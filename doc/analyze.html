<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"><title>Analysesoftware f&uuml;r &Uuml;bertragungsfunktions- und Hysterese-Messungen</title>

<link href="mm.css" rel="stylesheet" type="text/css"></head>
<body>
<a href="index.html">&rarr;&nbsp;Index</a>
<a href="glossary.html">&rarr;&nbsp;Glossar
</a>
<h1>Analysesoftware f&uuml;r &Uuml;bertragungsfunktions-
und Hysterese-Messungen</h1>
<p><span class="abstract">Release: 0.11</span></p>
<a href="#options">Parameter</a> <a href="#cal">Kalibrierung</a>
<a href="index.html#download">Download</a>
<a href="#history">Historie</a>
<a href="#todo">Todo</a>
<a href="index.html#build">Compilieren</a>
<h2><a name="description"></a>Kurzbeschreibung</h2>
<p>Dieses Programm analysiert einlaufende Messdaten in
Echtzeit und visualisiert die Ergebnisse z.B. mit
<a href="http://www.gnuplot.info">Gnuplot</a>. Das
Programm liegt als C++-Quelltext vor und sollte sich mit vertretbarem
Aufwand auf anderen Plattform &uuml;bersetzen lassen. F&uuml;r
die Fast-Fourier-Transformation kommt die Bibliothek <a href="http://www.fftw.org/">FFTW</a> in
der Version 2.x zum
Einsatz.</p>
<h3>Einsatzbereiche</h3>
<ul>
<li>Messung von <strong>Impedanzen</strong> oder <strong>&Uuml;bertragungsfunktionen</strong>
mit Rausch- oder <a href="glossar.html#MLS">MLS-Signalen</a>.</li>
<li>Messung von <strong>harmonischen Verzerrungen</strong>
mit speziellen Rauchsignalen.</li>
<li>Messung von <strong>Hysteresen</strong>.</li>
</ul>
<h3><a name="sequence" id="sequence"></a>Programmablauf</h3>
<blockquote>
<p>Das Programm liest kontinuierlich <strong>16-Bit
PCM-kodierte Daten in 2 Kan&auml;len</strong> von <tt><strong>stdin</strong></tt>,
einer <a href="#_in">Datei</a>&nbsp;und
analysiert
sie. Die Ergebnisse werden dann von Zeit zu Zeit in die <strong>Datei
<tt>data.dat</tt></strong> und/oder auf den
Bildschirm (<tt>stderr</tt>) geschrieben. Danach kann
optional ein Befehl &uuml;ber <tt>stdout</tt>
ausgegeben werden, z.B. zur Steuerung von Gnuplot. Das Programm endet,
wenn die angegebene <a href="#_ln">Zahl der Schleifen</a>
erreicht ist, der Eingabedatenstrom geschlossen wurde oder ein
Interrupt-Signal gesendet wird (z.B. Ctrl-C).</p>
<p>Die (plattformabh&auml;ngige) Beschaffung der PCM-Daten
sowie eine
eventuelle Pufferung, um die Datenentsorgung in Echtzeit
sicherzustellen, muss anderw&auml;rtig erfolgen.</p>
</blockquote>
<h3><a name="modes"></a>Messmodi</h3>
<blockquote>
<p>Das Programm unterst&uuml;tzt derzeit 3 verschiedene
Messmodi:</p>
<ul>
<li>
<p><strong><a name="mfft"></a><a href="glossary.html#LCR">LCR</a>-Analyse durch FFT</strong>
(Option <a href="#_mfft"><tt>mfft</tt></a>)</p>
<p> Hierbei wird versucht aus den per FFT gewonnenen Daten
eine Induktivit&auml;t oder Kapazit&auml;t und einen Widerstand
zu ermitteln. Dazu werden alle Messpunkte im Intervall [<a href="#_famin"><tt>famin</tt></a>, <a href="#_famax"><tt>famax</tt></a>] mit
ihren relativen Amplituden gewichtet und die Mittelwerte gebildet: </p>
<blockquote>
<p><a href="glossary.html#ESR"><var>ESR</var></a>
= &lt; <var>a<sub>i</sub></var> &gt;<br>
<a href="glossaryy.html#ESL"><var>ESL</var></a>
= &lt; <var>b<sub>i</sub></var> / <var>&omega;</var>
&gt;<br>
<a href="glossary.html#ESC"><var>ESC</var></a>
= &lt; &minus;<var>b<sub>i</sub></var>
&middot; <var>&omega;</var> &gt;</p>
</blockquote>
<p>Da die Ermittlung von ESC und ESL direkt korreliert ist,
sind
beide Werte nicht sinnvoll, wenn die zu messende Impedanz (im
relevanten Frequenzbereich) eine Kombination von Kapazit&auml;t und
Induktivit&auml;t ist. Aus den Standardabweichungen bekommt man
zus&auml;tzlich eine Hausnummer &uuml;ber die
Verl&auml;sslichkeit der
ermittelten Werte.</p>
<p>Wenn die zu messenden Bauteile ESR, ESL oder ESC
frequenzabh&auml;ngig &auml;ndern, sind die angezeigten
Mittelwerte nicht sinnvoll. In dem Fall muss auf die <a href="#_wd">detaillierten,
frequenzabh&auml;ngigen Daten</a> zur&uuml;ckgegriffen
werden. Dies ist eher die Regel denn die Ausnahme.</p>
</li>
</ul>
<ul>
<li>
<p><a name="mpca"></a><a href="glossary.html#LCR"><strong>LCR</strong></a><strong>-Analyse
durch <a href="glossary.html#PCA">PCA</a></strong>
(Option <a href="#_mpca"><tt>mpca</tt></a>)</p>
<p>Bei der PCA-Methode wird die Spannung <var>U</var>(<var>t</var>)
als <em>Linearkombination</em> aus </p>
<ul>
<li> einem DC-Offset,</li>
<li>einem dem Strom <var>I</var>(<var>t</var>)
(ohmscher Anteil),</li>
<li>einem der Ableitung d<var>I</var>(<var>t</var>)/d<var>t</var>
(induktiver Anteil),</li>
<li>einem dem Integral &int; <var>I</var>(<var>t</var>)
d<var>t</var> (kapazitiver Anteil) und</li>
<li>einem zeitlichen Drift des DC-Offsets</li>
</ul>
<p> dargestellt. Mit dieser Methode ist es
m&ouml;glich, eine Serienschaltung von Widerstand,
Induktivit&auml;t <em>und</em> Kapazit&auml;t
sauber zu trennen. Vorausgesetzt es <em>ist</em> eine
Serienschaltung. F&uuml;r ESR-Messungen von Elkos eignet sie sich
daher nicht.<br>
Ein anderer Vorteil der Methode ist der verschwindend geringe
Rechenzeit. Die Aufwandsklasse ist O(n) in der Zahl der
Messpunkte und die Berechnung kann auch auf sehr langsamen CPUs
on-the-fly
erfolgen.</p>
</li>
<li>
<p><strong><a name="mxy"></a>Kennlinienmessung</strong>
(Option <a href="#_mxy"><tt>mxy</tt></a>)</p>
<p>Bei dieser Messmethode wird direkt <var>I</var>(<var>t</var>)
&uuml;ber <var>U</var>(<var>t</var>)
aufgetragen. Was sich am einfachsten anh&ouml;rt, ist faktisch am
schwierigsten, da aufgrund der Kompensationen zuerst eine
Transformation in den Frequenzraum (DFT) und anschlie&szlig;end
zur&uuml;ck in den Zeitraum erforderlich ist. Zus&auml;tzlich
werden
bei dieser Methode auch noch die Integrale <var>U</var>(<var>t</var>)&nbsp;d<var>t</var>
und <var>I</var>(<var>t</var>)&nbsp;d<var>t</var>
sowie die Ableitungen <var>U</var>(<var>t</var>)/d<var>t</var>
und <var>I</var>(<var>t</var>)/d<var>t</var>
berechnet. Aus verschiedenen Gr&uuml;nden erfolgt deren Berechnung
im
Frequenzraum. Dadurch sind faktisch 2
Vorw&auml;rts-Transformationen
und 6 R&uuml;cktransformationen pro Datenpaket erforderlich.</p>
<p>Lohn der M&uuml;he ist z.B., dass mit sehr einfachen
Mitteln die Hysteresen von Spulenkernen gemessen werden
k&ouml;nnen, da <var>I</var>&nbsp;&prop;&nbsp;<var>V</var>&nbsp;&prop;&nbsp;<var>H</var>
und
&int;&nbsp;<var>U</var>(<var>t</var>)&nbsp;d<var>t</var>&nbsp;&prop;&nbsp;<var>&Phi;</var>&nbsp;&prop;&nbsp;<var>B</var>
ist.</p>
</li>
</ul>
<p>Die Messmodi FFT und PCA k&ouml;nnen kombiniert werden.
Dadurch
steht neben den genaueren LCR-Werten der PCA-Methode auch das Ergebnis
der Fourier-Transformation zur Verf&uuml;gung, aus dem sehr leicht <var>ESC</var>(<var>f</var>)
bzw. <var>ESL</var>(<var>f</var>) und <var>ESR</var>(<var>f</var>)
extrahiert werden kann.</p>
</blockquote>
<h2><a name="options"></a>Kommandozeilenparameter<br>
</h2>
<h3>&Uuml;bersicht</h3>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Option</th>
<th>Bedeutung</th>
<th>Standard</th>
<th>Kategorie</th>
</tr>
<tr>
<td><tt>ainc</tt></td>
<td>Inkrementeller Modus</td>
<td>aus</td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>al</tt></td>
<td>Mehrere Zyklen addieren</td>
<td><tt>1</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>bin</tt></td>
<td>FFT-Kan&auml;le zusammenfassen</td>
<td><tt>1</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>ca</tt></td>
<td>Samples zusammenfassen</td>
<td><tt>1</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>df</tt></td>
<td>Name der Datendatei</td>
<td><tt>data.dat</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>exec</tt></td>
<td>Kommando nach jeder Analyse</td>
<td>-</td>
<td>Programmablauf</td>
</tr>
<tr>
<td><tt>famin famax</tt></td>
<td>Frequenzbereich f&uuml;r die LCR-Analyse</td>
<td>fmin bzw. fmax</td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>fbin</tt></td>
<td>FFT-Kan&auml;le progressiv zusammenfassen</td>
<td><tt>0</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>fmin fmax</tt></td>
<td>Frequenzbereich f&uuml;r die Analyse</td>
<td><tt>0</tt> bzw. Nyquist Freq.</td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>fq</tt></td>
<td>Samplingfrequenz</td>
<td><tt>48000</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>g2f</tt></td>
<td>Dateiname f&uuml;r Validierung der <a href="analyze.html#gain-cal">Gainkalibrierung</a></td>
<td><tt>gainD.dat</tt></td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>gd</tt></td>
<td>Verifikation der <a href="analyze.html#gain-cal">Gainkalibrierung</a>
durchf&uuml;hren</td>
<td>aus</td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>gf</tt></td>
<td>Dateiname f&uuml;r die Gainkalibrierung</td>
<td><tt>gain.dat</tt></td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>gg</tt></td>
<td><a href="analyze.html#gain-cal">Gainkalibrierung</a>
durchf&uuml;hren</td>
<td>aus</td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>gr</tt></td>
<td><a href="analyze.html#gain-cal">Gainkalibrierung</a>
verwenden</td>
<td>aus</td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>h/f</tt></td>
<td>1/<var>f</var>-Gewichtung</td>
<td>Standardgewichtung</td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>harm</tt></td>
<td>Die ersten <i><tt>n</tt></i>
Harmonischen ber&uuml;cksichtigen</td>
<td><tt>0</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>hd</tt></td>
<td>Gewichtsfunktion f&uuml;r differenziellen
Scanmodus</td>
<td>Standardgewichtung</td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>he</tt></td>
<td>Gewichtung deaktivieren</td>
<td>Standardgewichtung</td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>in</tt></td>
<td>Eingabedateiname</td>
<td>stdin</td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>ln</tt></td>
<td>Nach <i><tt>n</tt></i>
Analysen stoppen</td>
<td><tt>1</tt></td>
<td>Programmablauf</td>
</tr>
<tr>
<td><tt>loop</tt></td>
<td>In Endlosschleife analysieren</td>
<td>aus</td>
<td>Programmablauf</td>
</tr>
<tr>
<td><tt>lp</tt></td>
<td>Pause bei der <a href="analyze.html#gain-cal">Nullkalibrierung</a></td>
<td><tt>10</tt></td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>lvl</tt></td>
<td>St&ouml;rpegel f&uuml;r Gewichtung</td>
<td><tt>1</tt></td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>mfft mpca mxy</tt></td>
<td>Analysemodus</td>
<td>keine</td>
<td>Programmablauf</td>
</tr>
<tr>
<td><tt>mst</tt></td>
<td>Stereo Modus</td>
<td>aus</td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>n</tt></td>
<td>Analyseblockl&auml;nge</td>
<td><tt>8192</tt></td>
<td>allg. Parameter</td>
</tr>
<tr>
<td><tt>olf olc</tt></td>
<td>Dateiname und Spalte zum &uuml;berschreiben des
Nutzsignals</td>
<td>keine bzw. <tt>1</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>orf orc</tt></td>
<td>Dateiname und Spalte zum &uuml;berschreiben des
Referenzsignals</td>
<td>keine bzw. <tt>1</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>pdc</tt></td>
<td>Die ersten Frequenzkan&auml;le nullen</td>
<td><tt>1</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>phcc</tt></td>
<td>Gruppenlaufzeit anpassen</td>
<td>aus</td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>phl</tt></td>
<td>Konstante Gruppenlaufzeit abziehen</td>
<td><tt>0</tt></td>
<td>FFT-Parameter</td>
</tr>

<tr>
<td><tt>plot</tt></td>
<td>Ausgabe nach stdout nach jeder Analyse</td>
<td>keine</td>
<td>Programmablauf</td>
</tr>
<tr>
<td><tt>psa</tt></td>
<td>Die ersten <kbd><var>num</var></kbd>
Samples verwerfen</td>
<td><tt>0</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>pte</tt></td>
<td>Eingabedatenstrom bis zum Ende lesen</td>
<td>aus</td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>rf</tt></td>
<td>Dateiname f&uuml;r Rohdaten</td>
<td><tt>raw.dat</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>rref</tt></td>
<td>Referenzwiderstand</td>
<td><tt>1</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>scm</tt></td>
<td>Scanmodus</td>
<td><tt>1</tt></td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>wd</tt></td>
<td>Daten nach jeder Analyse schreiben</td>
<td>aus</td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>wf</tt></td>
<td>Dateiname f&uuml;r die Fensterfunktion</td>
<td><tt>window.dat</tt></td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>win</tt></td>
<td>Fensterfunktion</td>
<td>aus/Rechteck</td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>wr</tt></td>
<td>Rohdaten schreiben</td>
<td>aus</td>
<td>Eingabedaten</td>
</tr>
<tr>
<td><tt>ww</tt></td>
<td>Fensterfunktion schreiben</td>
<td>aus</td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>z2f</tt></td>
<td>Dateiname f&uuml;r Validierung der Nullkalibrierung</td>
<td><tt>zeroD.dat</tt></td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>zd</tt></td>
<td>Validierung der <a href="analyze.html#gain-cal">Nullkalibrierung</a>
durchf&uuml;hren</td>
<td>aus</td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>zf</tt></td>
<td>Dateiname f&uuml;r Nullkalibrierung</td>
<td><tt>zero.dat</tt></td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>zg</tt></td>
<td>Nullkalibrierung durchf&uuml;hren</td>
<td>aus</td>
<td>Kalibrierung</td>
</tr>
<tr>
<td><tt>zn</tt></td>
<td>Amplituden normalisieren</td>
<td>aus</td>
<td>FFT-Parameter</td>
</tr>
<tr>
<td><tt>zr</tt></td>
<td>Nullkalibrierung verwenden</td>
<td>aus</td>
<td>Kalibrierung</td>
</tr>
</tbody>
</table>
<h3><a name="input_options"></a>Eingabedaten</h3>
<blockquote>
<dl compact="compact">
<dt><kbd><a name="_ainc"></a>ainc</kbd></dt>
<dd>Inkrementeller Modus. Es werden alle Rohdaten in Zyklen
der <a href="#_n">FFT-L&auml;nge</a>
aufaddiert. Dadurch wird ein kontinuierlich genauer werdender
Mittelwert gebildet. Das zu messende Objekt muss dabei
nat&uuml;rlich in
seinen Eigenschaften stabil bleiben.<br>
Diese Methode eignet sich in Kombination mit MLS- oder Rauschsignalen
besonders als
Alternative zum Sweep.</dd>
<dt><kbd><a name="_al"></a>al<var>num</var></kbd></dt>
<dd>Mehrere Zyklen addieren. Dabei werden erst die Rohdaten
von <kbd><var>num</var></kbd> Messzyklen
addiert, bevor die Analyse startet.</dd>
<dt><kbd><a name="_ca"></a>ca<var>num</var></kbd></dt>
<dd>Addiert immer <var><kbd>num</kbd></var>
benachbarte Samples
bei der Verarbeitung der PCM-Daten. Dieses Feature kann genutzt werden,
um die Samplingrate zu dr&uuml;cken und gleichzeitig das Rauschen
zu
mindern. Es handelt sich dabei nicht um eine geeignete Methode zum
Downsampeln, sondern eher um eine Methode zur Reduktion des
ADC-Rauschens.<br>
Fehlt der Parameter <var><kbd>num</kbd></var>,
so werden je 2 Samples addiert und die effektive Samplingrate halbiert.</dd>
<dt><kbd><a name="_in"></a>in<var>filename</var></kbd></dt>
<dd>PCM-Daten aus <var><kbd>filename</kbd></var>
lesen (anstelle von <tt>stdin</tt>). Der angegebene Name
kann auch ein transienter Datenstrom, wie z.B. eine Pipe oder ein
Device sein.</dd>
<dt><kbd><a name="_olc"></a>olc<var>column</var></kbd></dt>
<dd>Spalte in der Datei zum &uuml;berschreiben des
Nutzsignals.</dd>
<dt><kbd><a name="_olf"></a>olf<var>file</var></kbd></dt>
<dd>Nutzsignal (standardm&auml;&szlig;ig linker
Kanal) mit Spalte aus <var><kbd>file</kbd></var>
&uuml;berschreiben.</dd>
<dt><kbd><a name="_orc"></a>orc<var>column</var></kbd></dt>
<dd>Spalte in der Datei zum &uuml;berschreiben des
Referenzsignals.</dd>
<dt><kbd><a name="_orf"></a>orf<var>file</var></kbd></dt>
<dd>Referenzsignal (standardm&auml;&szlig;ig rechter
Kanal) mit Spalte aus <var><kbd>file</kbd></var>
&uuml;berschreiben.</dd>
<dt><kbd><a name="_psa"></a>psa<var>num</var></kbd></dt>
<dd>Die ersten <kbd><var>num</var></kbd>
Samples verwerfen. Dies
kann benutzt werden, um nach dem Start einer Messung auf einen
eingeschwungenen Zustand zu warten, aber auch, um eventuelle
Header-Daten in einem PCM-Datenstrom zu &uuml;berspringen (z.B. <kbd>pca11</kbd>
f&uuml;r <tt>.WAV</tt>-Dateien).</dd>
<dt><kbd><a name="_rf"></a>rf<var>filename</var></kbd></dt>
<dd>Dateiname f&uuml;r die Ausgabe der Quelldaten (Option
<a href="analyze.html#_wr"><kbd>wr</kbd></a>).
Standardm&auml;&szlig;ig hei&szlig;t die Datei <tt>raw.dat</tt>.</dd>
<dt><kbd><a name="_scm"></a>scm0</kbd>,
<kbd>scm1</kbd> oder <kbd>scm2</kbd></dt>
<dd>Modus bei der Entgegennahme der PCM-Daten:<br>
<kbd>scm0</kbd> &ndash; PCM-Reihenfolge:
Kanal&nbsp;1 = <var>U</var>(<var>t</var>),
Kanal&nbsp;2 = <var>I</var>(<var>t</var>)<br>
<kbd>scm1</kbd> &ndash; Differenzmodus: <var>U</var>(<var>t</var>)
= Kanal 1, <var>I</var>(<var>t</var>) =
Kanal&nbsp;2 &minus; Kanal&nbsp;1<br>
<kbd>scm2</kbd> &ndash; Kan&auml;le
vertauschen: Kanal&nbsp;1 = <var>I</var>(<var>t</var>),
Kanal&nbsp;2 = <var>U</var>(<var>t</var>)<br>
Der Differenzmodus ist praktisch, weil er sehr einfache
Impedanzmessungen durch die Reihenschaltung eines Referenzwiderstandes
mit der zu messenden Impedanz ohne Instrumentenverst&auml;rker
erlaubt.
Allerdings reagiert dieser Modus aufgrund der Differenzbildung von
&auml;hnlich gro&szlig;en Zahlen auch sehr allergisch auf
kleinste
Asymmetrien zwischen den beiden Kan&auml;len.</dd>
<dt><kbd><a name="_wr"></a>wr</kbd></dt>
<dd>Rohdaten in die Datei <tt>raw.dat</tt> oder
die mit der Option <a href="#_rf"><kbd>rf</kbd></a>
angegebene Datei schreiben. Das sind die Daten, wie sie aus dem
Eingabedatenstrom kommen. Die Option ist normalerweise nur zur
Fehlersuche gedacht. <a href="#raw_dat">&rarr;Dateiformat</a></dd>
</dl>
</blockquote>
<h3><a name="control_options"></a>Programmablauf</h3>
<blockquote>
<dl compact="compact">
<dt><kbd><a name="_exec"></a>exec<var>command</var></kbd></dt>
<dd>Kommando, das nach dem Wegschreiben der Daten jedesmal
ausgef&uuml;hrt wird. Achtung! Das Analyseprogramm stoppt bis zur
Beendung des Kommandos. Das kann bei der Echtzeitverarbeitung der Daten
problematisch werden. Daher ist im allgemeinen die Synchronisation
&uuml;ber <tt>stdout</tt> (Option <a href="analyze.html#_plot"><kbd>plot</kbd></a>)
vorzuziehen.</dd>
<dt><kbd><a name="_ln"></a>ln<var>num</var></kbd></dt>
<dd><kbd><var>num</var></kbd>
Einzelanalysen in Folge
durchf&uuml;hren und das Programm danach beenden.
Standardm&auml;&szlig;ig wird nur exakt ein Durchlauf
ausgef&uuml;hrt.</dd>
<dt><kbd><a name="_loop"></a>loop</kbd></dt>
<dd>Endlosmodus. Das Programm kann nur durch ein Ende der
Eingabedaten oder einer Abbruch gestoppt werden. Bei der Verwendung des
Endlosmodus zur Echtzeitverarbeitung transienter Eingabedaten sollte
man vorher mit einer endlichen Zahl an Schleifendurchl&auml;ufen
(Option <a href="analyze.html#_ln"><kbd>ln</kbd></a>)
getestet haben, ob die
Verarbeitung in Echtzeit mit den angegebenen Optionen
&uuml;berhaupt
mit unter 100% Systemlast m&ouml;glich ist.</dd>
<dt><kbd><a name="_mfft"></a>mfft</kbd></dt>
<dd>Messmodus <a href="analyze.html#mfft">FFT-Analyse</a>
verwenden.</dd>
<dt><kbd><a name="_mpca" id="_mpca"></a>mpca</kbd></dt>
<dd>Messmodus <a href="analyze.html#mpca">PCA-Analyse</a>
verwenden.</dd>
<dt><kbd><a name="_mfft"></a>mxy</kbd></dt>
<dd><a href="analyze.html#mxy">Kennlinienmodus</a>
verwenden.</dd>
<dt><kbd><a name="_plot" id="_plot"></a>plot<var>command</var></kbd></dt>
<dd>Kommando nach jedem Analyseergebnis &uuml;ber <tt>stdout</tt>
als eigene Zeile ausgeben. Dies kann z.B. verwendet werden, um eine
grafische Visualisierung z.B. durch Gnuplot in Echtzeit zu
aktualisieren.</dd>
<dt><kbd><a name="_pte"></a>pte</kbd></dt>
<dd>Nach Beendigung der angegebenen Anzahl an
Analyse-Durchl&auml;ufen (Option <a href="analyze.html#_ln"><kbd>ln</kbd></a>)
weiterhin Daten lesen, diese jedoch verwerfen. Dies kann
n&uuml;tzlich
sein, wenn Echtzeit-Datenquellen allergisch reagieren, wenn sie ihren
Daten nicht mehr los werden und auf anderem Wege gestoppt werden
m&uuml;ssen. Das verhindert letztlich auch das Programmende,
solange
noch Eingabedaten kommen. Wenn der Eingabedatenstrom abbricht, wird das
Programm dann beendet.</dd>
</dl>
</blockquote>
<h3><a name="param_options"></a>Allgemeine
Parameter</h3>
<blockquote>
<dl compact="compact">
<dt><kbd><a name="_al"></a>al<var>num</var></kbd></dt>
<dd>Mehrere Zyklen addieren. Dabei werden erst die Rohdaten
von <kbd><var>num</var></kbd> Messzyklen
addiert, bevor die Analyse startet.</dd>
<dt><kbd><a name="_famin"></a><a name="_famax"></a>famin<var>freq</var></kbd>
und <kbd>famax<var>freq</var></kbd></dt>
<dd>Minimale und maximale Frequenz, die bei der Analyse der
FFT-Daten herangezogen wird. Damit kann die Analyse an die Bandbreite
der verwendeten Komponenten angepasst werden. Im Gegensatz zu <a href="analyze.html#_fmin"><kbd>fmin</kbd></a>
und <a href="analyze.html#_fmax"><kbd>fmax</kbd></a>
werden dennoch alle Daten in die Datendatei geschrieben. Die
Einstellung wirkt sich nur auf die am Bildschirm angezeigten Resultate
aus.</dd>
<dt><kbd><a name="_fmin"></a><a name="_fmax"></a>fmin<var>freq</var></kbd>
und <kbd>fmax<var>freq</var></kbd></dt>
<dd>Minimale und maximale Frequenz bei der FFT-Analyse, die
&uuml;berhaupt in irgendeiner Weise bearbeitet wird. Diese
Einstellung
wirkt sich auf <em>alle</em> Folgeprozesse
einschlie&szlig;lich der
Berechnung der Kalibrierungsdaten etc. aus. Sie kann z.B. verwendet
werden, um st&ouml;rende Artefakte an den Randbereichen des
Frequenzspektrums aus grafischen Darstellungen zu entfernen.</dd>
<dt><kbd><a name="_fq"></a>fq<var>freq</var></kbd></dt>
<dd>Prim&auml;re Samplingfrequenz vor einer eventuellen
Reduzierung durch <a href="analyze.html#_ca">Sampleaddition</a>.
Dieser Parameter <strong>sollte immer angegeben werden</strong>,
da er f&uuml;r diverse Normierungen ben&ouml;tigt wird. Unter
anderem bei der Bildung zeitlicher Ableitungen.<br>
Ohne den Parameter wird derzeit von einer Samplingfrequenz von
48&nbsp;kHz
ausgegangen. Zuk&uuml;nftige Programmversionen k&ouml;nnten
dies jedoch
als einen Fehler werten.</dd>
<dt><kbd><a name="_h_f"></a>h/f</kbd></dt>
<dd>Automatische Gewichtsfunktion bei der Analyse der
FFT-Daten durch eine 1/<var>f</var>-Gewichtung ersetzen.</dd>
<dt><kbd><a name="_hd"></a>hd</kbd></dt>
<dd>Automatische Gewichtsfunktion f&uuml;r den
differenziellen Scanmodus <a href="analyze.html#_scm"><kbd>scm1</kbd></a>
aktivieren.</dd>
<dt><kbd><a name="_he"></a>he</kbd></dt>
<dd>Gewichtung der Messpunkte bei der Analyse der FFT-Daten
deaktivieren.</dd>
<dt><kbd><a name="_lvl"></a>lvl<var>level</var></kbd></dt>
<dd>St&ouml;rpegel f&uuml;r die automatische
Gewichtung der
Messpunkte bei der FFT-Analyse. Messpunkte mit Amplituden unterhalb
dieses St&ouml;rpegels werden gar nicht verwendet.</dd>
<dt><kbd><a name="_n"></a>n<var>num</var></kbd></dt>
<dd>L&auml;nge der Datenbl&ouml;cke f&uuml;r alle
Messmodi auf <var><kbd>num</kbd></var>
festlegen. (FFT-L&auml;nge, Samples pro PCA-Analyse, Samples pro
Kennlinie). Diese Zahl ist <em>nach</em> einer eventuellen
Zusammenfassung von
Samples durch die Option <a href="analyze.html#_ca"><kbd>ca</kbd></a>
zu verstehen.<br>
Ohne die Option <kbd>n</kbd> wird eine
Standardl&auml;nge von 8192 Samples verwendet.</dd>
<dt><kbd><a name="_rref"></a>rref<var>res</var></kbd></dt>
<dd>Referenzwiderstand <var><kbd>res</kbd></var>
bei der Analyse
von Impedanzdaten ber&uuml;cksichtigen.
Standardm&auml;&szlig;ig wird
ein Wert von 1.0 verwendet. Das ist auch dann zu verwenden, wenn die
Umrechnung bereits an anderer Stelle bei der Datenaufbereitung erfolgt.</dd>
</dl>
</blockquote>
<h3><a name="fft_options"></a>FFT-Parameter</h3>
<blockquote>
<dl compact="compact">
<dt><kbd><a name="_bin"></a>bin<var>size</var></kbd></dt>
<dd>Fasst <var><kbd>size</kbd></var>
benachbarte
Frequenzkan&auml;le bei der Fouriertransformation zusammen und
mittelt.
Mit der Methode kann man schnell mal das Rauschen etwas mindern, um zu
sehen, ob man auf dem richtigen Weg ist. Als Dauerl&ouml;sung ist
eine
k&uuml;rzere FFT-L&auml;nge gefolgt von einer Mittelung
&uuml;ber
mehrere Messintervalle die bessere Methode.</dd>
<dt><kbd><a name="_df"></a>df<var>filename</var></kbd></dt>
<dd>Name der Datendatei, die bei aktivierter Option <a href="analyze.html#_wd"><kbd>wd</kbd></a>
(regelm&auml;&szlig;ig) geschrieben wird.
Standardm&auml;&szlig;ig heisst die Datei <tt>data.dat</tt>.</dd>
<dt><kbd><a name="_fbin"></a>fbin<var>factor</var></kbd></dt>
<dd>Relativer Binsize Faktor. Diese Option fasst benachbarte
Frequenzkan&auml;le bei der Analyse der FFT-Daten genau dann
zusammen,
wenn sie in das Intervall [<var>f</var>,&nbsp;<var>f</var>&nbsp;&middot;&nbsp;(<kbd><var>factor</var></kbd>&nbsp;+&nbsp;1)]
passen. Diese Option ist sehr n&uuml;tzlich, wenn es in der Natur
der
analysierten Daten liegt, ihre Eigenschaften eher &uuml;ber
log&nbsp;<var>f</var> zu &auml;ndern als mit der
Frequenz <var>f</var>.
Anders formuliert: wenn das Ergebnis in der Datendatei logarithmisch
dargestellt werden soll, ist diese Option dringend zu empfehlen, da
dann in etwa in log&nbsp;<var>f</var>
&auml;quidistante St&uuml;tzpunkte entstehen.</dd>
<dt><kbd><a name="_harm"></a>harm<var>n</var></kbd></dt>
<dd>Die ersten <i><tt>n</tt></i>
Harmonischen ber&uuml;cksichtigen. Diese Funktion setzt die <a href="noise.html#_harm">gleichnamige Option bei der
Generierung des Referenzsignals</a> voraus. Siehe <a href="analyze.html#harmonics">Analyse von Harmonischen</a>.</dd>
<dt><kbd><a name="_mst"></a>mst</kbd></dt>
<dd>Stereomodus
aktivieren. Im Stereomodus werden die Analysen von Frequenzen mit
Intensit&auml;t (siehe harm) abwechselnd dem einen oder anderen
Kanal
zugeordnet. Dies ist vorrangig im Zusammenhang mit der Zusammenfassung
von Kan&auml;len relevant. Siehe <a href="analyze.html#multichannel">Mehrkanalmessungen</a>.</dd>
<dt><kbd><a name="_pdc"></a>pdc<var>num</var></kbd></dt>
<dd>Die ersten <var><kbd>num</kbd></var>
Frequenzkan&auml;le bei der
FFT-Analyse nullen. Diese Option kann alternativ zu <a href="analyze.html#_fmin"><kbd>fmin</kbd></a>
verwendet werden, um zu verhindern, dass nicht relevante DC-Offsets die
automatische Achsenskalierung einer Grafik negativ beeinflussen. Im
Gegensatz zu <kbd>fmin</kbd> werden die Zeilen dennoch in
die
Ergebnisdateien geschrieben und nicht initialisierte Werte in den
Kalibrierungsdateien vermieden. Das kann jedoch nach hinten losgehen,
wenn sich einer dieser Werte im Nenner einer Folgekalkulation
wiederfindet (z.B. der Strom bei der Impedanzberechnung). Deshalb wird
sicherheitshalber auch nicht 0, sondern nur ein sehr kleiner Wert
verwendet.</dd>
<dt><kbd><a name="_phcc"></a>phcc</kbd></dt>
<dd>Gruppenlaufzeit
zwischen Nutz und Referenzsignal per Kreuzkorrelation mit dem
Referenzsignal automatisch korrigieren. Diese Option ist
n&ouml;tig, falls
die Daten eine Verz&ouml;gerung enthalten, die in die
Gr&ouml;&szlig;enordnung der
FFT-L&auml;nge vordringen kann, da andernfalls die Phasen beim
zusammenfassen der Kan&auml;le nicht zuverl&auml;ssig
ausgewickelt werden k&ouml;nnen.
Wenn die Option aktiviert ist, erfolgt eine zus&auml;tzliche
Ausgabe der
angepassten Verz&ouml;gerung bei der Analyse. Die Daten in der <a href="#_wd">Ausgabedatei</a> enthalten die Verz&ouml;gerung dann aber nicht mehr.</dd>
<dt><kbd><a name="_phl"></a>phl<var>delay</var></kbd></dt>
<dd>Konstante Gruppenlaufzeit von den Phasendaten abziehen. <var><kbd>delay</kbd></var>
ist in Sekunden anzugeben.</dd><dt><kbd><a name="_wd"></a>wd</kbd></dt>
<dd>Ausf&uuml;hrliche Ergebnisse nach Abschluss (je)der
Analyse in die Datei <tt>data.dat</tt> oder die mit der
Option <a href="analyze.html#_df"><kbd>df</kbd></a>
angegebene Datei schreiben. <a href="analyze.html#data_dat">&rarr;Dateiformat</a></dd>
<dt><kbd><a name="_wf"></a>wf<var>filename</var></kbd></dt>
<dd>Dateiname f&uuml;r die Ausgabe der Fensterfunktion
(Option <a href="analyze.html#_ww"><kbd>ww</kbd></a>).
Standardm&auml;&szlig;ig hei&szlig;t die Datei <tt>window.dat</tt>.</dd>
<dt><kbd><a name="_win"></a>win<var>typ</var></kbd></dt>
<dd>Festerfunktion vor der FFT-Analyse verwenden. Derzeit
gibt sind folgende Fensterfunktionen implementiert:<br>
<kbd>win0</kbd> &ndash; Rechteckfenster = keine
Fensterfunktion<br>
<kbd>win1</kbd> &ndash; Bartlett-Fenster =
Dreieck-Fenster, abs(2&nbsp;<var>i</var>/<var>n&nbsp;</var>&minus;&nbsp;1)<br>
<kbd>win2</kbd> &ndash; Hanning-Fenster,
.5&nbsp;&minus;&nbsp;.5&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
<kbd>win3</kbd> &ndash; Hamming-Fenster,
.54&nbsp;&minus;&nbsp;.46&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
<kbd>win4</kbd> &ndash; Blackman-Fenster,
.42&nbsp;&minus;&nbsp;.5&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)
+&nbsp;.08&nbsp;cos(4&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
<kbd>win5</kbd> &ndash; Blackman-Harris-Fenster,
.35875&nbsp;&minus;&nbsp;.48829&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)
+&nbsp;.14128&nbsp;cos(4&pi;&nbsp;<var>i</var>/<var>n</var>)
&minus;&nbsp;.01168&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
Fehlt die Angabe <var> <kbd>typ</kbd></var>,
so wird ein Hanning-Fenster verwendet. Das ist i.A. ein brauchbarer
Kompromiss zwischen Trennsch&auml;rfe und St&ouml;rpegel.<br>
Eine Fensterfunktion sollte nur verwendet werden, wenn es nicht
m&ouml;glich ist, das Referenzsignal passend zur FFT-L&auml;nge
periodisch zu gestalten.</dd>
<dt><kbd><a name="_ww"></a>ww</kbd></dt>
<dd>Fensterfunktion Schreiben. Mit dieser Option wird die mit
der Option <a href="analyze.html#_win"><kbd>win</kbd></a>
ausgew&auml;hlte Fensterfunktion in die date <tt>window.dat</tt>
oder die mit der Option <a href="analyze.html#_wf"><kbd>wf</kbd></a>
angegebene Datei geschrieben. <a href="analyze.html#window_dat">&rarr;Dateiformat</a></dd>
<dt><kbd><a name="_zn"></a>zn</kbd></dt>
<dd>Amplituden normalisieren. Dabei wird die Summe der
komplexen
Amplituden von Kanal 1 und Kanal 2 f&uuml;r alle
Frequenzkan&auml;le
einzeln vor der Weiterverarbeitung auf konstant 1 normiert. Dies hat
bei Impedanzmessungen zun&auml;chst einmal keine Auswirkung, da nur
die
relativen, komplexen Amplituden (<var>U</var>(<var>f</var>)&nbsp;/<var>&nbsp;I</var>(<var>f</var>))
verwendet werden. Sollen jedoch die Ergebnisse verschiedener Messungen
direkt ins Verh&auml;ltnis gesetzt werden, wie es bei der
Null-Kalibrierung der Fall ist, bekommt diese Option durchaus Relevanz,
da nun auch Daten ins Verh&auml;ltnis gesetzt werden
k&ouml;nnen, bei
denen das Referenzsignal aus technischen Gr&uuml;nden nicht exakt
&uuml;bereinstimmt.</dd>
</dl>
</blockquote>
<h3><a name="calibrate_options"></a>Kalibrierung</h3>
<blockquote>
<dl compact="compact">
<dt><kbd><a name="_g2f"></a>g2f<var>filename</var></kbd></dt>
<dd>Dateiname f&uuml;r die Differenzdatei bei der
Validierung der Gain-Kalibrierung. Siehe Option <a href="analyze.html#_gd"><kbd>gd</kbd></a>.</dd>
<dt><kbd><a name="_gd"></a>gd</kbd></dt>
<dd>Validierung der <a href="analyze.html#gain-cal">Gainkalibrierung</a>
durchf&uuml;hren. Mit dieser Option wird eine vorhandene
Gain-Kalibrierung aus der Datei <tt>gain.dat</tt> oder der
mit der Option <a href="analyze.html#_gf"><kbd>gf</kbd></a>
angegebenen Datei angewendet und die sich danach immernoch ergebenden
Gain-Abweichungen in die Datei <tt>gainD.dat</tt> oder die
mit der Option <a href="analyze.html#_g2f"><kbd>g2f</kbd></a>
angegebene Datei geschrieben. Diese Option ist haupts&auml;chlich
zur Fehlersuche hilfreich.</dd>
<dt><kbd><a name="_gf"></a>gf</kbd></dt>
<dd>Dateiname f&uuml;r die Gainkalibrierung. Dieser
Dateiname ist f&uuml;r die Funktionen <a href="analyze.html#_gr"><kbd>gg</kbd></a>
und <a href="analyze.html#_gr"><kbd>gr</kbd></a>
relevant. Standardm&auml;&szlig;ig heisst die Datei <tt>gain.dat</tt>.</dd>
<dt><kbd><a name="_gg"></a>gg</kbd></dt>
<dd><a href="analyze.html#gain-cal">Gainkalibrierung</a>
durchf&uuml;hren. Das Ergebnis wird in die Datei <tt>gain.dat</tt>
oder der mit der Option <a href="analyze.html#_gf"><kbd>gf</kbd></a>
angegebenen Datei geschrieben. <a href="analyze.html#gain_dat">&rarr;Dateiformat</a></dd>
<dt><kbd><a name="_gr"></a>gr</kbd></dt>
<dd><a href="analyze.html#gain-cal">Gainkalibrierung</a>
aus einer fr&uuml;heren Kalibrierungsmessung verwenden. Die Daten
werden aus der Datei <tt>gain.dat</tt> oder der mit der
Option <a href="analyze.html#_gf"><kbd>gf</kbd></a>
angegebenen Datei gelesen. <a href="analyze.html#gain.dat">&rarr;Dateiformat</a></dd>
<dt><kbd><a name="_lp"></a>lp<var>num</var></kbd></dt>
<dd>Anzahl der zu verwerfenden Datenbl&ouml;cke in der
Pause der <a href="analyze.html#zero-cal">Nullwert-Kalibrierung</a>
(Option <kbd><a href="analyze.html#_zg">zg</a></kbd>).</dd>
<dt><kbd><a name="_z2f" id="_z2f"></a>z2f<var>filename</var></kbd></dt>
<dd>Dateiname f&uuml;r die Differenzdatei bei der
Validierung der Null-Kalibrierung. Siehe Option <a href="analyze.html#_zd"><kbd>zd</kbd></a>.</dd>
<dt><kbd><a name="_zd" id="_zd"></a>zd</kbd></dt>
<dd>Validierung der <a href="analyze.html#gain-cal">Null-Kalibrierung</a>
durchf&uuml;hren. Mit dieser Option wird eine vorhandene
Null-Kalibrierung aus der Datei <tt>zero.dat</tt> oder der
mit der Option <a href="analyze.html#_zf"><kbd>zf</kbd></a>
angegebenen Datei angewendet und die sich danach immernoch ergebenden
Nullwert-Abweichungen in die Datei <tt>zeroD.dat</tt> oder
die mit der Option <a href="analyze.html#_z2f"><kbd>z2f</kbd></a>
angegebene Datei geschrieben. Diese Option ist haupts&auml;chlich
zur Fehlersuche hilfreich.</dd>
<dt><kbd><a name="_zf"></a>zf</kbd></dt>
<dd>Dateiname f&uuml;r die Gainkalibrierung. Dieser
Dateiname ist f&uuml;r die Funktionen <a href="analyze.html#_zr"><kbd>zg</kbd></a>
und <a href="analyze.html#_zr"><kbd>zr</kbd></a>
relevant. Standardm&auml;&szlig;ig heisst die Datei <tt>zero.dat</tt>.</dd>
<dt><kbd><a name="_zg"></a>zg</kbd></dt>
<dd><a href="analyze.html#zero-cal">Null-Kalibrierung</a>
durchf&uuml;hren. Das Ergebnis wird in die Datei <tt>zero.dat</tt>
oder der mit der Option <a href="analyze.html#_zf"><kbd>zf</kbd></a>
angegebenen Datei geschrieben.</dd>
<dt><kbd><a name="_zr"></a>zr</kbd></dt>
<dd><a href="analyze.html#zero-cal">Null-Kalibrierung</a>
aus einer fr&uuml;heren Kalibrierungsmessung verwenden. Die Daten
werden aus der Datei <tt>zero.dat</tt> oder der mit der
Option <a href="analyze.html#_gf"><kbd>zf</kbd></a>
angegebenen Datei gelesen. <a href="analyze.html#gain_dat">&rarr;Dateiformat</a></dd>
</dl>
</blockquote>
<h3><a name="examples"></a>Beispiele</h3>
<blockquote>
<p>@@@TODO</p>
</blockquote>
<h2><a name="fileformat"></a>Dateiformate</h2>
<blockquote>
<p>Alle Dateien sind ASCII-Dateien, die aus Tabulator-separierten,
numerischen Spalten bestehen. Es gibt derzeit keine
Spalten&uuml;berschriften. Die Daten beginnen sofort mit Zeile 1.
Zuk&uuml;nftige Programmversionen k&ouml;nnten jedoch eine
&Uuml;berschriftszeile generieren. Diese ist an einem <strong><tt>#</tt></strong>
im ersten Zeichen zu erkennen und ebenfalls Tabulator-separiert. Im
folgenden sind die Bedeutungen der einzelnen Spalten beschrieben.</p>
</blockquote>
<h3><tt><a name="data_dat"></a>data.dat</tt>
&ndash; FFT-Modus</h3>
<blockquote>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Spalte</th>
<th>Kurzbezeichnung</th>
<th>Beschreibung</th>
</tr>
<tr>
<td>[1]</td>
<td><var>f</var></td>
<td>Frequenz</td>
</tr>
<tr>
<td>[2]</td>
<td>|<var>U</var>|</td>
<td>Amplitude von <var>U</var>(<var>f</var>)</td>
</tr>
<tr>
<td>[3]</td>
<td>arg <var>U</var></td>
<td>Phase von <var>U</var>(<var>f</var>)
in Grad</td>
</tr>
<tr>
<td>[4]</td>
<td>|<var>I</var>|</td>
<td>Amplitude von <var>I</var>(<var>f</var>)</td>
</tr>
<tr>
<td>[5]</td>
<td>arg&nbsp;<var>I</var></td>
<td>Phase von <var>I</var>(<var>f</var>)
in Grad</td>
</tr>
<tr>
<td>[6]</td>
<td>|<var>U</var>/<var>I</var>|</td>
<td>Amplitude der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
</tr>
<tr>
<td>[7]</td>
<td>arg <var>U</var>/<var>I</var></td>
<td>Phase der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
in Grad</td>
</tr>
<tr>
<td>[8]</td>
<td>re&nbsp;<var>U</var>/<var>I</var></td>
<td>Realteil der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
</tr>
<tr>
<td>[9]</td>
<td>im <var>U</var>/<var>I</var></td>
<td>Imagin&auml;rteil der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
</tr>
<tr>
<td>[10]</td>
<td><var>weight</var></td>
<td>relativer Gewichtungsfaktor</td>
</tr>
<tr>
<td>[11]</td>
<td><var>delay</var></td>
<td>Gruppenlaufzeit d(<var>U</var>/<var>I</var>)/d<var>&omega;</var>,
ergibt nur f&uuml;r Vierpolmessungen Sinn.</td>
</tr>
</tbody>
</table>
<p>F&uuml;r Vierpolmessungen ist&nbsp;<var>I</var>(<var>f</var>)
durch das Eingangssignal zu ersetzen und&nbsp;<var>U</var>(<var>f</var>)
durch das Ausgangssignal.</p>
<p>Aus den obigen Spalten k&ouml;nnen folgende,
frequenzabh&auml;ngigen Werte wie
folgt berechnet werden:</p>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Symbol</th>
<th>Bezeichnung</th>
<th>Formel</th>
<th>Einheit</th>
<th>Bemerkung</th>
</tr>
<tr>
<td valign="middle"><a href="glossary.htlm#ESR"><var>ESR</var></a></td>
<td valign="middle">&Auml;quivalenter
Serienwiderstand</td>
<td valign="middle">[8] &middot; <var>R<sub>ref</sub></var></td>
<td valign="middle">&Omega;</td>
<td valign="middle"></td>
</tr>
<tr>
<td valign="middle"><a href="glossary.html#ESC"><var>ESC</var></a></td>
<td valign="middle">&Auml;quivalente
Serienkapazit&auml;t</td>
<td valign="middle">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td align="center" nowrap="nowrap">-1</td>
</tr>
<tr>
<td style="border-top: 1px solid black;">2&pi;
&middot; [1] &middot; [9] &middot; <var>R<sub>ref</sub></var></td>
</tr>
</tbody>
</table>
</td>
<td valign="middle">F</td>
<td valign="middle">nur, wenn [9] &le; 0</td>
</tr>
<tr>
<td valign="middle"><a href="glossary.html#ESL"><var>ESL</var></a></td>
<td valign="middle">&Auml;quivalente
Serieninduktivit&auml;t</td>
<td valign="middle">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td align="center" nowrap="nowrap">[9]
&middot; <var>R<sub>ref</sub></var></td>
</tr>
<tr>
<td align="center">2&pi; &middot; [1]</td>
</tr>
</tbody>
</table>
</td>
<td valign="middle">H</td>
<td valign="middle">nur, wenn [9] &ge; 0</td>
</tr>
<tr>
<td valign="middle">|<var>Z</var>|</td>
<td valign="middle">Betrag der Impedanz</td>
<td valign="middle">[6] &middot; <var>R<sub>ref</sub></var></td>
<td valign="middle">&Omega;</td>
<td valign="middle"></td>
</tr>
<tr>
<td valign="middle"><var>Q</var></td>
<td valign="middle">Effektive G&uuml;te</td>
<td valign="middle">|[9]| / [8]</td>
<td valign="middle"></td>
<td valign="middle"></td>
</tr>
</tbody>
</table>
</blockquote>
<h3><tt>data.dat</tt> &ndash;Hysteresis-Modus</h3>
<blockquote>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Spalte</th>
<th>Kurzbezeichnung</th>
<th>Beschreibung</th>
</tr>
<tr>
<td>[1]</td>
<td><var>t</var></td>
<td>relativer Zeitindex (bei Zeile 1 immer 0)</td>
</tr>
<tr>
<td>[2]</td>
<td><var>U</var></td>
<td>Momentanwert <var>U</var>(<var>t</var>)</td>
</tr>
<tr>
<td>[3]</td>
<td><var>I</var></td>
<td>Momentanwert <var>I</var>(<var>t</var>)</td>
</tr>
<tr>
<td>[4]</td>
<td>TODO@@@</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>[5]</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>[6]</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>[7]</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</blockquote>
<h3><tt><a name="gain_dat"></a>gain.dat</tt></h3>
<blockquote>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Spalte</th>
<th>Kurzbezeichnung</th>
<th>Beschreibung</th>
</tr>
<tr>
<td>-</td>
<td>Zeilennummer</td>
<td>Die Zeilen werden in der Reihenfolge der
FFT-Frequenzen geschrieben, enthalten jedoch nicht die Frequenzkennung.</td>
</tr>
<tr>
<td>[1]</td>
<td><var>re</var></td>
<td>Realteil</td>
</tr>
<tr>
<td>[2]</td>
<td><var>im</var></td>
<td>Imagin&auml;rteil</td>
</tr>
<tr>
<td>[3]</td>
<td><var>abs</var></td>
<td>Betrag</td>
</tr>
<tr>
<td>[4]</td>
<td><var>arg</var></td>
<td>Phase in Grad</td>
</tr>
</tbody>
</table>
<p>Beim Einlesen der Datei <tt>gain.dat</tt> mit
der Option <a href="#_gr"><tt>gr</tt></a>
oder <a href="#_gd"><tt>gd</tt></a>
werden nur die ersten beiden Spalten verwendet.</p>
</blockquote>
<h3><tt><a name="zero_dat"></a>zero.dat</tt></h3>
<blockquote>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Spalte</th>
<th>Kurzbezeichnung</th>
<th>Beschreibung</th>
</tr>
<tr>
<td>-</td>
<td>Zeilennummer</td>
<td>Die Zeilen werden in der Reihenfolge der
FFT-Frequenzen geschrieben, enthalten jedoch nicht die Frequenzkennung.</td>
</tr>
<tr>
<td>[1]</td>
<td>re <var>c<sub>ll</sub></var></td>
<td>Realteil Koeffizient <var>c<sub>ll</sub></var></td>
</tr>
<tr>
<td>[2]</td>
<td>im&nbsp;<var>c<sub>ll</sub></var></td>
<td>Imagin&auml;rteil Koeffizient <var>c<sub>ll</sub></var></td>
</tr>
<tr>
<td>[3]</td>
<td>re <var>c<sub>lr</sub></var></td>
<td>Realteil Koeffizient <var>c<sub>lr</sub></var></td>
</tr>
<tr>
<td>[4]</td>
<td>im <var>c<sub>lr</sub></var></td>
<td>Imagin&auml;rteil Koeffizient <var>c<sub>lr</sub></var></td>
</tr>
<tr>
<td>[5]</td>
<td>re <var>c<sub>rl</sub></var></td>
<td>Realteil Koeffizient <var>c<sub>rl</sub></var></td>
</tr>
<tr>
<td>[6]</td>
<td>im <var>c<sub>rl</sub></var></td>
<td>Imagin&auml;rteil Koeffizient <var>c<sub>rl</sub></var></td>
</tr>
<tr>
<td>[7]</td>
<td>re <var>c<sub>rr</sub></var></td>
<td>Realteil Koeffizient <var>c<sub>rr</sub></var></td>
</tr>
<tr>
<td>[8]</td>
<td>im <var>c<sub>rr</sub></var></td>
<td>Imagin&auml;rteil Koeffizient <var>c<sub>rr</sub></var></td>
</tr>
<tr>
<td>[9]</td>
<td>abs&nbsp;<var>c<sub>ll</sub></var></td>
<td>Betrag Koeffizient <var>c<sub>ll</sub></var></td>
</tr>
<tr>
<td>[10]</td>
<td>arg&nbsp;<var>c<sub>ll</sub></var></td>
<td>Phase Koeffizient <var>c<sub>ll</sub></var>
in Grad</td>
</tr>
<tr>
<td>[11]</td>
<td>abs <var>c<sub>lr</sub></var></td>
<td>Betrag Koeffizient <var>c<sub>lr</sub></var></td>
</tr>
<tr>
<td>[12]</td>
<td>arg <var>c<sub>lr</sub></var></td>
<td>Phase Koeffizient <var>c<sub>lr</sub></var>
in Grad</td>
</tr>
<tr>
<td>[13]</td>
<td>abs <var>c<sub>rl</sub></var></td>
<td>Betrag Koeffizient <var>c<sub>rl</sub></var></td>
</tr>
<tr>
<td>[14]</td>
<td>arg <var>c<sub>rl</sub></var></td>
<td>Phase Koeffizient <var>c<sub>rl</sub></var>
in Grad</td>
</tr>
<tr>
<td>[15]</td>
<td>abs <var>c<sub>rr</sub></var></td>
<td>Betrag Koeffizient <var>c<sub>rr</sub></var></td>
</tr>
<tr>
<td>[16]</td>
<td>arg <var>c<sub>rr</sub></var></td>
<td>Phase Koeffizient <var>c<sub>rr</sub></var>
in Grad</td>
</tr>
</tbody>
</table>
<p>Diese Datei enth&auml;lt ein Array von
komplexen 2&times;2 Matrizen der Form
<table style="display: inline; vertical-align: middle;" cellpadding="0" cellspacing="0" height="22" width="54">
<tbody>
<tr>
<td style="border-left: 1px solid black;"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
<td style="border-right: 1px solid black;"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
</tr>
<tr>
<td style="border-left: 1px solid black;"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
<td style="border-right: 1px solid black;"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
</tr>
</tbody>
</table>
.&nbsp;Beim Einlesen der Datei &uuml;ber die Option <a href="#_zr"><tt>zr</tt></a>
oder <a href="#_zd"><tt>zd</tt></a>
werden nur die ersten 8 Spalten verwendet. <a href="analyze.html#zero_cal">&rarr;Null-Kalibrierung</a></p>
<p>Die semantische Bedeutung der Koeffizienten ist:</p>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Koeffizient</th>
<th>Bedeutung</th>
</tr>
<tr>
<td><var>c<sub>ll</sub></var></td>
<td>Verst&auml;rkung f&uuml;r Kanal 1</td>
</tr>
<tr>
<td><var>c<sub>lr</sub></var></td>
<td>&Uuml;bersprechen von Kanal 2 auf Kanal 1</td>
</tr>
<tr>
<td><var>c<sub>rl</sub></var></td>
<td>&Uuml;bersprechen von Kanal 1 auf Kanal 2</td>
</tr>
<tr>
<td><var>c<sub>rr</sub></var></td>
<td>Verst&auml;rkung f&uuml;r Kanal 2</td>
</tr>
</tbody>
</table>
</blockquote>
<h3><tt><a name="window_dat"></a>window.dat</tt></h3>
<blockquote>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Spalte</th>
<th>Kurzbezeichnung</th>
<th>Beschreibung</th>
</tr>
<tr>
<td>-</td>
<td>Zeilennummer</td>
<td>Index des Samples</td>
</tr>
<tr>
<td>1</td>
<td><var>win</var></td>
<td>Wert der Fensterfunktion zum betreffenden Sample</td>
</tr>
</tbody>
</table>
</blockquote>
<h3><tt><a name="raw_dat"></a>raw.dat</tt></h3>
<blockquote>
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Spalte</th>
<th>Kurzbezeichnung</th>
<th>Beschreibung</th>
</tr>
<tr>
<td>-</td>
<td>Zeilennummer</td>
<td>Index des Samples</td>
</tr>
<tr>
<td>1</td>
<td><var>L</var></td>
<td>Wert des Samples von Kanal 1</td>
</tr>
<tr>
<td>1</td>
<td><var>R</var></td>
<td>Wert des Samples von Kanal 2</td>
</tr>
</tbody>
</table>
</blockquote>
<h2><a name="cal"></a>Kalibrierung</h2>
<h3><a name="gain-cal"></a>Gain-Kalibrierung</h3>
<blockquote>
<p>Bei der einfachsten Art der Kalibrierung wird mit einer
Messung lediglich der <em>Gleichlauf</em>
der beiden Kan&auml;le korrigiert. Damit k&ouml;nnen
Toleranzen der
Soundkarten sowie bauartbedingte Phasenverschiebungen zwischen den
beiden Kan&auml;len korrigiert werden. Das ist besonders dann
wichtig,
wenn im differentiellen <a href="#_scm">Scan-Modus</a>
(<tt>scm1</tt>) gearbeitet wird.</p>
<h4>Durchf&uuml;hrung</h4>
<p>Zur Gain-Kalibrierung m&uuml;ssen beide Kan&auml;le
von Line-In mit
einem der Line-Out Ausg&auml;nge verbunden werden.
Anschlie&szlig;end
ist mit wei&szlig;em Rauschen eine Kalibrierung mit der
Kommandozeilenoption <a href="#_gg"><tt>gg</tt></a>
durchzuf&uuml;hren. Die FFT- und Samplingparameter m&uuml;ssen
dabei
mit denen bei der zu korrigierenden realen Messung
&uuml;bereinstimmen.</p>
<h4>Ergebnis</h4>
<div class="rightbox" style="width: 371px;"><img src="images/GainSample.png" alt="Beispiel f&uuml;r Gainkorrektur" height="234" width="371"><br>
Beispiel f&uuml;r eine Gain-Korrektur: Terratec XLerate (Aureal
AU8820 Chip) bei 48kHz und einer FFT-L&auml;nge von 65536 Samples,
gemittelt &uuml;ber ca. 10 Zyklen.<br>
Der Amplitudenfehler ist mit &lt; 0,1dB ziemlich gut, aber die
Kan&auml;le werden offenbar nicht exakt gleichzeitig gesampelt. Die
Verschiebung von &frac14; Sample bei der Nyquist-Frequenz deutet auf
eine serielle Konvertierung der Kan&auml;le sowie ein
Zweifach-Oversampling zur Verminderung von Aliasing hin. </div>
<p>Das Resultat der Korrektur ist der komplexe,
frequenzabh&auml;ngige Quotient:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>gain_korr</var>(<var>f</var>)
=&nbsp;</td>
<td align="center" nowrap="nowrap">FFT(<var>Kanal
2</var>)</td>
</tr>
<tr>
<td style="border-top: 1px solid black;">FFT(<var>Kanal
1</var>)</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Der Betrag der Korrektur ist ein
frequenzabh&auml;ngiges Ma&szlig; f&uuml;r unterschiedliche
Verst&auml;rkungsfaktoren bei den beiden Stereokan&auml;len.
Typischerweise ist der Wert weitgehend frequenzabh&auml;ngig aber
leicht verschieden von eins. Das kommt durch Bauteiltoleranzen bei den
Widerst&auml;nden. Bei niedrigen Frequenzen gibt es
&uuml;blicherweise eine Gr&ouml;&szlig;ere Abweichung. Das
kommt durch Toleranzen bei den Koppelkondensatoren.</p>
<p>Die Phase ist ein Ma&szlig; f&uuml;r den zeitlichen
Gleichlauf der Kan&auml;le. Typischerweise gibt es au&szlig;er
der ebenfalls auf die Koppelkondensatoren
zur&uuml;ckzuf&uuml;hrenden Abweichung bei niedrigen Frequenzen
hier keine Besonderheiten. Manche Soundkarten digitalisieren aber den
rechten und den linken Kanal abwechselnd mit einem gemeinsamen ADC.
Dadurch sind die Signale um ein halbes Sample zeitverschoben, was sich
in einem linearen Anstieg der Phasendifferenz mit der Frequenz
&auml;u&szlig;ert.</p>
<h4>Korrektur</h4>
<p>Bei der Anwendung der Korrektur wird willk&uuml;rlich
nur
Kanal 1 korrigiert, da die Korrektur ohnehin nur relativ ist.</p>
</blockquote>
<h3><a name="zero-cal"></a>Null-Kalibrierung</h3>
<blockquote>
<p>Die bessere Art der Kalibrierung f&uuml;r
Impedanzmessungen (2-Pol)
ist die Null-Kalibrierung. Bei dieser wird neben dem
Verst&auml;rkungsfaktoren auch noch das <em>&Uuml;bersprechen</em>
mit ber&uuml;cksichtigt. Es handelt sich um eine <strong>Zwei-Punkt-Kalibrierung</strong>.</p>
<p>Unter Ber&uuml;cksichtigung von <var>L<sub>ideal</sub></var>&nbsp;&prop;&nbsp;<var>U</var>
und <var>R<sub>ideal</sub></var>&nbsp;&prop;&nbsp;<var>I</var>&nbsp;&middot;&nbsp;<var>R<sub>ref</sub></var>
ergibt sich die die reale Impedanz:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" height="50" width="112">
<tbody>
<tr>
<td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>Z</var>&nbsp;=&nbsp;</td>
<td align="center" nowrap="nowrap"><var>L<sub>ideal</sub></var></td>
<td colspan="1" rowspan="2" valign="middle">&nbsp;&middot;<sup>&nbsp;</sup><var>R<sub>ref</sub></var></td>
</tr>
<tr>
<td style="border-top: 1px solid black;"><var>R<sub>ideal</sub></var></td>
</tr>
</tbody>
</table>
</blockquote>
<p>In Realit&auml;t hat man es aber mit den
transformierten Signalen <var>L<sub>real</sub></var> und<var></var>
<var>R<sub>real</sub></var> zu tun.
Selbstverst&auml;ndlich sind alle Koeffizienten <var>c<sub>xx</sub></var>
komplex und
frequenzabh&auml;ngig.</p>
</blockquote>
<blockquote>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
<td rowspan="2" align="center" valign="middle">&nbsp;=&nbsp; </td>
<td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
<td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
<td rowspan="2" align="center" valign="middle">&nbsp;&middot;&nbsp;</td>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
</tr>
<tr>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
<td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
<td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
</tr>
</tbody>
</table>
</blockquote>
<h4>Durchf&uuml;hrung</h4>
<p>Zur Null-Kalibrierung wird mit dem gesamten realen
Messequipment einmal bei <var>Z</var>&nbsp;=&nbsp;0
(<var>L<sub>ideal</sub></var>&nbsp;=&nbsp;0)
und einmal mit <var>Z&nbsp;</var>=&nbsp;&infin;
(<var>R<sub>ideal</sub></var>&nbsp;=&nbsp;0)
gemessen, also Kurzschluss und keine Verbindung. Dabei wird neben der
Soundkarte auch die gesamte Apparatur mit kalibriert. Wenn eine
Kalibrierung mit der Option <a href="#_zg"><tt>zg</tt></a>
gestartet wird, Erwartet das Analyseprogramm zun&auml;chst einmal <a href="#_ln"><tt>ln</tt></a> Perioden
mit&nbsp;<var>Z</var>&nbsp;=&nbsp;0.
Anschlie&szlig;end kommt eine Bildschirmausgabe nach <tt>stdout</tt>
und eine kurze Pause. In der Pause muss das Messequipment auf <var>Z&nbsp;</var>=&nbsp;&infin;
umgestellt werden. Dann werden nochmal <a href="analyze.html#_ln"><tt>ln</tt></a>
Perioden aufgenommen, bevor das Ergebnis feststeht und der
Eingabedatenstrom <tt>stdin</tt> geschlossen wird.</p>
<p>Theoretisch
lassen sich alle linearen Fehler ohne absolute Eichung korrigieren.
Praktisch gibt es eine Unbekannte zuviel. Man kennt weder <var>R<sub>ideal</sub></var>
bei <var>Z</var>&nbsp;=&nbsp;0 noch <var>L<sub>ideal</sub></var>
bei <var>Z&nbsp;</var>=&nbsp;&infin;. Einer
der Unbekannten kann man sich entledigen, in dem man
willk&uuml;rlich definiert det&nbsp;<i>C</i>&nbsp;=
1. Das ist
insofern erlaubt, als dass die absolute Skalierung bei der Bildung der
Quotienten&nbsp;<var>L<sub>ideal</sub></var>
/<var>&nbsp;R<sub>ideal</sub></var> keine
Rolle spielt. Eine weitere Unbekannte kann man eliminieren, wenn man
animmt, dass das Referenzsignal <var>U<sub>ref</sub></var>
bei beiden Messungen dasselbe war, und <var>R<sub>ref</sub></var>
und die Messimpedanz in Reihe geschaltet sind. Dann kann man
n&auml;hern, dass <var>U<sub>ref</sub></var>&nbsp;&prop;&nbsp;<var>L<sub>ideal</sub></var>&nbsp;+&nbsp;<var>R<sub>ideal</sub></var>
ist (siehe Option <a href="#_zn"><tt>zn</tt></a>).
Dabei macht man einen Fehler: die zus&auml;tzlichen zu <var>R<sub>ref</sub></var>
und <var>Z</var> in Reihe geschalteten Impedanzen allen
voran die <strong>Induktivit&auml;t der Zuleitung wird nicht
ber&uuml;cksichtigt</strong>.</p>
<h4>Ergebnis</h4>
<div class="figure"><img src="images/ZeroSample.png" alt="Beispiel f&uuml;r Gainkorrektur" height="484" width="748"><br>
Beispiel f&uuml;r eine Null-Korrektur: Onboard Realtek ALC650 Codec
bei 48kHz sowie der <a href="http://www.maazl.de/electronic/LCR/LCR-Adapter.html">gebastelte
Messadapter</a> bei 200&Omega; <var>R<sub>ref</sub></var>
und einer FFT-L&auml;nge von 65536 Samples,
gemittelt &uuml;ber ca. 10 Zyklen.<br>
Dargestellt sind die diagonalen (links) und die nichtdiagonalen
Koeffizienten (rechts) der Transformationsmatrix jeweils in Betrag
(oben) und Phase in Grad (unten).<br>
Man erkennt ein kapazitives &Uuml;bersprechen vom linken zum
rechten Kanal. Die Asymmetrie beim &Uuml;bersprechen
erkl&auml;rt sich durch die Asymmetrie der Innenschaltung des
Messadapter und den definitiv nicht hochfrequenztauglichen Aufbau.<br>Am Phasengang der Koeffizienten <i>c<sub>ll</sub></i> und <i>c<sub>rr</sub></i>dd erkennt man eine Zeitverz&ouml;gerung von ca 12ns (!) zwischen den Kan&auml;len.<br>
Der Koeffizient <i>c<sub>lr</sub></i> ist in
seiner Amplitude so klein (ca. -70dB), dass die Phase nahezu unbestimmt
ist. Daher die relativ willk&uuml;rliche Verteilung der Phase mit Tendenz zu -90&deg;. </div>
<h4>Korrektur</h4>
<p>Durch Inversion der Transformationsmatrix kann man die
gemessenen Werte kompensieren:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td colspan="4"></td>
<td colspan="1" rowspan="2" valign="middle">&nbsp;<sup>-1</sup></td>
<td rowspan="1" colspan="2"></td>
</tr>
<tr>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
<td rowspan="2" align="center" valign="middle"><var>&nbsp;</var>=&nbsp;
</td>
<td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
<td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
<td rowspan="2" align="center" valign="middle">&middot;&nbsp;</td>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
</tr>
<tr>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
<td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
<td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
<td></td>
<td style="border-left: 1px solid black; border-right: 1px solid black;" align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
</tr>
</tbody>
</table>
</blockquote>
</blockquote>
<h2><a name="history"></a>Historie</h2>
<h4>Version 0.11</h4>
<ul>
<li>Hysterese-Modus hinzugef&uuml;gt (noch alpha).</li>
<li>Source-Verzeichnisstruktur reorganisiert.</li>
</ul>
<h4>Version 0.1</h4>
<ul>
<li>Interne Version</li>
</ul>
<h2><a name="todo"></a>TODOs, bekante Probleme</h2>
<dl>
<dt><b>3-Punkt-Kalibrierung</b></dt>
<dd>Aufgrund den Unzul&auml;nglichkeiten der
<a href="#zero-cal">Zweipunktkalibrierung</a> ist eine 3-Punkt-Kalibrierung mit einer bekannten
Referenzimpedanz w&uuml;nschenswert.</dd>
</dl>
</body></html>