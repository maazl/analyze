<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
  <head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
    <title>Software to analyze transfer functions and impedance</title>
    <link href="mm.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <h1>Software to analyze transfer functions and impedance </h1>
    <p><span class="abstract">Release: 0.2</span></p>
    <a href="index.html">&rarr;&nbsp;Index</a> <a href="#overview">&rarr;&nbsp;Overview</a>
    <a href="#options">&rarr;&nbsp;Parameters</a> <a href="#cal">&rarr;&nbsp;Calibration</a>
    <a href="index.html#download">&rarr;&nbsp;Download</a> <a href="#history">&rarr;&nbsp;History</a>
    <a href="#todo">&rarr;&nbsp;Todo</a> <a href="index.html#build">&rarr;&nbsp;Build</a>
    <h2><a name="overview"></a>Overview</h2>
    <p>This program analyzes incoming PCM data on the fly and passes the results
      to files and optional a graphing utility like <a href="http://www.gnuplot.info">Gnuplot</a>.
      The C++ source code is available and should be portable to other platforms
      at reasonable effort. The open source library <a href="http://www.fftw.org/">FFTW</a>
      version 2.x is utilized for fast operation. The software is optimized for
      sound devices as for the A/D conversion. </p>
    <h3>Use cases </h3>
    <ul>
      <li>Measure <b>impedance</b> or <b>transfer function</b> with noise
        reference.</li>
      <li>Measure <b>harmonic distortion</b> with particular noise reference
        for this purpose.</li>
      <!--li>Messure <strong>hysteresis</strong>.</li-->
    </ul>
    <h3><a name="sequence" id="sequence"></a>Operation sequence </h3>
    <blockquote>
      <p><span style="font-family: monospace;">Analyze</span> reads <b>16 bit 2
          channel PCM Data</b> from <b><tt>stdin</tt></b>, a <a href="#_in">file</a>
        and does the analysis on the fly. The result is written to the <b>file
          <a href="#_wd"><tt>data.dat</tt></a></b> and/or the screen (<tt>stderr</tt>)
        every time new data is available. Optionally a <a href="#_plot">command</a>
        could be passed to <a href="#_plot"><tt>stdout</tt></a> when new data
        is available, e.g. to synchronize gnuplot. The program terminates, if
        the indicated <a href="#_ln">number of turns</a> has completed, no more
        input is available or an interrupt signal is received (Ctrl-C).</p>
      <p>The (platform independent) recording of the PCM stream as well as some
        buffering, to handle real time streaming, must be provided with other
        platform specific tools like <a href="http://www.ca-arnold.de/">playrec</a>
        (OS/2), or /dev/snd/pcm... (Linux). </p>
    </blockquote>
    <h3><a name="modes"></a>Modes of operation </h3>
    <blockquote>
      <p>Analyze currently supports two analysis modes:<b> </b></p>
      <b> </b>
      <ul>
        <b> </b>
        <li><b> </b>
          <p><b><strong><a name="mfft"></a> </strong>FFT analysis</b> (option <a
              href="#_mfft"><tt>mfft</tt></a>)</p>
          <p>The FFT mode is intended for measurement of impedance and transfer
            functions. It calculates the ESR ESC and ESL by fitting the FFT
            result. Therefore the weighted averages in the interval [<a href="#_famin"><tt>famin</tt></a>,
            <a href="#_famax"><tt>famax</tt></a>] are calculated as follows: </p>
          <blockquote>
            <p><var>ESR</var> := &lt; <var>a<sub>i</sub></var> &gt;<br>
              <var>ESL</var> := &lt; <var>b<sub>i</sub></var> / <var>&omega;</var>
              &gt;<br>
              <var>ESC</var> := &lt; &minus;<var>b<sub>i</sub></var> &middot; <var>&omega;</var>
              &gt;</p>
          </blockquote>
          <p>Of course, only one of ESL or ESC is reasonable, the positive one.
            The standard deviation of the above average values gives a coarse
            estimation of the reliability.</p>
          <p>You will not get reasonable results when the impedance contains
            inductive and capacitive components or their equivalent values
            change with frequency. In this case you should view the <a href="#_wd">frequency
              dependent results</a> in the data file.<br>
            The same applies if you are measuring transfer functions, of course.
          </p>
        </li>
      </ul>
      <ul>
        <li>
          <p><a name="mpca"></a><b>LCR analysis with PCA</b><strong> </strong>(option
            <a href="#_mpca"><tt>mpca</tt></a>)</p>
          <p>The PCA mode (<span style="text-decoration: underline;">P</span>rincipal
            <span style="text-decoration: underline;">C</span>omponent <span style="text-decoration: underline;">A</span>nalysis)
            uses a linear combination of the following functions to reproduce <var>U</var>(<var>t</var>):
            </p>
          <ul>
            <li>a constant (DC offset, parasitic),</li>
            <li><var>R</var>&middot;<var>I</var>(<var>t</var>) (ohmic
              resistance),</li>
            <li>d<var>I</var>(<var>t</var>)/d<var>t</var> (inductance),</li>
            <li>&int; <var>I</var>(<var>t</var>) d<var>t</var> (capacity) and</li>
            <li><var>x</var>&middot;<var>t</var> (drift of the DC offset,
              parasitic)</li>
          </ul>
          <p>This is a very fast way to analyze a series of resistor, inductor
            and capacitor. The complexity is O(n) in the number of samples.<br>
            It works as long it is a <em>series</em>. You cannot measure the
            electrolytic capacitors this way, because there are other effects
            included.</p>
          <p>The PCA method will <em>not</em> write a data file.</p>
        </li>
        <!--li>
      <p><strong><a name="mxy"></a>Kennlinienmessung</strong>(Option <a href="#_mxy"><tt>mxy</tt></a>)</p>      <p>Bei dieser Messmethode wird direkt <var>I</var>(<var>t</var>)&#129;ber <var>U</var>(<var>t</var>)
aufgetragen. Was sich am einfachsten anh&#8221;rt, ist faktisch amschwierigsten, da aufgrund der Kompensationen zuerst eineTransformation in den Frequenzraum (DFT) und anschlieáendzur&#129;ck in den Zeitraum erforderlich ist. Zus&#8222;tzlich
werdenbei dieser Methode auch noch die Integrale <var>U</var>(<var>t</var>)&nbsp;d<var>t</var>und <var>I</var>(<var>t</var>)&nbsp;d<var>t</var>
sowie die Ableitungen <var>U</var>(<var>t</var>)/d<var>t</var>und <var>I</var>(<var>t</var>)/d<var>t</var>berechnet. Aus verschiedenen Gr&#129;nden erfolgt deren Berechnung
imFrequenzraum. Dadurch sind faktisch 2Vorw&#8222;rts-Transformationenund 6 R&#129;cktransformationen pro Datenpaket erforderlich.</p>
      <p>Lohn der M&#129;he ist z.B., dass mit sehr einfachenMitteln die Hysteresen von Spulenkernen gemessen werdenk&#8221;nnen, da <var>I</var>&nbsp;&#8733;&nbsp;<var>V</var>&nbsp;&#8733;&nbsp;<var>H</var>und
&#8747;&nbsp;<var>U</var>(<var>t</var>)&nbsp;d<var>t</var>&nbsp;&#8733;&nbsp;<var>&#934;</var>&nbsp;&#8733;&nbsp;<var>B</var>ist.</p>    </li-->
      </ul>
      <p>FFT and PCA can be combined. Then you will get the more reliable LCR
        values of the PCA method together with the detailed frequency dependent
        results from FFT in the <a href="#_wd">data file</a>.</p>
    </blockquote>
    <h2><a name="options"></a>Command line options</h2>
    <h3>Alphabetic list </h3>
    <table border="1" cellpadding="3" cellspacing="0">
      <tbody>
        <tr>
          <th>Option</th>
          <th>Bedeutung</th>
          <th>Standard</th>
          <th>Kategorie</th>
        </tr>
        <tr>
          <td><a href="#_ainc"><tt>ainc</tt></a></td>
          <td>incremental mode<br>
          </td>
          <td>off</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_al"><tt>al</tt></a></td>
          <td>average over multiple cycles of samples<br>
          </td>
          <td><tt>1</tt> (off)<tt> </tt></td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_bin"><tt>bin</tt></a></td>
          <td>average FFT channels<br>
          </td>
          <td><tt>1</tt> (off)</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_bn"><tt>bn</tt></a></td>
          <td>analysis block size</td>
          <td><tt>8192</tt></td>
          <td><a href="#param_options">general options</a></td>
        </tr>
        <tr>
          <td><a href="#_ca"><tt>ca</tt></a></td>
          <td>add samples to bins<br>
          </td>
          <td><tt>1</tt> (off)</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_df"><tt>df</tt></a></td>
          <td>name of the FFT data file<br>
          </td>
          <td><tt>data.dat</tt></td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_exec"><tt>exec</tt></a></td>
          <td>execute shell command after data available<br>
          </td>
          <td>off<br>
          </td>
          <td><a href="#control_options">control options </a></td>
        </tr>
        <tr>
          <td><tt><a href="#_famin">famin</a> <a href="#_famax">famax</a></tt></td>
          <td>frequency range for LCR analysis</td>
          <td><a href="#_fmin"><tt>fmin</tt></a> .. <a href="#_fmax"><tt>fmax</tt></a></td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_fbin"><tt>fbin</tt></a></td>
          <td>average FFT channels with logarithmic bandwidth<br>
          </td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_finc"><tt>finc</tt></a></td>
          <td>linear increment for used FFT channels<br>
          </td>
          <td><tt>1</tt></td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_flog"><tt>flog</tt></a></td>
          <td>logarithmic increment for used FFT channels</td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_fmin">fmin</a> <a href="#_fmax">fmax</a></tt></td>
          <td>frequency range for analysis<br>
          </td>
          <td><tt>0</tt> .. Nyquist freq.</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_fg"><tt>fq</tt></a></td>
          <td>sampling frequency</td>
          <td><tt>48000</tt></td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_g2f"><tt>g2f</tt></a></td>
          <td>name of validation file of <a href="#gain-cal">gain calibration</a></td>
          <td><tt>gainD.dat</tt></td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_gd"><tt>gd</tt></a></td>
          <td>verify <a href="#gain-cal">gain calibration</a></td>
          <td>off<br>
          </td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_gf"><tt>gf</tt></a></td>
          <td>name of <a href="#gain-cal">gain calibration</a> file</td>
          <td><tt>gain.dat</tt></td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_gg"><tt>gg</tt></a></td>
          <td>generate <a href="#gain-cal">gain calibration</a> file</td>
          <td>off</td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_gr"><tt>gr</tt></a></td>
          <td>use <a href="#gain-cal">gain calibration</a> file</td>
          <td>off</td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_h_f"><tt>h/f</tt></a></td>
          <td>use 1/<var>f</var> weight<br>
          </td>
          <td>default weight<br>
          </td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_harm"><tt>harm</tt></a></td>
          <td>take harmonics into account<br>
          </td>
          <td><tt>0</tt></td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_hd"><tt>hd</tt></a></td>
          <td>use weight function for differential <a href="#_scm">input mode</a></td>
          <td>default weight</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_he"><tt>he</tt></a></td>
          <td>disable weight function<br>
          </td>
          <td>default weight</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_in"><tt>in</tt></a></td>
          <td>name of input file</td>
          <td>stdin</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_ln"><tt>ln</tt></a></td>
          <td>number of loops</td>
          <td><tt>1</tt></td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_loop"><tt>loop</tt></a></td>
          <td>infinite number of loops</td>
          <td>aus</td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_lp"><tt>lp</tt></a></td>
          <td>pause at <a href="#matrix-cal">matrix calibration</a></td>
          <td><tt>10</tt></td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_lvl"><tt>lvl</tt></a></td>
          <td>noise level for automatic weight function<br>
          </td>
          <td><tt>1</tt></td>
          <td><a href="#param_options">general options</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_mfft">mfft</a> <a href="#_mpca">mpca</a></tt></td>
          <td>operation mode<br>
          </td>
          <td><em>none</em><br>
          </td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_mst"><tt>mst</tt></a></td>
          <td>two channel mode</td>
          <td>off</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_olf">olf</a> <a href="#_olc">olc</a></tt></td>
          <td>file name and column to overwrite nominator<br>
          </td>
          <td>none / <tt>1</tt></td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_orf">orf</a> <a href="#_orc">orc</a></tt></td>
          <td>file name and column to overwrite denominator (reference)<br>
          </td>
          <td>none / <tt>1</tt></td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_pdc"><tt>pdc</tt></a></td>
          <td>purge first frequency channels</td>
          <td><tt>1</tt> (purge DC)<tt> </tt></td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_phcc"><tt>phcc</tt></a></td>
          <td>fit group delay<br>
          </td>
          <td>off<br>
          </td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_phl"><tt>phl</tt></a></td>
          <td>subtract constant group delay</td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_plot"><tt>plot</tt></a></td>
          <td>write command to <span style="font-family: monospace;">stdout</span>
            after data available</td>
          <td>off</td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_psa"><tt>psa</tt></a></td>
          <td>discard first samples<br>
          </td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_pte"><tt>pte</tt></a></td>
          <td>read input data till the end<br>
          </td>
          <td>off</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_rf"><tt>rf</tt></a></td>
          <td>name of raw data file</td>
          <td><tt>raw.dat</tt></td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_rref"><tt>rref</tt></a></td>
          <td>reference resistor<br>
          </td>
          <td><tt>1</tt></td>
          <td><a href="#param_options">general options</a></td>
        </tr>
        <tr>
          <td><a href="#_scm"><tt>scm</tt></a></td>
          <td>input mode<br>
          </td>
          <td><tt>0</tt></td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_wd"><tt>wd</tt></a></td>
          <td>(over)write FFT data file on the fly<br>
          </td>
          <td>off</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_wf"><tt>wf</tt></a></td>
          <td>name of window function file</td>
          <td><tt>window.dat</tt></td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_win"><tt>win</tt></a></td>
          <td>select window function</td>
          <td>off (rectangular)<br>
          </td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_wr"><tt>wr</tt></a></td>
          <td>write raw data</td>
          <td>off</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_ww"><tt>ww</tt></a></td>
          <td>write window function</td>
          <td>off</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_xb"><span style="font-family: monospace;">xb</span></a></td>
          <td>swap bytes of PCM data (change endianess)</td>
          <td>off</td>
          <td><a href="#input_options">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_z2f"><tt>z2f</tt></a></td>
          <td>name of validation file of <a href="#matrix-cal">matrix
              calibration</a></td>
          <td><tt>zeroD.dat</tt></td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_zd"><tt>zd</tt></a></td>
          <td>validate <a href="#matrix-cal">matrix calibration</a></td>
          <td>off</td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_zf"><tt>zf</tt></a></td>
          <td>name of <a href="#matrix-cal">matrix calibration</a> file<a href="#matrix-cal">
            </a></td>
          <td><tt>zero.dat</tt></td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_zg"><tt>zg</tt></a></td>
          <td>generate <a href="#matrix-cal">matrix calibration</a> file</td>
          <td>off</td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_zn"><tt>zn</tt></a></td>
          <td>normalize amplitudes</td>
          <td>off</td>
          <td><a href="#fft_options">FFT parameters</a></td>
        </tr>
        <tr>
          <td><a href="#_zr"><tt>zr</tt></a></td>
          <td>use <a href="#matrix-cal">matrix calibration</a> file</td>
          <td>off</td>
          <td><a href="#calibrate_options">calibration</a></td>
        </tr>
      </tbody>
    </table>
    <h3><a name="input_options"></a>Input data options </h3>
    <blockquote>
      <dl compact="compact">
      </dl>
      <dl compact="compact">
        <dt><kbd><a name="_in"></a>in<var>filename - </var></kbd>name of input
          file<kbd><var> </var></kbd></dt>
        <dd>Read PCM-data from <var><kbd>filename</kbd></var> (instead of <tt>stdin</tt>).
The
          file name could be a transient source like a pipe or a character
          device.</dd>
        <dt><kbd><a name="_rf"></a>rf<var>filename - </var></kbd>raw data file<kbd><var>
            </var></kbd></dt>
        <dd>Name of the output file for raw data (option <a href="#_wr"><kbd>wr</kbd></a>).
          <tt>raw.dat</tt> by default.</dd>
        <dt><kbd><a name="_wr"></a>wr - </kbd>write raw data<kbd> </kbd></dt>
        <dd>Write raw data to <a href="#_rf">file</a>. These is the raw input
          data without any processing so far, except for option <tt><a href="#_psa"><tt>psa</tt></a></tt>.
          It is intended for diagnostics only. <a href="#raw_dat">&rarr; file
            format</a></dd>
        <dt><span style="font-family: monospace;"><a name="_xb"></a>xb - </span>swap
          bytes of PCM data</dt>
        <dd>Change endianess of input data.</dd>
        <dt><kbd><a name="_psa"></a>psa<var>num - </var></kbd>discard first <kbd><var>num</var></kbd>
          samples<kbd><var> </var></kbd></dt>
        <dd>Use this to discard spikes at the starting or to reach a steady
          state. You may also use this option to discard headers from PCM files
          like RIFF wave format.</dd>
        <dt><kbd><a name="_pte"></a>pte - </kbd>discard trailing input<kbd> </kbd></dt>
        <dd>If the analysis has completed (option <a href="#_ln"><kbd>ln</kbd></a>)
          the input is read continously, but the data is discarded. This can be
          useful if the data source behaves unexpectedly if the data drain is
          closed. This also causes analyze not to terminate before either the
          input stream is closed or an interrupt signal is received.</dd>
        <dt><kbd><a name="_ca"></a>ca<var>num - </var></kbd>add <kbd><var>num</var></kbd>
          samples<kbd><var> </var></kbd></dt>
        <dd>Alwas add <var><kbd>num</kbd></var> subsequent samples before any
          further processing. This can be used to achieve a lower effective
          sampling rate at better SNR. Note that this is no appropriate down
          sampling, but only to reduce ADC noise.<br>
          Without an explicit value for <var><kbd>num</kbd></var>, 2 samples is
          assumed.</dd>
        <dt><kbd><a name="_scm"></a>scm0</kbd>, <kbd>scm1</kbd> oder <kbd>scm2
            - </kbd>input mode<kbd></kbd> </dt>
        <dd> <kbd>scm0</kbd> &ndash; nominator (<var>U</var>(<var>t</var>)) :=
          channel 1, denominator (<var>I</var>(<var>t</var>)) := channel 2<br>
          <kbd>scm1</kbd> &ndash; differential mode: nominator (<var>U</var>(<var>t</var>))<var></var><var></var>
          := channel 1, denominator (<var>I</var>(<var>t</var>)) := channel 2
          &minus; channel 1<br>
          <kbd>scm2</kbd> &ndash; reverse mode: nominator (<var>U</var>(<var>t</var>))
:=
          channel 2, denominator (<var>I</var>(<var>t</var>)) := channel 1<br>
          Differential mode is useful if you want to do impedance measurements
          without a differential instrumentation amplifier. You could simply use
          a series of a reference resistor with the unknown impedance. But note
          that the difference of similar numbers may become very sensitive to
          channel differences for low currents. It is recommended to use at
          least the <a href="#_hd">differential weight function</a> in FFT mode
          to reduce this kind of errors.</dd>
        <dt><kbd><a name="_al"></a>al<var>num</var></kbd><span style="font-family: monospace;">
            - </span>add <kbd><var>num</var></kbd> cycles</dt>
        <dd>Add <kbd><var>num</var></kbd> cycles of raw input data before
          starting analysis. This improves the SNR by the square root of <kbd><var>num</var></kbd>.
          Note that the reference signal must be cyclic to use this option.<br>
          This is effectively the same than taking a twice as large FFT size and
          discarding every odd frequency channel, but it is significantly
          faster.</dd>
        <dt><kbd><a name="_ainc"></a>ainc - </kbd>incremental mode</dt>
        <dd>The raw input data is added in sets of the analysis length. This
          causes a increasing accuracy by building an average over more and more
          cycles. Note that the reference signal must be cyclic to use this
          option and it must be exactly synchronized to the sampling frequency.<br>
          This option is an alternative to sweep measurements.</dd>
        <dt><kbd><a name="_olc"></a>olc<var>column - </var></kbd>column to
          override nominator<kbd><var> </var></kbd></dt>
        <dd>Column in the file to override the nominator. Requires <a href="#_olf"><kbd>olf</kbd></a>.
        </dd>
        <dt><kbd><a name="_olf"></a>olf<var>file - </var></kbd>override
          nominator<kbd><var> </var></kbd></dt>
        <dd>Override nominator (left channel by default) with a <a href="#_olc">column</a>
          from <var><kbd>file</kbd></var>.</dd>
        <dt><kbd><a name="_orc"></a>orc<var>column - </var></kbd>column to
          override denominator</dt>
        <dd>Column in the file to override the denominator. Requires <a href="#_orf"><kbd>orf</kbd></a>.</dd>
        <dt><kbd><a name="_orf"></a>orf<var>file - </var></kbd>override
          denominator</dt>
        <dd>Override denominator (right channel by default) with a <a href="#_orc">column</a>
          from <var><kbd>file</kbd></var>.</dd>
      </dl>
    </blockquote>
    <h3><a name="control_options"></a>Control options </h3>
    <blockquote>
      <dl compact="compact">
        <dt><kbd><a name="_ln"></a>ln<var>num - </var></kbd>number of loops<kbd><var>
            </var></kbd></dt>
        <dd>The program terminates automatically after <kbd><var>num</var></kbd>
          analysis cycles. By default only a a single analysis is done.</dd>
        <dt><kbd><a name="_loop"></a>loop - </kbd>infinite analysis<kbd> </kbd></dt>
        <dd>The program continue to analyze until the input data has been
          finished or it is interrupted by a signal. This is useful to reflect
          changes of you measurement item in near real time.<br>
          It is recommended to check whether real time processing is possible
          with a reasonable system load with a <a href="#_ln">limited number of
            cycles</a> before using this option on a infinite transient data
          source.</dd>
        <dt><kbd><a name="_mfft"></a>mfft - </kbd>FFT mode<kbd> </kbd></dt>
        <dd>Activate FFT mode for analysis. At least one analysis mode must be
          selected.</dd>
        <dt><kbd><a name="_mpca"></a>mpca - </kbd>PCA mode<kbd> </kbd></dt>
        <dd>Activate PCA mode for analysis. At least one analysis mode must be
          selected.</dd>
        <dt><kbd><a name="_exec"></a>exec<var>command - </var></kbd>execute
          shell command<kbd><var> </var></kbd></dt>
        <dd>Each time a analysis is complete and the data has been written <var><kbd>command</kbd></var>
          is passed to <span style="font-family: monospace;">system()</span>.
          Note that <span style="font-family: monospace;">analyze</span> waits
          for the command to complete. This gives you exclusive access to the
          data files but it may also interfere with the real time processing of
          the input data. You may alternatively consider to pipe the command to
          <span style="font-family: monospace;">stdout</span> instead (option <a
            href="#_plot"><kbd>plot</kbd></a>), if you do not need this kind of
          synchronization. </dd>
        <dt><kbd><a name="_plot" id="_plot"></a>plot<var>command - </var></kbd>pipe
          command<kbd><var> </var></kbd></dt>
        <dd>Write command to <tt>stdout</tt> each time an analysis has
          completed. You can use this to synchronize plot programs when new data
          arrives. Note that <span style="font-family: monospace;">analyze</span>
          will not wait for any command completion. </dd>
      </dl>
    </blockquote>
    <h3><a name="param_options"></a>General options </h3>
    <blockquote>
      <dl compact="compact">
        <dt><kbd><a name="_fq"></a>fq<var>freq - </var></kbd>sampling frequency
          of input data<kbd><var> </var></kbd></dt>
        <dd>This parameter should always be specified. <span style="font-family: monospace;">analyze</span>
          cannot read headers of PCM data files. </dd>
        <dt><kbd><a name="_bn"></a>bn<var>num - </var></kbd>analysis block
          length<kbd><var> </var></kbd></dt>
        <dd>Number of samples for one analysis cycle. This is also the length of
          the FFT. It is strongly recommended to use a power of 2 if you
          activated the <a href="#_mfft">FFT mode</a>. The number of samples
          here counts after an options averaging with option <a href="#_ca"><kbd>ca</kbd></a>.<br>
          The default values is 8192.</dd>
        <dt><kbd><a name="_rref"></a>rref<var>res - </var></kbd>reference
          resistor<kbd><var> </var></kbd></dt>
        <dd>Scale the denominator by <var><kbd>res</kbd></var> before any
          further processing. By default no scaling takes place.<br>
          This option could be used to compensate for constant factors of your
          measurement setup like a reference resistors to measure the current or
          the amplifier gain. </dd>
      </dl>
    </blockquote>
    <h3><a name="fft_options"></a>FFT-Parameter </h3>
    <blockquote>
      <dl compact="compact">
        <dt><kbd><a name="_famin"></a><a name="_famax"></a>famin<var>freq</var></kbd>
          and <kbd>famax<var>freq - </var></kbd>frequency range for LCR
          analysis<kbd><var> </var></kbd></dt>
        <dd>Minimum and maximum frequency for LCR data fit. This could be used
          to adapt the bandwidth of your setup. In contrast to <a href="#_fmin"><kbd>fmin</kbd></a>
          and <a href="#_fmax"><kbd>fmax</kbd></a> this has no influence on the
          data written to the <a href="#_wd">result file</a>. It applies only
          to the sreen output (to <span style="font-family: monospace;">stderr</span>).
          </dd> <dt><kbd><a name="_fmin"></a><a name="_fmax"></a>fmin<var>freq</var></kbd>
          and <kbd>fmax<var>freq - </var></kbd>frequency range<kbd><var> </var></kbd></dt>
        <dd>Minimum and maximum frequency for the FFT analysis. This option
          applies to <em>all</em> processing steps including calculation of
          calibration etc. It could be used to remove artifacts at the frequency
          limits for graphical output. </dd>
        <dt><kbd><a name="_h_f"></a>h/f - </kbd>use <kbd>1/<var>f</var></kbd>
          weight<kbd> </kbd></dt>
        <dd>This weight function can be useful for measurements with pink noise.
        </dd>
        <dt><kbd><a name="_hd"></a>hd - </kbd>weight function for differential
          mode<kbd> </kbd></dt>
        <dd>Use adapted weight function for differential input mode <a href="#_scm"><kbd>scm1</kbd></a>.</dd>
        <dt><kbd><a name="_he"></a>he - </kbd>disable weights<kbd> </kbd></dt>
        <dd>Use an equal distributed weight function. Use this if your input SNR
          has no correlation with the signal amplitude at a certain frequency. </dd>
        <dt><kbd><a name="_lvl"></a>lvl<var>level - </var></kbd>noise level<kbd><var>
            </var></kbd></dt>
        <dd>Frequencies with amplitudes below <var><kbd>level</kbd></var> are
          weighted close to zero. </dd>
        <dt><kbd><a name="_bin"></a>bin<var>size - </var></kbd>average <var><kbd>size</kbd></var>
          FFT channels<kbd><var> </var></kbd></dt>
        <dd>Calculates the average over <var><kbd>size</kbd></var> subsequent
          frequency channels before any further processing. The averaging is
          done in polar coordinates so phase noise does not degrade the
          amplitude.<br>
          This could be used to reduce noise if the measurement response is not
          likely to change fast with frequency. But if yur reference signal is
          periodic you should prefer a shorter block length together with <a href="#_al">averaging
            input samples</a>. </dd>
        <dt><kbd><a name="_fbin"></a>fbin<var>factor - </var></kbd>average<var><kbd></kbd></var><span
            style="font-family: monospace;"><span style="font-style: italic;"></span></span>
          FFT channels logarithmically </dt>
        <dd>Calculates the average over <var><kbd>size</kbd></var> subsequent
          frequency channels to get approximately logarithmic frequency bins.
          The channels are averaged as long as they fit into the interval [<var>f</var>,&nbsp;<var>f</var>&nbsp;&middot;&nbsp;(<kbd><var>factor</var></kbd>&nbsp;+&nbsp;1)].
This
          option is particularly useful if the properties of the object tend to
          change over log&nbsp;<var>f</var> rather than <var>f</var>. In other
          words if the result is shown with logarithmic frequency axis.</dd>
        <dt><tt><a name="_finc"></a>finc<var>channels</var></tt> and <tt><a name="_flog"></a>flog<var>increment
              </var></tt><tt><var>- </var></tt>linear and logarithmic increment
          for used frequencies </dt>
        <tt><var></var></tt> <dd>This is intended to be used with custom,
          discrete energy distributions. Subsequent used frequencies have at
          least the distance <var>f<small><sub>n+1</sub></small>&nbsp;= f<small><sub>n</sub></small></var>&nbsp;&middot;&nbsp;<tt><var>channels</var>&nbsp;+&nbsp;<var>increment</var></tt>
          rounded to the closest frequency in the FFT result. Any channels in
          between are ignored. </dd>
        <dd>The setting must be chosen to <a href="noise.html#_finc">match the
            reference signal</a>.</dd>
        <dt><kbd><a name="_harm"></a>harm<var>n - </var></kbd>use harmonics<kbd><var>
            </var></kbd></dt>
        <dd>With this option the first <i><tt>n</tt></i> harmonics of any used
          frequency is reserved. In fact it is assumed that the reference signal
          does not contain energy at these frequencies and any response is the
          result of harmonic distortion. This could be used to do very fast
          measurements of harmonics of loudspeakers.<br>
          The setting must be chosen to <a href="noise.html#_finc">match the
            reference signal</a>. See <a href="#harmonics">analysis of
            harmonics</a>.</dd>
        <dt><kbd><a name="_mst"></a>mst - </kbd>two channel mode<kbd> </kbd></dt>
        <dd>In two channel mode the used FFT frequencies are associated with two
          distinct channels alternatingly. This applies to any averaging
          operation. A column in the result files indicates the channel
          association. See multi <a href="#multichannel">multi channel
            measurements</a>.</dd>
        <dt><kbd><a name="_pdc"></a>pdc<var>num - </var></kbd>purge low FFT
          channels<kbd><var> </var></kbd></dt>
        <dd>This assigns zero to the first <var><kbd>num</kbd></var> channels
          of the FFT result. It is alternative to <a href="#_fmin"><kbd>fmin</kbd></a>
          that does not remove the lines from the data file and avoids
          uninitialized values in calibration files. But be careful not to use
          these coefficients as denominator of some following calculation step.
          To avoid division by zero exceptions a very small value is used rather
          than zero. </dd>
        <dt><kbd><a name="_phcc"></a>phcc - </kbd>fit group delay<kbd> </kbd></dt>
        <dd>This option fits the group delay by calculation of the center of the
          cross correlation of the wanted signal and the reference signal.</dd>
        <dd>The option is required if the wanted and the reference data are only
          synchronized at the sampling frequency but not at the origin of the
          cycle. Otherwise degradation of amplitude at higher frequencies when
          averaging of frequency channels is used may occur, because of errors
          in phase unwrapping. With this option activated the result is written
          to <span style="font-family: monospace;">stderr</span> additionally.
          The fitted group delay is removed from the <a href="#data_dat">output
            file</a> in this case.</dd>
        <dt><kbd><a name="_phl"></a>phl<var>delay - </var></kbd>subtract group
          delay</dt>
        <dd>Adjusts the phase data by exp(I <var>&omega; <span style="font-family: monospace;">delay</span></var>).
          <var><span style="font-family: monospace;">delay</span></var> is in
          seconds. </dd>
        <dt><kbd><a name="_df"></a>df<var>filename - </var></kbd>data file name<kbd><var>
            </var></kbd></dt>
        <dd>Name of the file to write FFT data with option <a href="#_wd"><kbd>wd</kbd></a>,
          <tt>data.dat</tt> by default. </dd>
        <dt><kbd><a name="_wd"></a>wd - </kbd>write FFT data<kbd> </kbd></dt>
        <dd>Write detailed result of FFT analysis. <a href="#data_dat">&rarr;
            file format</a></dd>
        <dt><kbd><a name="_wf"></a>wf<var>filename - </var></kbd>window file
          name<kbd><var> </var></kbd></dt>
        <dd>File to write the window function with option <a href="#_ww"><kbd>ww</kbd></a>,
          <tt>window.dat</tt> by default. </dd>
        <dt><kbd><a name="_win"></a>win<var>typ - </var></kbd>window function<kbd><var>
            </var></kbd></dt>
        <dd>Aplly window function to data before FFT. The following window
          functions are implemented:<br>
          <kbd>win0</kbd> &ndash; rectangular = none<br>
          <kbd>win1</kbd> &ndash; Bartlett window = triangular, abs(2&nbsp;<var>i</var>/<var>n</var>
          1)<br>
          <kbd>win2</kbd> &ndash; Hanning window, .5 + .5&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)<br>
          <kbd>win3</kbd> &ndash; Hamming window, .54 + .46&nbsp;cos(2 <var>i</var>/<var>n</var>)<br>
          <kbd>win4</kbd> &ndash; Blackman window, .42 + .5&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)
          +&nbsp;.08&nbsp;cos(4&pi; <var>i</var>/<var>n</var>)<br>
          <kbd>win5</kbd> &ndash; Blackman Harris window, .35875 +
          .48829&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)
          +&nbsp;.14128&nbsp;cos(4&pi; <var>i</var>/<var>n</var>) +
          .01168&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)<br>
          A window function is only recommended if the reference signal cannot
          be made cyclic.</dd>
        <dt><kbd><a name="_ww"></a>ww - </kbd>write window function<kbd> </kbd></dt>
        <dd>This option writes the selected window function (option <a href="#_win"><kbd>win</kbd></a>)
          to a file (option <a href="#_wf"><kbd>wf</kbd></a>). <a href="#window_dat">&rarr;
            file format</a></dd>
        <dt><kbd><a name="_zn"></a>zn - </kbd>normalize amplitudes<kbd> </kbd></dt>
        <dd>Adjust the sum of the complex amplitudes of nominator and
          denominator to 1. This has no effect on impedance or transfer
          function, but it gets important if you relate data of different
          measurements as e.g. the matrix calibration does.<span style="font-family: Arial,Helvetica,sans-serif;"><span
              style="font-weight: bold;"></span></span></dd>
      </dl>
    </blockquote>
    <h3><a name="calibrate_options"></a>Calibration options </h3>
    <blockquote>
      <dl compact="compact">
        <dt><kbd><a name="_gg"></a>gg - </kbd>do <a href="#gain-cal">gain
            calibration</a><kbd> </kbd></dt>
        <dd>The left and right channel is assumed to sample the same signal. The
          difference in the transfer functions is written to the <a href="#_gf">calibration
            file</a>. <a href="#gain_dat">&rarr; file format</a></dd>
        <dt><kbd><a name="_gr"></a>gr - </kbd>apply gain calibration<kbd> </kbd></dt>
        <dd>The results from an earlier <a href="#gain-cal">gain calibration</a>
          are read from <a href="#_gf">file</a> and applied to the data. <a href="#gain.dat">&rarr;
            file format</a><br>
          The calibration is arbitrarily applied to the nominator signal. So you
          should not abuse the gain calibration to compensate for complex
          transfer functions, because the weight functions would be affected.</dd>
        <dt><kbd><a name="_gf"></a>gf - </kbd>gain calibration file<kbd> </kbd></dt>
        <dd>File name for gain calibration (<a href="#_gr">read</a> and <a href="#_gg">write</a>).
          <tt>gain.dat</tt> by default.</dd>
        <dt><kbd><a name="_gd"></a>gd - </kbd>verify gain calibration<kbd> </kbd></dt>
        <dd>The result from an earlier <a href="#gain-cal">gain calibration</a>
          is read from <a href="#_gf">file</a> and applied to the data before
          another gain calibration is done.The residual result is written to the
          <a href="#_g2f">gain verification file</a>. The <a href="#gain.dat">file
            format</a> is the same as for the calibration file. The option is
          mainly for diagnostic purposes.</dd>
        <dt><kbd><a name="_g2f"></a>g2f<var>filename - </var></kbd>gain
          verification file<kbd><var> </var></kbd></dt>
        <dd>Name of the file for validation result of the gain correction. See
          option <a href="#_gd"><kbd>gd</kbd></a>.</dd>
        <dt><kbd><a name="_zg"></a>zg - </kbd>do <a href="#matrix-cal">matrix
            calibration</a><kbd> </kbd></dt>
        <dd>Generate the <a href="#_zf">matrix calibration file</a>. The Matrix
          calibration operates in two steps. In the first step the reference
          signal should be zero, in the second step the wanted signal should be
          zero. Between the steps there is a <a href="#_lp">configured pause</a>
          to adjust the setup. See <a href="#matrix-cal">documentation</a> for
          further details. </dd>
        <dt><kbd><a name="_zr"></a>zr - </kbd>apply matrix calibration<kbd> </kbd></dt>
        <dd>Use the <a href="#matrix-cal">matrix calibration</a> from <a href="#_zf">file</a>
          and apply it to the input data. <a href="#gain_dat">&rarr; file
            format</a></dd>
        <dt><kbd><a name="_zf"></a>zf - </kbd>matrix calibration file<kbd> </kbd></dt>
        <dd>Overwrite the name of the matrix calibration file (<a href="#_zr">read</a>
          and <a href="#_zg">write</a>). <tt>zero.dat</tt> by default.</dd>
        <dt><kbd><a name="_zd" id="_zd"></a>zd - </kbd>verify the matrix
          calibration<kbd> </kbd></dt>
        <dd>The results from an earlier <a href="#matrix-cal">matrix
            calibration</a> are applied to the input data while another matrix
          calibration is done. The residuals are written to the <a href="#_z2f">matrix
verification
            file</a>. This option is mainly for diagnostic purposes. </dd>
        <dt><kbd><a name="_z2f" id="_z2f"></a>z2f<var>filename - </var></kbd>matrix
verification
          file<kbd><var> </var></kbd></dt>
        <dd>Overwrite the name of the matrix calibration verification file. <tt>zeroD.dat</tt>
          by default.</dd>
        <dt><kbd><a name="_lp"></a>lp<var>num - </var></kbd>pause between
          matrix calibration steps<kbd><var> </var></kbd></dt>
        <dd>Number of cycles between the tho steps of the matrix calibration
          (option <kbd><a href="#_zg">zg</a></kbd> and <a href="#_zd">zd</a>).
          Note that the effective time between the steps also scales with the <a
            href="#_n">block size</a>.</dd>
      </dl>
    </blockquote>
    <h3><a name="examples"></a>Examples</h3>
    <blockquote>
      <p>@@@TODO</p>
    </blockquote>
    <h2><a name="fileformat"></a>File formats </h2>
    <blockquote>
      <p>All files are ASCII, with blank separated, numeric columns. Currently
        there is no header line, but this may change in Future. A header line
        will start with <kbd>#</kbd>.</p>
    </blockquote>
    <h3><tt><a name="data_dat"></a>data.dat</tt> &ndash; details in FFT mode </h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[1]</td>
            <td><var>f</var></td>
            <td>Frequency</td>
          </tr>
          <tr>
            <td>[2]</td>
            <td>|<var>U</var>|</td>
            <td>Amplitude of <var>U</var>(<var>f</var>) or nominator
              respectively<br>
            </td>
          </tr>
          <tr>
            <td>[3]</td>
            <td>arg <var>U</var></td>
            <td>Phase angle of <var>U</var>(<var>f</var>) or nominator
              respectively in degrees<br>
            </td>
          </tr>
          <tr>
            <td>[4]</td>
            <td>|<var>I</var>|</td>
            <td>Amplitude of <var>I</var>(<var>f</var>) or denominator
              respectively<br>
            </td>
          </tr>
          <tr>
            <td>[5]</td>
            <td>arg&nbsp;<var>I</var></td>
            <td>Phase angle of <var>I</var>(<var>f</var>) or denominator
              respectively in degrees<br>
            </td>
          </tr>
          <tr>
            <td>[6]</td>
            <td>|<var>U</var>/<var>I</var>|</td>
            <td>Amplitude of the impedance <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
              or transfer function</td>
          </tr>
          <tr>
            <td>[7]</td>
            <td>arg <var>U</var>/<var>I</var></td>
            <td>Phase angle of the impedance <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
              or transfer function in degrees<br>
            </td>
          </tr>
          <tr>
            <td>[8]</td>
            <td>re&nbsp;<var>U</var>/<var>I</var></td>
            <td>Real part of the impedance <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
              or transfer function</td>
          </tr>
          <tr>
            <td>[9]</td>
            <td>im <var>U</var>/<var>I</var></td>
            <td>Imaginary part of the impedance <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
              or transfer function</td>
          </tr>
          <tr>
            <td>[10]</td>
            <td><var>weight</var></td>
            <td>Relative weight</td>
          </tr>
          <tr>
            <td>[11]</td>
            <td><var>delay</var></td>
            <td>Group delay d(<var>U</var>/<var>I</var>)/d<var>&omega;</var><br>
            </td>
          </tr>
          <tr>
            <td>[12]</td>
            <td><var>hamonic</var></td>
            <td>Ordinal of the harmonic. Negative values indicate the second
              channel in case <a href="#_mst">two channel mode</a> is activated</td>
          </tr>
        </tbody>
      </table>
      <p>From the above columns you may calculate the following parameters for
        one-port measurements:</p>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Symbol</th>
            <th>Descriptioc</th>
            <th>Formula</th>
            <th>Unit</th>
            <th>Remarks</th>
          </tr>
          <tr>
            <td valign="middle"><var>ESR</var></td>
            <td valign="middle">equivalent series resistor</td>
            <td valign="middle">[8] &middot; <var>R<sub>ref</sub></var></td>
            <td valign="middle">&Omega;</td>
            <td><br>
            </td>
          </tr>
          <tr>
            <td valign="middle"><var>ESC</var></td>
            <td valign="middle">equivalent series capacitor<br>
            </td>
            <td valign="middle">
              <table border="0" cellpadding="0" cellspacing="0">
                <tbody>
                  <tr>
                    <td align="center" nowrap="nowrap">-1</td>
                  </tr>
                  <tr>
                    <td style="border-top: 1px solid black;">2&pi; &middot; [1]
                      &middot; [9] &middot; <var>R<sub>ref</sub></var></td>
                  </tr>
                </tbody>
              </table>
            </td>
            <td valign="middle">F</td>
            <td valign="middle">only for [9] &lt; 0</td>
          </tr>
          <tr>
            <td valign="middle"><var>ESL</var></td>
            <td valign="middle">equivalent series inductor<br>
            </td>
            <td valign="middle">
              <table border="0" cellpadding="0" cellspacing="0">
                <tbody>
                  <tr>
                    <td align="center" nowrap="nowrap">[9] &middot; <var>R<sub>ref</sub></var></td>
                  </tr>
                  <tr>
                    <td align="center">2&pi; &middot; [1]</td>
                  </tr>
                </tbody>
              </table>
            </td>
            <td valign="middle">H</td>
            <td valign="middle">only for [9] &gt; 0</td>
          </tr>
          <tr>
            <td valign="middle">|<var>Z</var>|</td>
            <td valign="middle">absolute value of the impedance</td>
            <td valign="middle">[6] &middot; <var>R<sub>ref</sub></var></td>
            <td valign="middle">&Omega;</td>
            <td><br>
            </td>
          </tr>
          <tr>
            <td valign="middle"><var>Q</var></td>
            <td valign="middle">quality factor<br>
            </td>
            <td valign="middle">|[9]| / [8]</td>
            <td><br>
            </td>
            <td><br>
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h3><tt><a name="gain_dat"></a>gain.dat</tt> &ndash; gain calibration file<tt>
      </tt></h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[1]<br>
            </td>
            <td><var>f</var></td>
            <td>Frequency<br>
            </td>
          </tr>
          <tr>
            <td>[2]</td>
            <td><var>re</var></td>
            <td>Real part of gain difference</td>
          </tr>
          <tr>
            <td>[3]</td>
            <td><var>im</var></td>
            <td>Imaginary part of gain difference</td>
          </tr>
          <tr>
            <td>[4]</td>
            <td><var>abs</var></td>
            <td>Absolute value of gain difference</td>
          </tr>
          <tr>
            <td>[5]</td>
            <td><var>arg</var></td>
            <td>Phase angle of gain difference in degrees</td>
          </tr>
        </tbody>
      </table>
      <p>On input (option <a href="#_gr"><tt>gr</tt></a> and <a href="#_gd"><tt>gd</tt></a>)
        only the first three columns are used.</p>
    </blockquote>
    <h3><tt><a name="zero_dat"></a>zero.dat</tt> &ndash; matrix calibration file</h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[1]<br>
            </td>
            <td><var>f</var></td>
            <td>Frequency</td>
          </tr>
          <tr>
            <td>[2]</td>
            <td>re <var>c<sub>ll</sub></var></td>
            <td>Real part of coefficient <var>c<sub>ll</sub></var></td>
          </tr>
          <tr>
            <td>[3]</td>
            <td>im&nbsp;<var>c<sub>ll</sub></var></td>
            <td>Imaginary part of coefficient <var>c<sub>ll</sub></var></td>
          </tr>
          <tr>
            <td>[4]</td>
            <td>re <var>c<sub>lr</sub></var></td>
            <td>Real part of coefficient <var>c<sub>lr</sub></var></td>
          </tr>
          <tr>
            <td>[5]</td>
            <td>im <var>c<sub>lr</sub></var></td>
            <td>Imaginary part of coefficient <var>c<sub>lr</sub></var></td>
          </tr>
          <tr>
            <td>[6]</td>
            <td>re <var>c<sub>rl</sub></var></td>
            <td>Real part of coefficient <var>c<sub>rl</sub></var></td>
          </tr>
          <tr>
            <td>[7]</td>
            <td>im <var>c<sub>rl</sub></var></td>
            <td>Imaginary part of coefficient <var>c<sub>rl</sub></var></td>
          </tr>
          <tr>
            <td>[8]</td>
            <td>re <var>c<sub>rr</sub></var></td>
            <td>Real part of coefficient <var>c<sub>rr</sub></var></td>
          </tr>
          <tr>
            <td>[9]</td>
            <td>im <var>c<sub>rr</sub></var></td>
            <td>Imaginary part of coefficient <var>c<sub>rr</sub></var></td>
          </tr>
          <tr>
            <td>[10]</td>
            <td>abs&nbsp;<var>c<sub>ll</sub></var></td>
            <td>Absolute value of coefficient <var>c<sub>ll</sub></var></td>
          </tr>
          <tr>
            <td>[11]</td>
            <td>arg&nbsp;<var>c<sub>ll</sub></var></td>
            <td>Phase angle of coefficient <var>c<sub>ll</sub></var> in degrees<br>
            </td>
          </tr>
          <tr>
            <td>[12]</td>
            <td>abs <var>c<sub>lr</sub></var></td>
            <td>Absolute value of coefficient <var>c<sub>lr</sub></var></td>
          </tr>
          <tr>
            <td>[13]</td>
            <td>arg <var>c<sub>lr</sub></var></td>
            <td>Phase angle of coefficient <var>c<sub>lr</sub></var> in degrees</td>
          </tr>
          <tr>
            <td>[14]</td>
            <td>abs <var>c<sub>rl</sub></var></td>
            <td>Absolute value of coefficient <var>c<sub>rl</sub></var></td>
          </tr>
          <tr>
            <td>[15]</td>
            <td>arg <var>c<sub>rl</sub></var></td>
            <td>Phase angle of coefficient <var>c<sub>rl</sub></var> in degrees</td>
          </tr>
          <tr>
            <td>[16]</td>
            <td>abs <var>c<sub>rr</sub></var></td>
            <td>Absolute value of coefficient <var>c<sub>rr</sub></var></td>
          </tr>
          <tr>
            <td>[17]</td>
            <td>arg <var>c<sub>rr</sub></var></td>
            <td>Phase angle of coefficient <var>c<sub>rr</sub></var> in degrees</td>
          </tr>
        </tbody>
      </table>
      <p>The file contains an array of complex 2&times;2 matrices
        <table style="display: inline; vertical-align: middle;" cellpadding="0"
          cellspacing="0" height="22" width="54">
          <tbody>
            <tr>
              <td style="border-left: 1px solid black;"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black;"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
            </tr>
          </tbody>
        </table>
        . On input (option <a href="#_zr"><tt>zr</tt></a> and <a href="#_zd"><tt>zd</tt></a>)
        only the first 9 columns are used. <a href="#matrix_cal">&rarr; matrix
          calibration</a></p>
      <p>The physical meaning of the coefficients is: </p>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Coefficient</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td><var>c<sub>ll</sub></var></td>
            <td>Channel 1 gain<br>
            </td>
          </tr>
          <tr>
            <td><var>c<sub>lr</sub></var></td>
            <td>Cross talk from channel 2 to channel 1<br>
            </td>
          </tr>
          <tr>
            <td><var>c<sub>rl</sub></var></td>
            <td>Cross talk from channel 1 to channel 2<br>
            </td>
          </tr>
          <tr>
            <td><var>c<sub>rr</sub></var></td>
            <td>Channel 2 gain<br>
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h3><tt><a name="window_dat"></a>window.dat</tt> - window function<tt> </tt></h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Descroption</th>
          </tr>
          <tr>
            <td>-</td>
            <td>line number<br>
            </td>
            <td>sample index <var>n</var><br>
            </td>
          </tr>
          <tr>
            <td>[1]</td>
            <td><var>win(n)</var></td>
            <td>Relative value of the window function at index <var>n</var><br>
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h3><tt><a name="raw_dat"></a>raw.dat</tt> - raw data<tt> </tt></h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>-</td>
            <td>line number<br>
            </td>
            <td>sample index <var>n</var><br>
            </td>
          </tr>
          <tr>
            <td>[1]</td>
            <td><var>L(n)</var></td>
            <td>Channel 1 sample value<br>
            </td>
          </tr>
          <tr>
            <td>[2]</td>
            <td><var>R(n)</var></td>
            <td>Channel 2 sample value<br>
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h2><a name="cal"></a>Calibration</h2>
    <h3><a name="gain-cal"></a>Gain correction </h3>
    <blockquote>
      <p>The simple gain calibration mode only takes care of the <em>differences</em>
        in the transfer function between the two input channels. This is
        sufficient to compensate for tolerances and phase differences between
        the channels. This is particularly important in differential <a href="#_scm">scan
          mode</a>.</p>
      <p>Note that the gain calibration does not compensate for the absolute
        transfer function of the sound device in any way. It does not even
        distinguish between the transfer function of the line output stage and
        the transfer function of the line input. </p>
      <h4>How to do gain calibration </h4>
      <div style="width: 151px;" class="rightbox"> <img style="margin-bottom: 5px;"
          alt="" src="images/CircuitGainCal.png" height="77" width="151"><br>
        Schematic how to prepare for gain calibration. </div>
      <p>Connect both line in channels to one line out channel. Play a white
        noise and activate the gain correction mode with option <a href="#_gg"><tt>gg</tt></a>.
        The FFT and sampling parameters should match the parameters used for the
        subsequent measurements.</p>
      <p>For high precision it is recommended to use a cyclic reference signal
        that exactly match the FFT length. You could use the program <a href="noise.html">noise</a>
        to generate the reference. For synchronized measurements it is essential
        that the sampling rate of the DAC <em>exactly</em> matches that of the
        ADC, i.e they have to use the same clock oscillator. This requirement is
        usually fulfilled if both are on the same sound device. If you have
        different devices for analog input and output, then you need a world
        clock. </p>
      <h4>Result</h4>
      <div class="rightbox" style="width: 371px;"><img src="images/GainSample.png"
          alt="Beispiel fr Gainkorrektur" height="234" width="371"><br>
        Example of gain correction: Terratec XLerate (Aureal AU8820 chip) at
        48kHz and an FFT length of 65536 samples, average ofer 10 cycles.<br>
        The deviation in the amplitude is with &lt;&nbsp;0,2 dB pretty good, but
        the channels are obviously not sampled simultaneously. The time
        difference of &not; sample at the Nyquist frequency point to a serial
        conversion with two way oversampling. </div>
      <p>The result of the gain calibration is the complex and frequency
        dependent quotient:</p>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>gain_korr</var>(<var>f</var>)
                =&nbsp;</td>
              <td align="center" nowrap="nowrap">FFT(<var>channel 2</var>)</td>
            </tr>
            <tr>
              <td style="border-top: 1px solid black;">FFT(<var>channel 1</var>)</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
      <p>The magnitude of this quotient is a measure of the degree of gain
        difference between the two channels. A typical value is mainly
        independent of the frequency and close to but not exactly one. This is
        due to tolerances in resistors. At low frequencies the difference may
        increase due to tolerances in the coupling capacitors.</p>
      <p>The phase angle of the correction shows the synchronization of the
        channels. Beyond the small differences due to tolerance of the coupling
        capacitors there are usually no particular deviations. But some sound
        devices sample the two channels not simultaneously, but alternating. In
        this case there is a linear phase shift.</p>
      <h4>Using the correction </h4>
      <p>When using the correction is used with option <a href="#_gr">gr</a> it
        is only applied to channel 1. So do not use this correction to
        compensate for a complex transition function or there will be an impact
        on automatic weight function. </p>
    </blockquote>
    <h3><a name="matrix-cal"></a>Matrix correction </h3>
    <blockquote>
      <p>The simple gain calibration method above does not compensate for cross
        talk. So there is a superior calibration method called <em>matrix
          calibration</em>. It should be preferred at least for impedance
        measurements. </p>
      <p>Using <var>L<sub>ideal</sub></var>&nbsp;&prop;&nbsp;<var>U</var> and <var>R<sub>ideal</sub></var>&nbsp;&prop;&nbsp;<var>I</var>&nbsp;&middot;&nbsp;<var>R<sub>ref</sub></var>
        (<var>L</var> = channel 1, <var>R</var> = channel 2) the real impedance
        is: </p>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0" height="50" width="112">
          <tbody>
            <tr>
              <td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>Z</var>&nbsp;=&nbsp;</td>
              <td align="center" nowrap="nowrap"><var>L<sub>ideal</sub></var></td>
              <td colspan="1" rowspan="2" valign="middle">&nbsp;&middot;<sup>&nbsp;</sup><var>R<sub>ref</sub></var></td>
            </tr>
            <tr>
              <td style="border-top: 1px solid black;"><var>R<sub>ideal</sub></var></td>
            </tr>
          </tbody>
        </table>
      </blockquote>
      <p>But in fact you can't see <var>L<sub>ideal</sub></var> and <var>R<sub>ideal</sub></var>.
        What you really record is <var>L<sub>real</sub></var> and<var></var> <var>R<sub>real</sub></var>,
        a transformation:</p>
    </blockquote>
    <blockquote>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
              <td rowspan="2" align="center" valign="middle">&nbsp;=&nbsp; </td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
              <td rowspan="2" align="center" valign="middle">&nbsp;&middot;&nbsp;</td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
      <p>Of course, all the coefficients <var>c<sub>xx</sub></var> are complex
        and frequency dependent.</p>
      <h4>How to do the matrix calibration</h4>
      <h5>Impedance measurements </h5>
      <p>The matrix calibration is a two point calibration. In fact you do two
        calibration measurements. One with <var>Z</var>&nbsp;=&nbsp;0 (<var>L<sub>ideal</sub></var>&nbsp;=&nbsp;0)
        and another with <var>Z&nbsp;</var>=&nbsp;&infin; (<var>R<sub>ideal</sub></var>&nbsp;=&nbsp;0),
        in fact a short cut and no connection. The advantage is that this does
        not only compensate for the sound device but also for the whole
        measurement setup.</p>
      <h5>Transfer functions, two port measurements</h5>
      <div style="width: 340px;" class="rightbox"> <img style="margin-bottom: 5px;"
          alt="" src="images/CircuitMatrixCal.png" height="100" width="340"><br>
        Schematic how to prepare for matrix calibration of measurements of
        transfer functions. </div>
      <p>In case of two port measurements you usually cannot compensate for the
        setup. Then you have to compensate for the sound device only. The first
        calibration is done with the reference signal only connected to channel
        2 (<var>R</var>) and channel 1 (<var>L</var>) grounded. The second
        calibration is done the other way around. </p>
      <h5>Calibration sequence </h5>
      <p>When the matrix calibration is initiated with option <a href="#_zg"><tt>zg</tt></a>,
        analyze takes the following steps in sequence:</p>
      <ol>
        <li>Discard the first samples. (option <a href="#_psa"><tt>psa</tt></a>)</li>
        <li>Record <var>n</var> cycles (option <a href="#_ln"><tt>ln</tt></a>)
          of data.</li>
        <li>Output a message to setup for the next step to <tt>stderr</tt>.</li>
        <li>Discard some cycles. (option <a href="#_lp"><tt>lp</tt></a>)<br>
          In this time you have to change the setup for step two. </li>
        <li>Record another <var>n</var> cycles.</li>
        <li>Write the result file (option <a href="#_zf"><tt>zf</tt></a>) and
          terminate.</li>
      </ol>
      <h5>Important notes</h5>
      <p>It is essential to use <em>absolutely the same reference</em> signal
        in both steps. The reference therefore must be exactly reproducible. So
        it cannot be done with white noise but must by cyclic. This implies to
        use the same output channel of the sound device, too. It is also
        essential the the <em>phase</em> of the reference signal is 100%
        correlated in both steps. This is the reason why both measurements have
        to be done at one single run without closing the sound device in
        between. The synchronization of the input (ADC) and the output (DAC)
        have to be stable within less than one sample over the whole
        measurement. This is only possible if both are controlled by the same
        crystal oscillator. Fortunately this is naturally ensured as long as
        both are on the same sound device.</p>
      <h4>Result </h4>
      <p>In theory the matrix correction omits all linear errors without the
        need of an absolute reference. Practically this only works for the
        correction of sound device itself. For impedance measurements there is
        one degree of freedom to much. You know neither <var>R<sub>ideal</sub></var>
        at <var>Z</var>&nbsp;=&nbsp;0 nor <var>L<sub>ideal</sub></var> at <var>Z&nbsp;</var>=&nbsp;&infin;
and
        they are not necessarily the same. You could eliminate the additional
        degree of freedom if you assume that&nbsp;<var></var><var>U<sub>ref</sub></var>&nbsp;&prop;&nbsp;<var>L<sub>ideal</sub></var>&nbsp;+&nbsp;<var>R<sub>ideal</sub></var>
        =&gt; <var>R<sub>ideal</sub></var> at <var>Z</var>&nbsp;=&nbsp;0
        equals <var>L<sub>ideal</sub></var> at <var>Z&nbsp;</var>=&nbsp;&infin;
(see
        option <a href="#_zn"><tt>zn</tt></a>). But this introduces the
        systematic error that the high current at <var>Z</var>&nbsp;=&nbsp;0
        causes an additional voltage drop at <em>inductance of the wires</em>.</p>
      <div class="figure"><img src="images/ZeroSample.png" alt="Beispiel fr Gainkorrektur"
          height="484" width="748"><br>
        Example of matrix calibration result: on board Realtek ALC650 codec at
        48 kHz sampling rate and a <a href="http://www.maazl.de/electronic/LCR/LCR-Adapter.html">self-made
          probe</a> with 200&Omega; <var>R<sub>ref</sub></var> and an FFT
        length of 65536 samples, averaged over about 10 cycles.<br>
        The graphs show the diagonal (left) and the non diagonal (right) matrix
        elements, each with amplitude (top) and phase angle in degrees (bottom).<br>
        You see a capacitive cross talk from channel 1 to channel 2. The
        asymmetric cross talk is due to the probe.<br>
        The phase response of <i>c<sub>ll</sub></i> and <i>c<sub>rr</sub></i>
        shows a delay of about 12ns (!) between both channels. Note the
        extremely high accuracy in spite of the 20&aelig;s sampling resolution.<br>
        <i>c<sub>lr</sub></i> is that small (about -70 dB), that the phase
        (blue) is nearly undetermined. </div>
      <h4>Using the matrix correction </h4>
      <p>The matrix correction is applied to the measurement data with option <a
          href="#_zr"><tt>zr</tt></a>. This calculates the inverse
        transformation matrix and applies it to the input data before the data
        is passed to the FFT analysis. </p>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td colspan="4"><br>
              </td>
              <td colspan="1" rowspan="2" valign="middle">&nbsp;<sup>-1</sup></td>
              <td rowspan="1" colspan="2"><br>
              </td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
              <td rowspan="2" align="center" valign="middle"><var>&nbsp;</var>=&nbsp;
                </td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
              <td rowspan="2" align="center" valign="middle">&middot;&nbsp;</td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
              <td><br>
              </td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </blockquote>
    <h2><a name="history"></a>Program history</h2>
    <h4>Version 0.2</h4>
    <ul>
      <li>Port to Linux</li>
    </ul>
    <h4>Version 0.11</h4>
    <ul>
      <li>Source tree reorganized.</li>
      <li>Fit of the delay. </li>
      <li>English translation. </li>
    </ul>
    <h4>Version 0.1</h4>
    <ul>
      <li>Internal revision.</li>
    </ul>
    <h2><a name="todo"></a>TODOs, known issues </h2>
    <dl>
      <dt><b>3 point calibration </b></dt>
      <dd>Because of the limitations of the <a href="#zero-cal">matrix
          correction</a> a 3 point calibration would be helpful. This would be
        less sensitive on the reproducibility of the reference signal.</dd>
    </dl>
  </body>
</html>
