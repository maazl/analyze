<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
  <head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
    <title>Noise reference generator</title>
    <link href="mm.css" rel="stylesheet" type="text/css">
    <meta content="Marcel M&uuml;ller" name="author">
  </head>
  <body>
    <h1>Signal generator for cyclic noise patterns </h1>
    <p>Release: 0.2</p>
    <a href="index.html">&rarr;&nbsp;Index</a> <a href="#reference">&rarr;&nbsp;Parameters</a>
    <a href="#method">&rarr;&nbsp;How&nbsp;it&nbsp;works</a> <a href="#format">&rarr;&nbsp;File&nbsp;formats</a>
    <a href="index.html#download">&rarr;&nbsp;Download</a> <a href="#history">&rarr;&nbsp;History</a>
    <a href="#todo">&rarr;&nbsp;Todo</a> <a href="index.html#build">&rarr;&nbsp;Build</a>
    <h2><a name="overview"></a>Overview</h2>
    <p>This program <span style="font-family: monospace;">noise</span>
      generates cyclic noise patterns with adjustable properties, like energy
      distribution and relatively prime frequencies. The cyclic nature of the
      patterns makes the spectrum discrete which is ideal for FFT analysis
      without the need of a window function.</p>
    <p>The program does not handle the platform dependent output of the data to
      a DAC like a sound device. This is up to your environment. In general you
      should pipe the output to some device or application that can play PCM
      data. </p>
    <h3>Use cases </h3>
    <blockquote>Reference signal for measurements of impedance or transfer
      functions.</blockquote>
    <h3>Program sequence </h3>
    <blockquote>
      <p>The program writes <b>16-Bit PCM encoded audio data with two channels</b>
        in the machines native endianess to <tt><b>stdout</b></tt> or a
        destination file in RIFF wave format.</p>
    </blockquote>
    <h2><a name="options"></a>Command line options </h2>
    <dl compact="compact">
      <dt><a name="_ar"></a><tt>ar - </tt>append reference file<tt><br>
        </tt></dt>
      <dd>Append reference file (<a href="#_wr"><tt>wr</tt></a>) instead of
        overwriting.</dd>
      <dt><a name="_bn"></a><tt><b>bn</b><var><b>samples</b> -</var></tt><strong><tt><var>
            </var></tt></strong>cycle length<strong><tt><var> </var></tt></strong></dt>
      <dd>This is the number of samples in one period of the signal. This should
        be the same as the FFT length used for analysis. So powers of 2 should
        be preferred.</dd>
      <dt><b><a name="_fmin"></a><a name="_fmax"></a><tt>fmin<var>freq</var></tt></b>
        and <b><tt>fmax<var>freq</var></tt></b><tt> - </tt>frequency range<strong><tt><var>
            </var></tt></strong></dt>
      <dd>Minimum and maximum frequency where the output contains energy.</dd>
      <dt><tt><a name="_finc"></a>finc<var>channels</var></tt> and <tt><a name="_flog"></a>flog<var>increment
            </var></tt><tt><var>- </var></tt>linear and logarithmic increment
        for used frequencies </dt>
      <dd>This is creates a discrete energy distribution. Subsequent used
        frequencies have at least the distance <var>f<small><sub>n+1</sub></small>&nbsp;=
          f<small><sub>n</sub></small></var>&nbsp;&middot;&nbsp;<tt><var>channels</var>&nbsp;+&nbsp;<var>increment</var></tt>
        rounded to the closest multiple of the cycle frequency. All frequencies
        in between have no intensity.<br>
        This could be used to create support points in an approximately
        logarithmic frequency axis. </dd>
      <dt><tt><a name="_fsamp"></a>fsamp<var>freq - </var></tt>sampling
        frequency<tt><var> </var></tt></dt>
      <dd><span style="font-family: monospace;">48000</span> Hz by default.</dd>
      <dt><a name="_gm"></a><tt>gm - </tt>gain in dB</dt>
      <dd>Apply gain to the Output. The value should be negative because it
        refers to 0dB FSR.</dd>
      <dt><kbd><a name="_harm"></a>harm<var>n - </var></kbd>use harmonics<kbd><var>
          </var></kbd></dt>
      <dd>With this option the first <i><tt>n</tt></i> harmonics of any used
        frequency are reserved and do not contain energy. Instead the next free
        frequency will be used. This could be used to do very fast measurements
        of harmonics of loudspeakers. See <a href="#harmonics">dealing with
          harmonics</a>.</dd>
      <dt><a name="_ln"></a><tt>ln<var>count - </var></tt>number of cycles</dt>
      <dd>Number of cycles to generate until the program completes. The loop
        count only applies to <a href="#_ww">PCM output</a>.&nbsp; <span style="font-family: monospace;">1</span>
        by default.</dd>
      <dt><kbd><a name="_loop"></a>loop - </kbd>infinite output<kbd><var></var></kbd></dt>
      <dd>Switches the program to continuous mode. It can only be terminated by
        either sending a interrupt signal or when the output stream gets closed.
        You should not use this mode with file output, because it will not
        terminate until the disk is full.</dd>
      <dt><kbd><a name="_mst"></a>mst - </kbd>two channel mode</dt>
      <dd>In two channel mode the used frequencies are alternately used for as
        channel 1 and channel 2.</dd>
      <dt><tt><a name="_sweep"></a>msweep - </tt>sweep mode</dt>
      <dd>Use sweep mode rather than a noise pattern.</dd>
      <dt><a name="_scale"></a><tt>scale<var>power - </var></tt>noise type</dt>
      <dd>Exponent of the <a href="noise.html#method">energy distribution</a>.
        <span style="font-family: monospace;">0</span> := white noise, <span style="font-family: monospace;">-1</span>
        := pink noise. <span style="font-family: monospace;">0</span> by
        default.</dd>
      <dt><a name="_wr"></a><tt>wd<var>file - </var></tt>write design data</dt>
      <dd>Writes the design coefficients into a <a href="#design_dat">text file</a>.
        See @@@@@ </dd>
      <dt><a name="_wr"></a><tt>wr<var>file - </var></tt>write reference signal</dt>
      <dd>Writes one cycle of the reference signal to a <a href="#ref_dat">text
          file</a>. For each sample exactly one line is written.</dd>
      <dt><a name="_ww"></a><tt>ww<var>file - </var></tt>write PCM data</dt>
      <dd>Writes the <a href="#pcm-dat">binary data</a> as RIFF wave format. If
        <var><span style="font-family: monospace;">file</span></var> is <span style="font-family: monospace;">-</span>,
        the output is written to <tt>stdout</tt>. The Output is always
        normalized to 0 dB FSR. You could use a transient stream like a
        character device or a pipe (fifo) as destination too.</dd>
    </dl>
    <h3><a name="examples"></a>Examples</h3>
    <dl>
      <dt><kbd>noise bn65536 fmin20 fmax20000 ln100 wwnoise.wav</kbd></dt>
      <dd>Creates a file <tt>noise.wav</tt> with 100 cycles of a 65536 samples
        white noise pattern with 48 kHz sampling rate (about 2&frac12; minutes).
        Frequencies below 20 Hz and above 20 kHz are suppressed.</dd>
      <dt><kbd>noise bn65536 fmin50 fmax20000 loop scale-.5 | </kbd><var>some
          output device</var></dt>
      <dd>This creates an infinite repetition of 65536 samples noise, weighted
        with <var>f<font size="-1"><sup>-</sup></font></var><font size="-1"><sup>0,5</sup></font>
        at 48 kHz sampling rate. Frequencies below 50 Hz and above 20 kHz are
        suppressed. The output is written to <span style="font-family: monospace;">stdout</span>
        where a appropriate program or device handles the DAC output.</dd>
    </dl>
    <h2><a name="method"></a>How does it work?</h2>
    <blockquote>
      <p>The program creates the noise reference by inverse Discrete Fourier
        Transform. The <b>amplitudes</b> of the Fourier coefficients are
        calculated by:</p>
      <blockquote>
        <p><var>r<font size="-1"><sub>i</sub></font></var> = <var>f<font size="-1"><sub>i</sub><sup>&kappa;</sup></font></var></p>
      </blockquote>
      <p>The <b>phase angles</b> are chosen randomly.</p>
      <p>The exponent &kappa; controls the <b>energy distribution</b>. An
        homogeneous distribution (&kappa;&nbsp;=&nbsp;0) represents white noise.
        Positive values prefer high frequencies, negative values prefer low
        frequencies. &kappa;&nbsp;= -1 creates pink noise.</p>
      <p>All coefficients, outside the <b>frequency range [<var>f<font size="-1"><sub>min</sub></font></var>,
          <var>f<font size="-1"><sub>max</sub></font></var>]</b>, are purged.
        This is particularly required when &kappa; &lt; 0, because otherwise the
        amplitude of the DC component gets singular. </p>
      <p>After the inverse Fourier Transform the wave form is normalized to <b>0dB
          FSR</b>.</p>
    </blockquote>
    <h3><a name="harmonics"></a>Dealing with harmonics</h3>
    <blockquote>
      <p>The harmonics option excludes frequencies from the resulting spectrum
        if </p>
      <ul>
        <li>the current frequency is a harmonic of another used frequency or </li>
        <li>one of the first <var>n</var> harmonics of the current frequency is
          a harmonic of another used frequency.</li>
      </ul>
      <p>Because of the second condition it is strongly recommended to set the
        minimum frequency at least higher than the <var>n</var>th harmonic of
        the ground frequency of the generated pattern. Otherwise a large gap
        would occur after the first used frequency. </p>
      <img style="width: 771px; height: 368px;" alt="" src="images/64H3.png"><br>
      <p>The graph shows an example of the generated frequencies for a 64 sample
        noise pattern with 3 harmonics and a minimum frequency of 4:<br>
        <samp>noise fsamp64 fmin3 fmax32 harm3 wdnoise.dat</samp></p>
      <p><u>Comments</u><samp> </samp></p>
      <ul>
        <li>Frequency 4 is the first after <a href="#_fmin"><span style="font-family: monospace;">fmin</span></a>.
          This is always used.</li>
        <li>Frequency 6 has a collision at its 2nd harmonic with the 3rd
          harmonic of frequency 4 at frequency 12 and therefore cannot be used
          because it would make frequency 12 ambiguous.</li>
        <li>Frequency 5 has also a collision at its 4th harmonic with the 5th
          harmonic of frequency 4, but both are beyond the maximum harmonic to
          analyze (3 in this case) and so this does not care.</li>
        <li>Frequency 8 has a direct collision with the 2nd harmonic of
          frequency 4 and must not be used.</li>
        <li>Frequency 16 has a direct collision with the 4th harmonic of
          frequency 4. Although this harmonic is not analyzed it might get
          additional energy by non-linearities, so it is not used either.</li>
      </ul>
      In effect the noise pattern contains only energy at the frequencies with
      red circles. While all the frequencies with red <em>or</em> pink circles
      are used for analysis. See <a href="http://www.maazl.de/electronic/LS/Noise.html">'The
        Art of Noise'</a> for further information. </blockquote>
    <h2><a name="format"></a>File formats</h2>
    <h3><a name="design_dat"></a><tt>design.dat</tt> - design coefficients</h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[1]</td>
            <td><var>f</var></td>
            <td>Frequency</td>
          </tr>
          <tr>
            <td>[2]</td>
            <td>|<var>R</var>|</td>
            <td>Magnitude<var></var></td>
          </tr>
          <tr>
            <td>[3]</td>
            <td>arg <var>R</var></td>
            <td>Phase angle in degrees</td>
          </tr>
          <tr>
            <td>[4]</td>
            <td>re <var>R</var><var></var></td>
            <td>Real part (<var>a<sub>i</sub></var>)<br>
            </td>
          </tr>
          <tr>
            <td>[5]</td>
            <td>im&nbsp;<var>R</var></td>
            <td>Imaginary part (<var>b<sub>i</sub></var>)</td>
          </tr>
          <tr>
            <td>[6]</td>
            <td><var>hamonic</var></td>
            <td>Ordinal of the harmonic. Negative values indicate the second
              channel in case <a href="#_mst">two channel mode</a> is activated</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h3><a name="ref_dat"></a><span style="font-family: monospace;">ref.dat</span>
      - reference waveform</h3>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Column</th>
            <th>Symbol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>line no.</td>
            <td><var>i</var></td>
            <td>sample index</td>
          </tr>
          <tr>
            <td>[1]</td>
            <td>&Sigma;<var>s<sub>ij</sub></var></td>
            <td>sample value (sum over all channels)</td>
          </tr>
          <tr>
            <td>[2], two channel mode only</td>
            <td><var>s<sub>i1</sub></var></td>
            <td>sample value of first channel</td>
          </tr>
          <tr>
            <td>[3], two channel mode only</td>
            <td><var>s<sub>i2</sub></var></td>
            <td>sample value of second channel</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h3><a name="pcm_dat"></a><span style="font-family: monospace;">pcm.dat</span>
      - PCM output</h3>
    <blockquote>
      <p>In single channel mode the output is still stereo. The two channels are
        used symmetrically: <var>s<sub>i1</sub></var> = -<var>s<sub>i2</sub></var>.
        This could be used for an improved SNR. But if you don't need this,
        simply use only one of them. </p>
      <p>In <a href="#_mst">two channel mode</a> the two channels contain
        distinct data as you might suggest.</p>
      <p>The output will always be normalized to the maximum sample value
        &plusmn;32767. In two channel mode they are normalized simultaneously.</p>
    </blockquote>
    <h2><a name="history"></a>Change log</h2>
    <h4>Version 0.2</h4>
    <ul>
      <li>Port to Linux</li>
    </ul>
    <h4>Version 0.1.1</h4>
    <ul>
      <li>Support of harmonics</li>
      <li>Changed command line interface</li>
    </ul>
    <h4>Version 0.1</h4>
    <ul>
      <li>Internal revision</li>
    </ul>
    <h2><a name="todo"></a>TODOs, known issues</h2>
    <dl>
      <dt><b>RIFF format and endianess</b></dt>
      <dd>Currently only PCM data in RIFF wave format is supported for binary
        output and the endianess is always the platforms native one.</dd>
    </dl>
  </body>
</html>
