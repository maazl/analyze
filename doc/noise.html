<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title>Noise reference generator</title>
  <link href="mm.css" rel="stylesheet" type="text/css">
  <meta content="Marcel Müller" name="author">
</head>
<body>
<a href="index.html">&#8594;&nbsp;Index</a>
<h1>Signal generator for cyclic noise patterns</h1>
<p>Release: 0.1.1</p>
<a href="#reference">Parameters</a> <a href="#method">How it works</a>
<a href="#format">File format</a> <a href="index.html#download">Download</a>
<a href="#history">History</a>
<a href="#todo">Todo</a>
<a href="index.html#build">Build</a>
<h2><a name="overview"></a>Overview</h2>
<p>This program <span style="font-family: monospace;">noise</span>
generates cyclic noise patterns with adjustable properties, like energy
distribution and relatively prime frequencies. The cyclic nature of the
patterns makes the spectrum discrete which is ideal for FFT analysis
without the need of a window function.</p>
<p>The program does not handle the platform dependent output of the
data to an DAC like a sound device. This is up to your environment. In
general you should pipe the output to some device or application that
can play PCM data.<br>
</p>
<h3>Use cases<br>
</h3>
<blockquote>Reference signal for measurements of impedance or transfer
functions.</blockquote>
<h3>Program sequence<br>
</h3>
<blockquote>
  <p>The program writes<strong> 16-Bit PCM encoded
audio data with two channels</strong> to <tt><strong>stdout</strong></tt>
or a destination file in RIFF wave format.</p>
</blockquote>
<h2><a name="options"></a>Command line options<br>
</h2>
<blockquote>
  <dl compact="compact">
    <dt><strong><a name="_bn"></a><tt>bn<var>samples - </var></tt></strong>cycle
length<strong><tt><var><br>
      </var></tt></strong></dt>
    <dd>This is the number of samples in one period of the signal. This
should be the same as the FFT length used for analysis. So powers of 2
should be preferred.</dd>
    <dt><strong><a name="_fmin"></a><a name="_fmax"></a><tt>fmin<var>freq</var></tt></strong>
und <strong><tt>fmax<var>freq - </var></tt></strong>frequency range<strong><tt><var><br>
      </var></tt></strong></dt>
    <dd>Minimum and maximum frequency where the output contains energy.</dd>
    <dt><tt><a name="_finc"></a>finc<var>channels</var></tt> and <tt><a
 name="_flog"></a>flog<var>increment </var></tt><tt><var>- </var></tt>linear
and logarithmic increment for used frequencies<br>
    </dt>
    <dd>This is creates a discrete energy distribution. Subsequent used
frequencies have at
least the
distance <var>f<small><sub>n+1</sub></small>&nbsp;= f<small><sub>n</sub></small></var>&nbsp;·&nbsp;<tt><var>channels</var>&nbsp;+&nbsp;<var>increment</var></tt>
rounded to the closest multiple of the cycle frequency. All frequencies
in
between have no intensity.<br>
This could be used to create support points in an approximately
logarithmic frequency axis.<br>
    </dd>
    <dt><tt><a name="_fsamp"></a>fsamp<var>freq - </var></tt>sampling
frequency<tt><var><br>
      </var></tt></dt>
    <dd><span style="font-family: monospace;">48000</span> Hz by
default.</dd>
    <dt><kbd><a name="_harm"></a>harm<var>n - </var></kbd>use harmonics<kbd><var><br>
      </var></kbd></dt>
    <dd>With this option the first <i><tt>n</tt></i>
harmonics of any used frequency are reserved and do not contain energy.
Instead the next free frequency will be used. This could be used
to do very fast measurements of harmonics of loudspeakers. See <a
 href="#harmonics">dealing with harmonics</a>.</dd>
    <dt><a name="_ln"></a><tt>ln<var>count - </var></tt>number of
cycles</dt>
    <dd>Number of cycles to generate until the program completes. The
loop count ony applies to <a href="#_ww">PCM output</a>.&nbsp; <span
 style="font-family: monospace;">1</span> by default.</dd>
    <dt><kbd><a name="_loop"></a>loop - </kbd>infinite output<kbd><var></var></kbd></dt>
    <dd>Switches the program to continuous mode. It can only be
terminated by either sending a interrupt signal or when the output
stream gets closed. You should not use this mode with file output,
because it will not terminate until the disk is full.</dd>
    <dt><kbd><a name="_mst"></a>mst - </kbd>two channel mode</dt>
    <dd>In two channel mode the used frequencies are alternately used
for as channel 1 and channel 2.</dd>
    <dt><a name="_scale"></a><tt>scale<var>power - </var></tt>noise
type</dt>
    <dd>Exponent of the <a href="noise.html#method">energy distribution</a>.
      <span style="font-family: monospace;">0</span> := white noise, <span
 style="font-family: monospace;">-1</span> := pink noise. <span
 style="font-family: monospace;">0</span> by default.</dd>
    <dt><a name="_wr"></a><tt>wd<var>file - </var></tt>write design
data</dt>
    <dd>Writes the design coefficients into a <a href="#design_dat">text
file</a>. See @@@@@<br>
    </dd>
    <dt><a name="_wr"></a><tt>wr<var>file - </var></tt>write reference
signal</dt>
    <dd>Writes one cycle of the reference signal to a <a
 href="#ref_dat">text file</a>.
For each sample exactly one line is written.</dd>
    <dt><a name="_ww"></a><tt>ww<var>file - </var></tt>write PCM data</dt>
    <dd>Writes the <a href="#pcm-dat">binary data</a> as RIFF wave
format. If <var><span style="font-family: monospace;">file</span></var>
is <span style="font-family: monospace;">-</span>, the output is
written to <tt>stdout</tt>.
The Output is always normalized to 0 dB FSR. You could use a transient
stream like a character device or a pipe (fifo) as destination too.</dd>
  </dl>
</blockquote>
<h3><a name="examples"></a>Examples</h3>
<blockquote>
  <dl>
    <dt><kbd>noise bn65536 fmin20 fmax20000 ln100 wwnoise.wav</kbd></dt>
    <dd>Creates a file <tt>noise.wav</tt> with 100 cycles of a 65536
samples white noise pattern with 48 kHz sampling rate (about 2½
minutes).
Frequencies below 20 Hz and above 20 kHz are suppressed.</dd>
    <dt><kbd>noise bn65536 fmin50 fmax20000 loop scale-.5 | </kbd><var>some
output device</var></dt>
    <dd>This creates an infinite repetition of 65536 samples noise,
weighted with <var>f<font size="-1"><sup>-</sup></font></var><font
 size="-1"><sup>0,5</sup></font> at 48 kHz sampling rate. Frequencies
below 50 Hz and above 20 kHz are suppressed. The output is written to <span
 style="font-family: monospace;">stdout</span> where a appropriate
program or device handles the DAC output.</dd>
  </dl>
</blockquote>
<h2><a name="method"></a>How does it work?</h2>
<blockquote>
  <p>The program creates the noise reference by inverse discrete
Fourier Transform. The <strong>amplitudes</strong>
of the Fourier coefficients are calculated by:</p>
  <blockquote>
    <p><var>r<font size="-1"><sub>i</sub></font></var>
= <var>f<font size="-1"><sub>i</sub><sup>&#954;</sup></font></var></p>
  </blockquote>
  <p>The <strong>phase angles</strong> are chosen randomly.</p>
  <p>The exponent &#954; controls the <strong>energy distribution</strong>.
An homogeneous distribution (&#954;&nbsp;=&nbsp;0) represents white noise.
Positive values prefer high frequencies,
negative values prefer low frequencies. &#954;&nbsp;=
-1 creates pink noise.</p>
  <p>All coefficients, outside the <strong>frequency range
[<var>f<font size="-1"><sub>min</sub></font></var>, <var>f<font
 size="-1"><sub>max</sub></font></var>]</strong>, are
zeroed. This is particularly required when &#954; &lt; 0, because otherwise
the amplitude of the DC component gets singular.<br>
  </p>
  <p>After the inverse Fourier Transform the wave form is normalized to
  <strong>0dB FSR</strong>.</p>
</blockquote>
<h3><a name="harmonics"></a>Dealing with harmonics</h3>
<blockquote>
  <p>The harmonics option exculdes frequencies from the resulting
spectrum<br>
  </p>
  <ul>
    <li>if the current frequency is a harmonic of another used
frequency or<br>
    </li>
    <li>if one of the first <var>n</var> harmonics of the current
frequency is a harmonic of another used frequency.</li>
  </ul>
  <p>Because of the second condition it is strongly recommended to set
the minimum frequency at least higher than the <var>n</var>th harmonic
of the ground frequency of the generated pattern. Otherwise a large gap
would occur after the first used frequency.<br>
  </p>
  <img style="width: 771px; height: 368px;" alt="" src="images/64H3.png"><br>
  <p>The graph shows the generated frequencies for a 64 sample noise
pattern with 3 harmonics and a minimum frequency of 4:<br>
  <samp>noise fsamp64 fmin3 fmax32 harm3 wdnoise.dat</samp></p>
  <ul>
    <li>Frequency 4 is the first after fmin. This is always used.</li>
    <li>Frequency 6 has a collision at its 2nd harmonic with the 3rd
harmonic of frequency 4 at frequency 12 and therefore cannot be used.</li>
    <li>Frequency 5 has also a collision at its 4th harmonic with the
5th harmonic of frequency 4, but both are beyond the maximum harmonic
to analye (3) and so this does not care.</li>
    <li>Frequency 8 has a direct collision with the 2nd harmonic of
frequency 4 and must not be used.</li>
    <li>Frequency 16 has a direct collision with the 4th harmonic of
frequency 4. Although this harmonic is not analyzed it might get
energy, so it is not used either.</li>
  </ul>
In effect the noise pattern contains only energy at the frequencies
with red circles. While all the frequencies with red or pink circles
are used for analysis.<br>
</blockquote>
<h2><a name="format"></a>File formats</h2>
<h3><a name="design_dat"></a><tt>design.dat</tt> - design coefficients</h3>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Column</th>
        <th>Symbol</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>[1]</td>
        <td><var>f</var></td>
        <td>Frequency</td>
      </tr>
      <tr>
        <td>[2]</td>
        <td>|<var>R</var>|</td>
        <td>Magnitude<var></var></td>
      </tr>
      <tr>
        <td>[3]</td>
        <td>arg <var>R</var></td>
        <td>Phase angle in degrees</td>
      </tr>
      <tr>
        <td>[4]</td>
        <td>re <var>R</var><var></var></td>
        <td>Real part (<var>a<sub>i</sub></var>)<br>
        </td>
      </tr>
      <tr>
        <td>[5]</td>
        <td>im&nbsp;<var>R</var></td>
        <td>Imaginary part (<var>b<sub>i</sub></var>)</td>
      </tr>
      <tr>
        <td>[6]</td>
        <td><var>hamonic</var></td>
        <td>Ordinal of the harmonic. Negative values indicate the
second channel in case <a href="#_mst">two channel mode</a> is
activated</td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h3><a name="ref_dat"></a><span style="font-family: monospace;">ref.dat</span>
- reference waveform</h3>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Column</th>
        <th>Symbol</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>line no.</td>
        <td><var>i</var></td>
        <td>sample index</td>
      </tr>
      <tr>
        <td>[1]</td>
        <td>&#931;<var>s<sub>ij</sub></var></td>
        <td>sample value (sum over all channels)</td>
      </tr>
      <tr>
        <td>[2], two channel mode only</td>
        <td><var>s<sub>i1</sub></var></td>
        <td>sample value of first channel</td>
      </tr>
      <tr>
        <td>[3], two channel mode only</td>
        <td><var>s<sub>i2</sub></var></td>
        <td>sample value of second channel</td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h3><a name="pcm_dat"></a><span style="font-family: monospace;">pcm.dat</span>
- PCM output</h3>
<blockquote>
  <p>In single channel mode the output is still
stereo. The two
channels are used symmetrically: <var>s<sub>i1</sub></var>
= -<var>s<sub>i2</sub></var>. This could
be used for an improved SNR. The output will always be normalized to
the maximum sample value ±32767.<br>
  </p>
  <p>In <a href="#_mst">two channel mode</a> the two channels contain
the two channels as you might suggest.<br>
  </p>
</blockquote>
<h2><a name="history"></a>Change log</h2>
<h4>Version 0.1.1</h4>
<ul>
  <li>Support of harmonics</li>
  <li>Changed command line interface</li>
</ul>
<h4>Version 0.1</h4>
<ul>
  <li>Internal revision</li>
</ul>
<h2><a name="todo"></a>TODOs, known issues</h2>
<dl>
  <dt><b>RIFF format and endianess</b></dt>
  <dd>Currently only PCM data in RIFF wave format is supported for
binary output and the endianness is always the platforms native one.</dd>
</dl>
</body>
</html>
