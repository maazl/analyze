<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
    <title>Analysesoftware f&uuml;r &Uuml;bertragungsfunktions-Messungen per
      Frequenzscan</title>
    <link href="mm.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <h1>Analysesoftware f&uuml;r Impedanz- und
      &Uuml;bertragungsfunktions-Messungen per Frequenzscan </h1>
    <p><span class="abstract">Release: 0.1</span></p>
    <a href="index.html">&rarr;&nbsp;Index</a> <a href="#description">Beschreibung</a>
    <a href="#guide">Anleitung</a> <a href="#reference">Referenz</a> <a href="#cal">Kalibrierung</a>
    <a href="index.html#download">Download</a> <a href="#history">Historie</a>
    <a href="#todo">Todo</a> <a href="index.html#build">Compilieren</a>
    <h2><a name="description"></a>Kurzbeschreibung</h2>
    <p>Dieses Programm&nbsp;generiert Sinus-Referenzsignale unterschiedlicher
      Frequenz und analysiert die zeitgleich einlaufenden Messdaten. Die
      Ergebnisse werden in eine Textdatei fortgeschrieben.</p>
    <p>Die (plattformabh&auml;ngige) Aus und Eingabe der PCM-Daten sowie eine
      eventuelle Pufferung, um die Datenentsorgung in Echtzeit sicherzustellen,
      muss anderw&auml;rtig erfolgen.</p>
    <p>Das Programm liegt als C++-Quelltext vor und sollte sich mit vertretbarem
      Aufwand auf anderen Plattform &uuml;bersetzen lassen.</p>
    <h2><a name="guide"></a>Anleitung<br>
    </h2>
    <h3>Ablauflogik</h3>
    <ol>
      <li>
        <h4>Synchronisation</h4>
        <p>Zuallererst muss die Analyse der Messantwort auf das Referenzsignal
          synchronisiert werden. Dar&uuml;ber wird dann die Steuerung der
          Messzeitfenster bestimmt. Einmal synchronisiert z&auml;hlen sowohl
          Referenzsignalgenerator als auch die Analyse nur noch gemeinsam nach
          dem gleichen Schema die Samples. Deshalb ist es essentiell, dass die
          Parametrisierung identisch ist.</p>
        <p>Zudem muss sowohl die Wiedergabe des Referenzsignals als auch die
          Aufnahme der Messantwort auf sample-genau synchron laufenden
          Sounddevices erfolgen. Dazu braucht es entweder<em> einunddieselbe
            Soundkarte</em> oder <em>World-Clock</em>.</p>
        <p>Mit der Synchronisation werden unbekannte Latenzen im
          Signalverarbeitungsprozess kompensiert. Diese k&ouml;nnen aus
          I/O-Puffer kommen oder aber einfach dadurch, dass die Analyseseite
          nicht exakt zeitgleich zum Referenzsignal gestartet wurde. Alle <em>Latenzen</em>,
          die im Rahmen des <a href="#_sync">Synchronisationszeitfensters</a>
          noch erfasst werden, <em>haben keine Auswirkung auf das Messergebnis</em>.
          Es ist daher sinnvoll, die I/O-Puffer eher gro&szlig;z&uuml;gig zu
          gestalten, denn Sample-Drops haben sehr wohl Auswirkung auf das
          Ergebnis.</p>
        <p>Technisch gesehen findet die Synchronisation immer bei 1/4 der
          Nyquist-Frequenz mit einem 180&deg; Phasensprung statt. Das
          &Uuml;bertragungsverhalten des Messobjektes spielt dabei allerdings
          keine Rolle, weil nur mit dem parallel aufgezeichneten Referenzsignal
          synchronisiert wird.</p>
      </li>
      <li>
        <h4>Scan der Messfrequenzen</h4>
        <p>Einmal synchronisiert, werden f&uuml;r jede zu messende Frequenz die
          nachfolgenden Schritte durchgef&uuml;hrt.</p>
        <p>Das Programm verwendet, anders als der Name suggeriert, keinen
          stufenlosen Frequenzscan. Statt dessen wird bei einzelnen, diskreten
          Frequenzen gemessen, die alle eine Harmonische der durch die <a href="#_n">Datensatzgr&ouml;&szlig;e</a>
          festgelegten Grundfrequenz sind. Dies ist genauer.</p>
        <p>Die Frequenzen m&uuml;ssen aber nicht linear verteilt
          (&auml;quidistant) sein. &Uuml;ber den Parameter <a href="#_flog"><tt>flog</tt></a>
          kann ein Mindestabstand benachbarter Frequenzen gew&auml;hrleistet
          werden.</p>
      </li>
      <ol>
        <li>
          <h4>Einschwingzeit</h4>
          <p>Unmittelbar nach einer Frequenz&auml;nderung wartet das
            Analyseprogramm erstmal eine gewisse Zeit, bis sich das zu messende
            System in einem stabilen Zustand ohne Nachwirkungen der letzten
            Messfrequenz befindet.</p>
          <p>Wie lange eine sinnvolle Einschwingzeit ist, h&auml;ngt letztlich
            von der Frequenz und der Resonanzg&uuml;te der zu messenden Objekte
            ab. Sinnvolle Werte liegen in der Gr&ouml;&szlig;enordnung von 3<var>Q</var>/<var>f</var>.</p>
        </li>
        <li>
          <h4>Messung</h4>
          <p>Nun werden die Daten zu einer Frequenz erfasst. Hier kann &uuml;ber
            mehrere Datensatzgr&ouml;&szlig;en gemittelt werden, um die
            Genauigkeit zu erh&ouml;hen. Aufgrund der Synchronit&auml;t zwischen
            Referenzsignal und Analyse hat dieser Parameter unmittelbaren
            Einfluss auf das Signal-Untergrundverh&auml;ltnis. Alle nicht mit
            den analysierten Frequenzen synchronen St&ouml;rungen k&ouml;nnen
            mit gen&uuml;gend Messzeit ausgeblendet werden. Das gilt auch
            f&uuml;r das Rauschen der Soundkarte. Dadurch k&ouml;nnen mit diesem
            Messverfahren selbst mit r&auml;udigen Onboard-Soundkarten
            hochpr&auml;zise Ergebnisse ermittelt werden.</p>
        </li>
        <li>
          <h4>Analyse</h4>
          <p>Die aufgenommenen Informationen werden analysiert und an die <a href="#_df">Ausgabedatei</a>
            angeh&auml;ngt. W&auml;hrend dieser Zeit nimmt das Programm keine
            Daten entgegen. Der Ringpuffer f&uuml;r die Aufnahme muss daher
            gro&szlig; genug sein um diese Zeit zu &uuml;berbr&uuml;cken.</p>
        </li>
        <li>
          <h4>Nachlauf</h4>
          <p>Um die Auswirkungen einer nicht 100% sitzenden Synchronisation und
            unterschiedlicher Gruppenlaufzeiten zu kompensieren, l&auml;uft das
            Referenzsignal nach Abschluss der Messung noch einen Moment nach,
            bevor die Frequenz wechselt.</p>
        </li>
      </ol>
      <li>
        <h4>Programmende<br>
        </h4>
        <p>Das Programm endet, wenn die letzte vorgesehene Frequenz gemessen
          und/oder erzeugt ist, der Eingabedatenstrom geschlossen wurde oder ein
          Interrupt-Signal gesendet wird (z.B. Ctrl-C).</p>
      </li>
    </ol>
    <ol>
    </ol>
    <h3>Betriebsmodi</h3>
    <blockquote>
      <p>Das Programm kennt drei Betriebsmodi:</p>
      <ol>
        <li>nur <strong>Referenzsignal erzeugen</strong>,</li>
        <li>nur <strong>Messantwort analysieren</strong> und</li>
        <li><strong>Referenzsignal erzeugen und</strong> gleichzeitig <strong>Messantwort
            analysieren</strong>.</li>
      </ol>
      <p>Die Komponenten zum Erzeugen des Referenzsignals und zum analysieren
        der Messantwort laufen komplett unabh&auml;ngig in eigenen Threads.</p>
      <p>Wenn die Referenzerzeugung und die Analyse in unterschiedlichen
        Programminstanzen laufen, ist streng darauf zu achten, dass beide
        Instanzen mit den gleichen Parametern gestartet werden, andernfalls ist
        das Ergebnis undefiniert. Lediglich der <a href="sweep.html#_ma">Parameter
f&uuml;r
          den Messmodus</a> sollte sich unterscheiden.</p>
    </blockquote>
    <h4><a name="refplay"></a>Referenzsignal erzeugen</h4>
    <blockquote>
      <p>Beim Erzeugen des Referenzsignals schreibt das Programm <strong>16-Bit
          PCM-kodierte Daten in 2 Kan&auml;len</strong> mit einem RIFF-Wave
        kompatiblen Header. Standardm&auml;&szlig;ig erfolgt die Ausgabe nach <tt>stdout</tt>
        und kann per Pipe zum Sounddevice umgeleitet werden. Sollte es sich bei
        dem Ziel um ein RAW-Device handeln, dass keinen WAV-Header
        ben&ouml;tigt, f&uuml;hrt das nur zu einem leichten
        St&ouml;rger&auml;usch am Anfang, was von der Synchronisation des
        Analyseteils ignoriert wird.</p>
      <p>Das Programm erzeugt das Referenzsignal entweder in mono oder
        symmetrisch. In letzterem Fall erfolgt die Ausgabe auf dem linken und
        rechten Kanal invers. </p>
    </blockquote>
    <h4><a name="analyze"></a>Messantwort analysieren</h4>
    <blockquote>
      <p>Das Programm liest kontinuierlich <strong>16-Bit PCM-kodierte Daten in
          2 Kan&auml;len</strong> von <tt><strong>stdin</strong></tt>, einer <a
          href="sweep.html#_in">Datei</a> oder einem Device und analysiert sie.
        Die Ergebnisse werden dann nach jeder Messfrequenz in die <strong>Datei
          <tt>data.dat</tt></strong> und/oder auf den Bildschirm (<tt>stderr</tt>)
        geschrieben. Danach kann optional ein Befehl &uuml;ber <tt>stdout</tt>
        ausgegeben werden, z.B. zur Steuerung von Gnuplot.</p>
    </blockquote>
    <blockquote>Die Analyse erfolgt immer aufgrund des gleichzeitig
      aufgezeichneten Referenzsignals und niemals auf Basis der theoretischen
      Kenntnis des Referenzsignals. Daher muss einer der zwei
      Stereoeing&auml;nge stets das Referenzsignal enthalten. N&auml;heres siehe
      <a href="#_scm">Scanmodus</a>.</blockquote>
    <h3><a name="examples"></a>Beispiele</h3>
    <blockquote>
      <p>@@@TODO</p>
    </blockquote>
    <h2><a name="reference"></a>Referenz</h2>
    <h3><a name="options"></a>Kommandozeilenparameter</h3>
    <dl compact="compact">
      <dt><kbd><a name="_bn"></a>bn<var>num</var></kbd></dt>
      <dd>L&auml;nge der Datenbl&ouml;cke auf <var><kbd>num</kbd></var> Samples
        festlegen. Diese Zahl ist <em>nach</em> einer eventuellen
        Zusammenfassung von Samples durch die Option <a href="sweep.html#_ca"><kbd>ca</kbd></a>
        zu verstehen. Ohne die Option <kbd>bn</kbd> wird eine
        Standardl&auml;nge von 8192 Samples verwendet.</dd>
      <dt><kbd><a name="_ca"></a>ca<var>num</var></kbd></dt>
      <dd>Addiert immer <var><kbd>num</kbd></var> benachbarte Samples bei der
        Verarbeitung der PCM-Daten. Dieses Feature kann genutzt werden, um die
        Samplingrate zu dr&uuml;cken und gleichzeitig das Rauschen zu mindern.
        Es handelt sich dabei nicht um eine geeignete Methode zum Downsampeln,
        sondern eher um eine Methode zur reduktion des ADC-Rauschens.<br>
        Fehlt der Parameter <var><kbd>num</kbd></var>, so werden je 2 Samples
        addiert und die effektive Samplingrate halbiert.</dd>
      <dt><kbd><a name="_df"></a>df<var>filename</var></kbd></dt>
      <dd>Name der Datendatei, die bei aktivierter Option <a href="#_wd"><kbd>wd</kbd></a>
        (regelm&auml;&szlig;ig) geschrieben wird. Standardm&auml;&szlig;ig
        heisst die Datei <tt>data.dat</tt>.</dd>
      <dt><kbd><a name="_exec"></a>exec<var>command</var></kbd></dt>
      <dd>Kommando, das nach dem Aktualisieren der Daten jedesmal
        ausgef&uuml;hrt wird. Achtung! Das Analyseprogramm stoppt bis zur
        Beendung des Kommandos. Das kann bei der Echtzeitverarbeitung der Daten
        problematisch werden. Daher ist im allgemeinen die Synchronisation
        &uuml;ber <tt>stdout</tt> (Option <a href="#_plot"><kbd>plot</kbd></a>)
        vorzuziehen.</dd>
      <dt><kbd><a name="_fmin"></a><a name="_fmax"></a>fmin<var>freq</var></kbd>
        und <kbd>fmax<var>freq</var></kbd></dt>
      <dd>Minimale und maximale Frequenz beim Frequenzscan. Diese Einstellung
        wirkt sich auf <em>alle</em> Folgeprozesse einschlie&szlig;lich der
        Berechnung der Kalibrierungsdaten etc. aus.</dd>
      <dt><kbd><a name="_fq"></a>fq<var>freq</var></kbd></dt>
      <dd>Prim&auml;re Samplingfrequenz vor einer eventuellen Reduzierung durch
        <a href="#_ca">Sampleaddition</a>. Dieser Parameter <strong>sollte
          immer angegeben werden</strong>, da er f&uuml;r dieverse Normierungen
        ben&ouml;tigt wird. Unter anderem bei der Bildung zeitlicher
        Ableitungen.<br>
        Ohne den Parameter wird derzeit fon einer Samplingfrequenz von
        48&nbsp;kHz ausgegangen. Zuk&uuml;nftige Programmversionen k&ouml;nnten
        dies jedoch als einen Fehler werten.</dd>
      <dt><kbd><a name="_g2f"></a>g2f<var>filename</var></kbd></dt>
      <dd>Dateiname f&uuml;r die Differenzdatei bei der Validierung der
        Gain-Kalibrierung. Siehe Option <a href="#_gd"><kbd>gd</kbd></a>.</dd>
      <dt><kbd><a name="_gd"></a>gd</kbd></dt>
      <dd>Validierung der <a href="#gain-cal">Gainkalibrierung</a>
        durchf&uuml;hren. Mit dieser Option wird eine vorhandene
        Gain-Kalibrierung aus der Datei <tt>gain.dat</tt> oder der mit der
        Option <a href="#_gf"><kbd>gf</kbd></a> angegebenen Datei angewendet
        und die sich danach immernoch ergebenden Gain-Abweichungen in die Datei
        <tt>gainD.dat</tt> oder die mit der Option <a href="#_g2f"><kbd>g2f</kbd></a>
        angegebene Datei geschrieben. Diese Option ist haupts&auml;chlich zur
        Fehlersuche hilfreich.</dd>
      <dt><kbd><a name="_gf"></a>gf</kbd></dt>
      <dd>Dateiname f&uuml;r die Gainkalibrierung. Dieser Dateiname ist f&uuml;r
        die Funktionen <a href="#_gr"><kbd>gg</kbd></a> und <a href="#_gr"><kbd>gr</kbd></a>
        relevant. Standardm&auml;&szlig;ig heisst die Datei <tt>gain.dat</tt>.</dd>
      <dt><kbd><a name="_gg"></a>gg</kbd></dt>
      <dd><a href="#gain-cal">Gainkalibrierung</a> durchf&uuml;hren. Das
        Ergebnis wird in die Datei <tt>gain.dat</tt> oder der mit der Option <a
          href="#_gf"><kbd>gf</kbd></a> angegebenen Datei geschrieben. <a href="#gain_dat">&rarr;Dateiformat</a></dd>
      <dt><kbd><a name="_gr"></a>gr</kbd></dt>
      <dd><a href="#gain-cal">Gainkalibrierung</a> aus einer fr&uuml;heren
        Kalibrierungsmessung verwenden. Die Daten werden aus der Datei <tt>gain.dat</tt>
        oder der mit der Option <a href="#_gf"><kbd>gf</kbd></a> angegebenen
        Datei gelesen. <a href="#gain.dat">&rarr;Dateiformat</a></dd>
      <dt><kbd><a name="_hd"></a>hd</kbd></dt>
      <dd>Automatische Gewichtungsfunktion f&uuml;r den differenziellen
        Scanmodus <a href="#_scm"><kbd>scm1</kbd></a> aktivieren.</dd>
      <dt><kbd><a name="_in"></a>in<var>filename</var></kbd></dt>
      <dd>PCM-Daten aus <var><kbd>filename</kbd></var> lesen (anstelle von <tt>stdin</tt>).
        Der angegebene Name kann auch ein transienter Datenstrom, wie z.B. eine
        Pipe (FiFo) oder ein Device sein.</dd>
      <dt><kbd><a name="_ln"></a>ln<var>num</var></kbd></dt>
      <dd><kbd><var>num</var></kbd> Einzelanalysen in Folge durchf&uuml;hren und
        das Programm danach beenden. Standardm&auml;&szlig;ig wird nur exakt ein
        Durchlauf ausgef&uuml;hrt.</dd>
      <dt><kbd><a name="_loop"></a>loop</kbd></dt>
      <dd>Endlosmodus. Das Programm kann nur durch ein Ende der Eingabedaten
        oder einer Abbruch gestoppt werden.</dd>
      <dt><kbd><a name="_lp"></a>lp<var>num</var></kbd></dt>
      <dd>Anzahl der zu verwerfenden Datenbl&ouml;cke in der Pause der <a href="#zero-cal">Nullwert-Kalibrierung</a>
        (Option <kbd><a href="#_zg">zg</a></kbd>).</dd>
      <dt><kbd><a name="_plot" id="_plot"></a>plot<var>command</var></kbd></dt>
      <dd>Kommando nach jedem Analyseergebnis &uuml;ber <tt>stdout</tt> als
        eigene Zeile ausgeben. Dies kann z.B. verwendet werden, um eine
        grafische Visualisierung z.B. durch Gnuplot in Echtzeit zu
        aktualisieren. Diese Option kann nicht gleichzeitig zur Ausgabe des
        Referenzsignals nach <tt>stdout</tt> verwendet werden.</dd>
      <dt><kbd><a name="_psa"></a>psa<var>num</var></kbd></dt>
      <dd>Die ersten <kbd><var>num</var></kbd> Samples verwerfen. Dies kann
        benutzt werden, um eventuelle Header-Daten in einem PCM-Datenstrom zu
        &uuml;berspringen (z.B. <kbd>pca11</kbd> f&uuml;r <tt>.WAV</tt>-Dateien).</dd>
      <dt><kbd><a name="_pte"></a>pte</kbd></dt>
      <dd>Nach Beendigung der Messung weiterhin Daten lesen, diese jedoch
        verwerfen. Dies kann n&uuml;tzlich sein, wenn Echtzeit-Datenquellen
        allergisch reagieren, wenn sie ihren Daten nicht mehr los werden und auf
        anderem Wege gestoppt werden m&uuml;ssen. Das verhindert letztlich auch
        das Programmende, solange noch Eingabedaten kommen. Wenn der
        Eingabedatenstrom abbricht, wird das Programm dann beendet.</dd>
      <dt><kbd><a name="_rf"></a>rf<var>filename</var></kbd></dt>
      <dd>Dateiname f&uuml;r die Ausgabe der Quelldaten (Option <a href="#_wr"><kbd>wr</kbd></a>).
Standardm&auml;&szlig;ig
        hei&szlig;t die Datei <tt>raw.dat</tt>.</dd>
      <dt><kbd><a name="_rref"></a>rref<var>res</var></kbd></dt>
      <dd>Referenzwiderstand <var><kbd>res</kbd></var> bei der Analyse von
        Impedanzdaten ber&uuml;cksichtigen. Standardm&auml;&szlig;ig wird ein
        Wert von 1.0 verwendet. Das ist auch dann zu verwenden, wenn die
        Umrechnung bereits an anderer Stelle bei der Datenaufbereitung erfolgt.</dd>
      <dt><kbd><a name="_scm"></a>scm0</kbd>, <kbd>scm1</kbd> oder <kbd>scm2</kbd></dt>
      <dd>Modus bei der Entgegennahme der PCM-Daten:<br>
        <ul>
          <li><kbd>scm0</kbd> &ndash; PCM-Reihenfolge: Kanal&nbsp;1 = <var>U</var>(<var>t</var>),
            Kanal&nbsp;2 = <var>I</var>(<var>t</var>)</li>
          <li><kbd>scm1</kbd> &ndash; Differenzmodus: <var>U</var>(<var>t</var>)
            = Kanal 1, <var>I</var>(<var>t</var>) = Kanal&nbsp;2 &minus;
            Kanal&nbsp;1</li>
          <li><kbd>scm2</kbd> &ndash; Kan&auml;le vertauschen: Kanal&nbsp;1 = <var>I</var>(<var>t</var>),
            Kanal&nbsp;2 = <var>U</var>(<var>t</var>)</li>
        </ul>
        Der Differenzmodus ist praktisch, weil er sehr einfache
        Impedanzmessungen durch die Reihenschaltung eines Referenzwiderstandes
        mit der zu messenden Impedanz ohne Instrumentenverst&auml;rker erlaubt.
        Allerding reagiert dieser Modus aufgrund der Differenzbildung von
        &auml;hnlich gro&szlig;en Zahlen auch sehr allergisch auf kleinste
        Asymmetrien zwischen den beiden Kan&auml;len.</dd>
      <dt><kbd><a name="_wd"></a>wd</kbd></dt>
      <dd>Ausf&uuml;hrliche Ergebnisse nach Analyse jeder Messfrequenz an die
        Datei <tt>data.dat</tt> oder die mit der Option <a href="#_df"><kbd>df</kbd></a>
        angegebene Datei anh&auml;ngen. <a href="#data_dat">&rarr;Dateiformat</a></dd>
      <dt><kbd><a name="_wr"></a>wr</kbd></dt>
      <dd>Rohdaten in die Datei <tt>raw.dat</tt> oder die mit der Option <a href="#_rf"><kbd>rf</kbd></a>
        angegebene Datei schreiben. Das sind die Daten, wie sie aus dem
        Eingabedatenstrom kommen. Die Option ist normalerweise nur zur
        Fehlersuche gedacht. <a href="#raw_dat">&rarr;Dateiformat</a></dd>
      <dt><kbd><a name="_z2f" id="_z2f"></a>z2f<var>filename</var></kbd></dt>
      <dd>Dateiname f&uuml;r die Differenzdatei bei der Validierung der
        Null-Kalibrierung. Siehe Option <a href="#_zd"><kbd>zd</kbd></a>.</dd>
      <dt><kbd><a name="_zd" id="_zd"></a>zd</kbd></dt>
      <dd>Validierung der <a href="#gain-cal">Null-Kalibrierung</a>
        durchf&uuml;hren. Mit dieser Option wird eine vorhandene
        Null-Kalibrierung aus der Datei <tt>zero.dat</tt> oder der mit der
        Option <a href="#_zf"><kbd>zf</kbd></a> angegebenen Datei angewendet
        und die sich danach immernoch ergebenden Nullwert-Abweichungen in die
        Datei <tt>zeroD.dat</tt> oder die mit der Option <a href="#_z2f"><kbd>z2f</kbd></a>
        angegebene Datei geschrieben. Diese Option ist haupts&auml;chlich zur
        Fehlersuche hilfreich.</dd>
      <dt><kbd><a name="_zf"></a>zf</kbd></dt>
      <dd>Dateiname f&uuml;r die Gainkalibrierung. Dieser Dateiname ist f&uuml;r
        die Funktionen <a href="#_zr"><kbd>zg</kbd></a> und <a href="#_zr"><kbd>zr</kbd></a>
        relevant. Standardm&auml;&szlig;ig heisst die Datei <tt>zero.dat</tt>.</dd>
      <dt><kbd><a name="_zg"></a>zg</kbd></dt>
      <dd><a href="#zero-cal">Null-Kalibrierung</a> durchf&uuml;hren. Das
        Ergebnis wird in die Datei <tt>zero.dat</tt> oder der mit der Option <a
          href="#_zf"><kbd>zf</kbd></a> angegebenen Datei geschrieben.</dd>
      <dt><kbd><a name="_zn"></a>zn</kbd></dt>
      <dd>Amplituden normalisieren. Dabei wird die Summe der komplexen
        Amplituden von Kanal 1 und Kanal 2 f&uuml;r alle Frequenzkan&auml;le
        einzeln vor der Weiterverarbeitung auf konstant 1 normiert. Dies hat bei
        Impedanzmessungen zun&auml;chst einmal keine Auswirkung, da nur die
        relativen, komplexen Amplituden (<var>U</var>(<var>f</var>)&nbsp;/<var>&nbsp;I</var>(<var>f</var>))
verwendet
        werden. Sollen jedoch die Ergebnisse verschiedener Messungen direkt ins
        Verh&auml;ltnis gesetzt werden, wie es bei der Null-Kalibrierung der
        Fall ist, bekommt diese Option durchaus Relevanz, da nun auch Daten ins
        Verh&auml;ltnis gesetzt werden k&ouml;nnen, bei denen das Referenzsignal
        aus technischen Gr&uuml;nden nicht exakt &uuml;bereinstimmt.</dd>
      <dt><kbd><a name="_zr"></a>zr</kbd></dt>
      <dd><a href="#zero-cal">Null-Kalibrierung</a> aus einer fr&uuml;heren
        Kalibrierungsmessung verwenden. Die Daten werden aus der Datei <tt>zero.dat</tt>
        oder der mit der Option <a href="#_gf"><kbd>zf</kbd></a> angegebenen
        Datei gelesen. <a href="#gain_dat">&rarr;Dateiformat</a></dd>
    </dl>
    <h3><a name="fileformat"></a>Dateiformate</h3>
    <blockquote>
      <p>Alle Dateien sind ASCII-Dateien, die aus tabulator-separierten,
        numerischen Spalten bestehen. Es gibt derzeit keine
        Spalten&uuml;berschriften. Die Daten beginnen sofort mit Zeile 1.
        Zuk&uuml;nftige Programmversionen k&ouml;nnten jedoch eine
        &Uuml;berschriftszeile generieren. Diese ist an einem <strong><tt>#</tt></strong>
        im ersten Zeichen zu erkennen und ebenfalls tabulator-separiert. Im
        folgenden sind die Bedeutungen der einzelnen Spalten beschrieben.</p>
    </blockquote>
    <h4><tt><a name="data_dat"></a>data.dat</tt> &ndash; FFT-Modus</h4>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Spalte</th>
            <th>Kurzbezeichnung</th>
            <th>Beschreibung</th>
          </tr>
          <tr>
            <td>$1</td>
            <td><var>f</var></td>
            <td>Frequenz</td>
          </tr>
          <tr>
            <td>$2</td>
            <td>|<var>U</var>|</td>
            <td>Amplitude von <var>U</var>(<var>f</var>)</td>
          </tr>
          <tr>
            <td>$3</td>
            <td>arg <var>U</var></td>
            <td>Phase von <var>U</var>(<var>f</var>) in Grad</td>
          </tr>
          <tr>
            <td>$4</td>
            <td>|<var>I</var>|</td>
            <td>Amplitude von <var>I</var>(<var>f</var>)</td>
          </tr>
          <tr>
            <td>$5</td>
            <td>arg&nbsp;<var>I</var></td>
            <td>Phase von <var>I</var>(<var>f</var>) in Grad</td>
          </tr>
          <tr>
            <td>$6</td>
            <td>|<var>U</var>/<var>I</var>|</td>
            <td>Amplitude der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
          </tr>
          <tr>
            <td>$7</td>
            <td>arg <var>U</var>/<var>I</var></td>
            <td>Phase der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
              in Grad</td>
          </tr>
          <tr>
            <td>$8</td>
            <td>re&nbsp;<var>U</var>/<var>I</var></td>
            <td>Realteil der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
          </tr>
          <tr>
            <td>$9</td>
            <td>im <var>U</var>/<var>I</var></td>
            <td>Imagin&auml;rteil der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
          </tr>
          <tr>
            <td>$10</td>
            <td><var>weight</var></td>
            <td>relativer Gewichtungsfaktor</td>
          </tr>
          <tr>
            <td>$11</td>
            <td><var>delay</var></td>
            <td>Gruppenlaufzeit d(<var>U</var>/<var>I</var>)/d<var>&omega;</var>,
              ergibt nur f&uuml;r Vierpolmessungen Sinn.</td>
          </tr>
        </tbody>
      </table>
      <p>F&uuml;r Vierpolmessungen ist&nbsp;<var>I</var>(<var>f</var>) durch das
        Eingangssignal zu ersetzen und&nbsp;<var>U</var>(<var>f</var>) durch das
        Ausgangssignal.</p>
      <p>Aus den obigen Spalten k&ouml;nnen folgende, frequenzabh&auml;ngigen
        Werte wie folgt berechnet werden:</p>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Symbol</th>
            <th>Bezeichnung</th>
            <th>Formel</th>
            <th>Einheit</th>
            <th>Bemerkung</th>
          </tr>
          <tr>
            <td valign="middle"><a href="glossary.htlm#ESR"><var>ESR</var></a></td>
            <td valign="middle">&Auml;quivalenter Serienwiderstand</td>
            <td valign="middle">$8 &middot; <var>R<sub>ref</sub></var></td>
            <td valign="middle">&Omega;</td>
            <td valign="middle"><br>
            </td>
          </tr>
          <tr>
            <td valign="middle"><a href="glossary.html#ESC"><var>ESC</var></a></td>
            <td valign="middle">&Auml;quivalente Serienkapazit&auml;t</td>
            <td valign="middle">
              <table border="0" cellpadding="0" cellspacing="0">
                <tbody>
                  <tr>
                    <td align="center" nowrap="nowrap">-1</td>
                  </tr>
                  <tr>
                    <td style="border-top: 1px solid black;">2&pi; &middot; $1
                      &middot; $9 &middot; <var>R<sub>ref</sub></var></td>
                  </tr>
                </tbody>
              </table>
            </td>
            <td valign="middle">F</td>
            <td valign="middle">nur, wenn $9 &le; 0</td>
          </tr>
          <tr>
            <td valign="middle"><a href="glossary.html#ESL"><var>ESL</var></a></td>
            <td valign="middle">&Auml;quivalente Serieninduktivit&auml;t</td>
            <td valign="middle">
              <table border="0" cellpadding="0" cellspacing="0">
                <tbody>
                  <tr>
                    <td align="center" nowrap="nowrap">$9 &middot; <var>R<sub>ref</sub></var></td>
                  </tr>
                  <tr>
                    <td align="center">2&pi; &middot; $1</td>
                  </tr>
                </tbody>
              </table>
            </td>
            <td valign="middle">H</td>
            <td valign="middle">nur, wenn $9 &ge; 0</td>
          </tr>
          <tr>
            <td valign="middle">|<var>Z</var>|</td>
            <td valign="middle">Betrag der Impedanz</td>
            <td valign="middle">$6 &middot; <var>R<sub>ref</sub></var></td>
            <td valign="middle">&Omega;</td>
            <td valign="middle"><br>
            </td>
          </tr>
          <tr>
            <td valign="middle"><var>Q</var></td>
            <td valign="middle">Effektive G&uuml;te</td>
            <td valign="middle">|$9| / $8</td>
            <td valign="middle"><br>
            </td>
            <td valign="middle"><br>
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h4><tt><a name="gain_dat"></a>gain.dat</tt></h4>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Spalte</th>
            <th>Kurzbezeichnung</th>
            <th>Beschreibung</th>
          </tr>
          <tr>
            <td>-</td>
            <td>Zeilennummer</td>
            <td>Die Zeilen werden in der Reihenfolge der FFT-Frequenzen
              geschrieben, enthalten jedoch nicht die Frequenzkennung.</td>
          </tr>
          <tr>
            <td>$1</td>
            <td><var>re</var></td>
            <td>Realteil</td>
          </tr>
          <tr>
            <td>$2</td>
            <td><var>im</var></td>
            <td>Imagin&auml;rteil</td>
          </tr>
          <tr>
            <td>$3</td>
            <td><var>abs</var></td>
            <td>Betrag</td>
          </tr>
          <tr>
            <td>$4</td>
            <td><var>arg</var></td>
            <td>Phase in Grad</td>
          </tr>
        </tbody>
      </table>
      <p>Beim Einlesen der Datei <tt>gain.dat</tt> mit der Option <a href="#_gr"><tt>gr</tt></a>
        oder <a href="#_gd"><tt>gd</tt></a> werden nur die ersten beiden
        Spalten verwendet.</p>
    </blockquote>
    <h4><tt><a name="zero_dat"></a>zero.dat</tt></h4>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Spalte</th>
            <th>Kurzbezeichnung</th>
            <th>Beschreibung</th>
          </tr>
          <tr>
            <td>-</td>
            <td>Zeilennummer</td>
            <td>Die Zeilen werden in der Reihenfolge der FFT-Frequenzen
              geschrieben, enthalten jedoch nicht die Frequenzkennung.</td>
          </tr>
          <tr>
            <td>$1</td>
            <td>re <var>c<sub>ll</sub></var></td>
            <td>Realteil Koeffizient <var>c<sub>ll</sub></var></td>
          </tr>
          <tr>
            <td>$2</td>
            <td>im&nbsp;<var>c<sub>ll</sub></var></td>
            <td>Imagin&auml;rteil Koeffizient <var>c<sub>ll</sub></var></td>
          </tr>
          <tr>
            <td>$3</td>
            <td>re <var>c<sub>lr</sub></var></td>
            <td>Realteil Koeffizient <var>c<sub>lr</sub></var></td>
          </tr>
          <tr>
            <td>$4</td>
            <td>im <var>c<sub>lr</sub></var></td>
            <td>Imagin&auml;rteil Koeffizient <var>c<sub>lr</sub></var></td>
          </tr>
          <tr>
            <td>$5</td>
            <td>re <var>c<sub>rl</sub></var></td>
            <td>Realteil Koeffizient <var>c<sub>rl</sub></var></td>
          </tr>
          <tr>
            <td>$6</td>
            <td>im <var>c<sub>rl</sub></var></td>
            <td>Imagin&auml;rteil Koeffizient <var>c<sub>rl</sub></var></td>
          </tr>
          <tr>
            <td>$7</td>
            <td>re <var>c<sub>rr</sub></var></td>
            <td>Realteil Koeffizient <var>c<sub>rr</sub></var></td>
          </tr>
          <tr>
            <td>$8</td>
            <td>im <var>c<sub>rr</sub></var></td>
            <td>Imagin&auml;rteil Koeffizient <var>c<sub>rr</sub></var></td>
          </tr>
          <tr>
            <td>$9</td>
            <td>abs&nbsp;<var>c<sub>ll</sub></var></td>
            <td>Betrag Koeffizient <var>c<sub>ll</sub></var></td>
          </tr>
          <tr>
            <td>$10</td>
            <td>arg&nbsp;<var>c<sub>ll</sub></var></td>
            <td>Phase Koeffizient <var>c<sub>ll</sub></var> in Grad</td>
          </tr>
          <tr>
            <td>$11</td>
            <td>abs <var>c<sub>lr</sub></var></td>
            <td>Betrag Koeffizient <var>c<sub>lr</sub></var></td>
          </tr>
          <tr>
            <td>$12</td>
            <td>arg <var>c<sub>lr</sub></var></td>
            <td>Phase Koeffizient <var>c<sub>lr</sub></var> in Grad</td>
          </tr>
          <tr>
            <td>$13</td>
            <td>abs <var>c<sub>rl</sub></var></td>
            <td>Betrag Koeffizient <var>c<sub>rl</sub></var></td>
          </tr>
          <tr>
            <td>$14</td>
            <td>arg <var>c<sub>rl</sub></var></td>
            <td>Phase Koeffizient <var>c<sub>rl</sub></var> in Grad</td>
          </tr>
          <tr>
            <td>$15</td>
            <td>abs <var>c<sub>rr</sub></var></td>
            <td>Betrag Koeffizient <var>c<sub>rr</sub></var></td>
          </tr>
          <tr>
            <td>$16</td>
            <td>arg <var>c<sub>rr</sub></var></td>
            <td>Phase Koeffizient <var>c<sub>rr</sub></var> in Grad</td>
          </tr>
        </tbody>
      </table>
      <p>Diese Datei enth&auml;lt ein Array von komplexen 2&times;2 Matrizen der
        Form
        <table style="display: inline; vertical-align: middle;" cellpadding="0"
          cellspacing="0" height="22" width="54">
          <tbody>
            <tr>
              <td style="border-left: 1px solid black;"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black;"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
            </tr>
          </tbody>
        </table>
        .&nbsp;Beim Einlesen der Datei &uuml;ber die Option <a href="#_zr"><tt>zr</tt></a>
        oder <a href="#_zd"><tt>zd</tt></a> werden nur die ersten 8 Spalten
        verwendet. <a href="analyze.html#zero_cal">&rarr;Null-Kalibrierung</a></p>
      <p>Die semantische Bedeutung der Koeffizienten ist:</p>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Koeffizient</th>
            <th>Bedeutung</th>
          </tr>
          <tr>
            <td><var>c<sub>ll</sub></var></td>
            <td>Verst&auml;rkung f&uuml;r Kanal 1</td>
          </tr>
          <tr>
            <td><var>c<sub>lr</sub></var></td>
            <td>&Uuml;bersprechen von Kanal 2 auf Kanal 1</td>
          </tr>
          <tr>
            <td><var>c<sub>rl</sub></var></td>
            <td>&Uuml;bersprechen von Kanal 1 auf Kanal 2</td>
          </tr>
          <tr>
            <td><var>c<sub>rr</sub></var></td>
            <td>Verst&auml;rkung f&uuml;r Kanal 2</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h4><tt><a name="window_dat"></a>window.dat</tt></h4>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Spalte</th>
            <th>Kurzbezeichnung</th>
            <th>Beschreibung</th>
          </tr>
          <tr>
            <td>-</td>
            <td>Zeilennummer</td>
            <td>Index des Samples</td>
          </tr>
          <tr>
            <td>1</td>
            <td><var>win</var></td>
            <td>Wert der Fensterfunktion zum betreffenden Sample</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h4><tt><a name="raw_dat"></a>raw.dat</tt></h4>
    <blockquote>
      <table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <th>Spalte</th>
            <th>Kurzbezeichnung</th>
            <th>Beschreibung</th>
          </tr>
          <tr>
            <td>-</td>
            <td>Zeilennummer</td>
            <td>Index des Samples</td>
          </tr>
          <tr>
            <td>1</td>
            <td><var>L</var></td>
            <td>Wert des Samples von Kanal 1</td>
          </tr>
          <tr>
            <td>1</td>
            <td><var>R</var></td>
            <td>Wert des Samples von Kanal 2</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
    <h2><a name="cal"></a>Kalibrierung</h2>
    <h3><a name="gain-cal"></a>Gain-Kalibrierung</h3>
    <blockquote>
      <p>Bei der einfachsten Art der Kalibrierung wird mit einer Messung
        lediglich der <em>Gleichlauf</em> der beiden Kan&auml;le korrigiert.
        Damit k&ouml;nnen Torleranzen der Soundkarten sowie bauartbedingte
        Phasenverschiebungen zwischen den beiden Kan&auml;len korrigiert werden.
        Das ist besonders dann wichtig, wenn im differentiellen <a href="#_scm">Scan-Modus</a>
        (<tt>scm1</tt>) gearbeitet wird.</p>
      <h4>Durchf&uuml;hrung</h4>
      <p>Zur Gain-Kalibrierung m&uuml;ssen beide Kan&auml;le von Line-In mit
        einem der Line-Out Ausg&auml;nge verbunden werden. Anschlie&szlig;end
        ist mit wei&szlig;em Rauschen eine Kalibrierung mit der
        Kommandozeilenoption <a href="#_gg"><tt>gg</tt></a> durchzuf&uuml;hren.
        Die FFT- und Samplingparameter m&uuml;ssen dabei mit denen bei der zu
        korrigierenden realen Messung &uuml;bereinstimmen.</p>
      <h4>Ergebnis</h4>
      <div class="rightbox" style="width: 371px;"><img src="images/GainSample.png"
          alt="Beispiel f&uuml;r Gainkorrektur" height="234" width="371"><br>
        Beispiel f&uuml;r eine Gain-Korrektur: Terratec XLerate (Aureal AU8820
        Chip) bei 48kHz und einer FFT-L&auml;nge von 65536 Samples, gemittelt
        &uuml;ber ca. 10 Zyklen.<br>
        Der Amplitudenfehler ist mit &lt; 0,1dB ziemlich gut, aber die
        Kan&auml;le werden offenbar nicht exakt gleichzeitig gesampelt. Die
        Verschiebung von &frac14; Sample bei der Nyquistfrequenz deutet auf eine
        serielle Konertierung der Kan&auml;le sowie ein Zweifach-Oversampling
        zur Verminderung von Aliasing hin. </div>
      <p>Das Resultat der Korrektur ist der komplexe, frequenzabh&auml;ngige
        Quotient:</p>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>gain_korr</var>(<var>f</var>)
                =&nbsp;</td>
              <td align="center" nowrap="nowrap">FFT(<var>Kanal 2</var>)</td>
            </tr>
            <tr>
              <td style="border-top: 1px solid black;">FFT(<var>Kanal 1</var>)</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
      <p>Der Betrag der Korrektur ist ein frequenzabh&auml;ngiges Ma&szlig;
        f&uuml;r unterschiedliche Verst&auml;rkungsfaktoren bei den beiden
        Stereokan&auml;len. Typischerweise ist der Wert weitgehend
        frequenzabh&auml;ngig aber leicht verschieden von eins. Das kommt durch
        Bauteiltoleranzen bei den Widerst&auml;nden. Bei niedrigen Frequenzen
        gibt es &uuml;blicherweise eine Gr&ouml;&szlig;ere Abweichung. Das kommt
        durch Toleranzen bei den Koppelkondensatoren.</p>
      <p>Die Phase ist ein Ma&szlig; f&uuml;r den zeitlichen Gleichlauf der
        Kan&auml;le. Typischerweise gibt es au&szlig;er der ebenfalls auf die
        Koppelkondensatoren zur&uuml;ckzuf&uuml;hrenden Abweichung bei niedrigen
        Frequenzen hier keine Besonderheiten. Manche Soundkarten digitalisieren
        aber den rechten und den linken Kanal abwechselnd mit einem gemeinsamen
        ADC. Dadurch sind die Signale um ein halbes Sample zeitverschoben, was
        sich in einem linearen Anstieg der Phasendifferenz mit der Frequenz
        &auml;u&szlig;ert.</p>
      <h4>Korrektur</h4>
      <p>Bei der Anwendung der Korrektur wird willk&uuml;rlich nur Kanal 1
        korrigiert, da die Korrektur ohnehin nur relativ ist.</p>
    </blockquote>
    <h3><a name="zero-cal"></a>Null-Kalibrierung</h3>
    <blockquote>
      <p>Die bessere Art der Kalibrieirung f&uuml;r Impedanzmessungen (2-Pol)
        ist die Null-Kalibrierung. Bei dieser wird neben dem
        Verst&auml;rkungsfaktoren auch noch das <em>&Uuml;bersprechen</em> mit
        ber&uuml;cksichtigt. Es handelt sich um eine <strong>Zwei-Punkt-Kalibrierung</strong>.</p>
      <p>Unter Ber&uuml;cksichtigung von <var>L<sub>ideal</sub></var>&nbsp;&prop;&nbsp;<var>U</var>
        und <var>R<sub>ideal</sub></var>&nbsp;&prop;&nbsp;<var>I</var>&nbsp;&middot;&nbsp;<var>R<sub>ref</sub></var>
        ergibt sich die die reale Impedanz:</p>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0" height="50" width="112">
          <tbody>
            <tr>
              <td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>Z</var>&nbsp;=&nbsp;</td>
              <td align="center" nowrap="nowrap"><var>L<sub>ideal</sub></var></td>
              <td colspan="1" rowspan="2" valign="middle">&nbsp;&middot;<sup>&nbsp;</sup><var>R<sub>ref</sub></var></td>
            </tr>
            <tr>
              <td style="border-top: 1px solid black;"><var>R<sub>ideal</sub></var></td>
            </tr>
          </tbody>
        </table>
      </blockquote>
      <p>In Realit&auml;t hat man es aber mit den transformnierten Werten&nbsp;<var>L<sub>real</sub></var>
        und<var></var> <var>R<sub>real</sub></var> zu tun.
        Selbstverst&auml;ndlich sind alle Koeffizienten c<sub>xx</sub> komplex
        und frequenzabh&auml;ngig.</p>
    </blockquote>
    <blockquote>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
              <td rowspan="2" align="center" valign="middle">&nbsp;=&nbsp; </td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
              <td rowspan="2" align="center" valign="middle">&nbsp;&middot;&nbsp;</td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
      <h4>Durchf&uuml;hrung</h4>
      <p>Zur Null-Kalibirierung wird mit dem gesamten realen Messequipment
        einmal bei <var>Z</var>&nbsp;=&nbsp;0 (<var>L<sub>ideal</sub></var>&nbsp;=&nbsp;0)
        und einmal mit <var>Z&nbsp;</var>=&nbsp;&infin; (<var>R<sub>ideal</sub></var>&nbsp;=&nbsp;0)
        gemessen, also Kurzschluss und keine Verbindung. Dabei wird neben der
        Soundkarte auch das gesamte Messequipment mit kalibriert. Wenn eine
        Kalibrierung mit der Option <a href="#_zg"><tt>zg</tt></a> gestartet
        wird, Erwartet das Analyseprogramm zun&auml;chst einmal <a href="#_ln"><tt>ln</tt></a>
        Perioden mit&nbsp;<var>Z</var>&nbsp;=&nbsp;0. Anschlie&szlig;end kommt
        eine Bildschrirmausgabe nach <tt>stdout</tt> und eine kurze Pause. In
        der Pause muss das Messequipment auf <var>Z&nbsp;</var>=&nbsp;&infin;
        umgestellt werden. Dann werden nochmal <a href="analyze.html#_ln"><tt>ln</tt></a>
        Perioden aufgenommen, bevor das Ergebnis feststeht und der
        Eingabedatenstrom <tt>stdin</tt> geschlossen wird.</p>
      <p>Theoretisch lassen sich alle linearen Fehler ohne absolute Eichung
        korrigieren. Praktisch gibt es eine Unbekannte zuviel. Man kennt weder <var>R<sub>ideal</sub></var>
        bei <var>Z</var>&nbsp;=&nbsp;0 noch <var>L<sub>ideal</sub></var> bei <var>Z&nbsp;</var>=&nbsp;&infin;.
        Einer der Unbekannten kann man sich entledigen, in dem man
        willk&uuml;rlich definiert det&nbsp;<i>C</i>&nbsp;= 1. Das ist insofern
        erlaubt, als dass die absolute Skalierung bei der Bildung der
        Quotienten&nbsp;<var>L<sub>ideal</sub></var> /<var>&nbsp;R<sub>ideal</sub></var>
        keine Rolle spielt. Eine weitere Unbekannte kann man eliminieren, wenn
        man animmt, dass das Referenzsignal <var>U<sub>ref</sub></var> bei
        beiden Messungen dasselbe war, und <var>R<sub>ref</sub></var> und die
        Messimpedanz in Reihe geschaltet sind. Dann kann man n&auml;hern, dass <var>U<sub>ref</sub></var>&nbsp;&prop;&nbsp;<var>L<sub>ideal</sub></var>&nbsp;+&nbsp;<var>R<sub>ideal</sub></var>
        ist (siehe Option <a href="#_zn"><tt>zn</tt></a>). Dabei macht man
        einen Fehler: die zus&auml;tzlichen zu <var>R<sub>ref</sub></var> und <var>Z</var>
        in Reihe geschalteten Impedanzen allen voran die <strong>Zuleitungsinduktivit&auml;ten
          werden nicht ber&uuml;cksichtigt</strong>.</p>
      <h4>Ergebnis</h4>
      <div class="figure"><img src="images/ZeroSample.png" alt="Beispiel f&uuml;r Gainkorrektur"
          height="484" width="748"><br>
        Beispiel f&uuml;r eine Null-Korrektur: Onboard Realtek ALC650 Codec bei
        48kHz sowie der <a href="http://www.maazl.de/electronic/LCR/LCR-Adapter.html">gebastelte
          Messadapter</a> bei 200&Omega; <var>R<sub>ref</sub></var> und einer
        FFT-L&auml;nge von 65536 Samples, gemittelt &uuml;ber ca. 10 Zyklen.<br>
        Dargestellt sind die diagonalen (links) und die nichtdiagonalen
        Koeffizienten (rechts) der Transformationsmatrix jeweils in Betrag
        (oben) und Phase in Grad (unten).<br>
        Man erkennt ein kapazitives &Uuml;bersprechen vom linken zum rechten
        Kanal. Die Asymmetrie beim &Uuml;bersprechen erkl&auml;rt sich durch die
        Asymmetrie der Innenschaltung des Messadapter und den definitiv nicht
        hochfrequenztauglichen Aufbau.<br>
        Der Koeffizient <i>c<sub>lr</sub></i> ist in seiner Amplitude so klein
        (ca. -70dB), dass die Phase nahezu unbestimmt ist. Daher die relativ
        willk&uuml;rliche Verteilung der Phase. </div>
      <h4>Korrektur</h4>
      <p>Durch Inversion der Transformationsmatrix kann man die gemessenen Werte
        kompensieren:</p>
      <blockquote>
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td colspan="4"><br>
              </td>
              <td colspan="1" rowspan="2" valign="middle">&nbsp;<sup>-1</sup></td>
              <td rowspan="1" colspan="2"><br>
              </td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
              <td rowspan="2" align="center" valign="middle"><var>&nbsp;</var>=&nbsp;
                </td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
              <td rowspan="2" align="center" valign="middle">&middot;&nbsp;</td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
            </tr>
            <tr>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
              <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
              <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
              <td><br>
              </td>
              <td style="border-left: 1px solid black; border-right: 1px solid black;"
                align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </blockquote>
    <h2><a name="history"></a>Historie</h2>
    <h4>Version 0.11</h4>
    <ul>
      <li>Source-Verzeichnisstruktur reorganisiert.</li>
    </ul>
    <h4>Version 0.1</h4>
    <ul>
      <li>Interne Version</li>
    </ul>
    <h2><a name="todo"></a>TODOs, bekante Probleme</h2>
    <dl>
      <dt><b>3-Punkt-Kalibrierung</b></dt>
      <dd>Aufgrund den unzul&auml;nglichkeiten der Zweipunkteichung ist eine
        3-Punkt-Kalibrierung mit einer bekannten Referenzimpedanz
        w&uuml;nschenswert.</dd>
    </dl>
  </body>
</html>
