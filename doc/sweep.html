<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title>Analysesoftware für Übertragungsfunktions-Messungen per
Frequenzscan</title>
  <link href="mm.css" rel="stylesheet" type="text/css">
</head>
<body>
<a href="index.html">&#8594;&nbsp;Index</a><a href="glossary.html">
</a>
<h1>Analysesoftware für
Impedanz- und Übertragungsfunktions-Messungen per Frequenzscan</h1>
<p><span class="abstract">Release: 0.1</span></p>
<a href="#description">Beschreibung</a> <a href="#guide">Anleitung</a>
<a href="#reference">Referenz</a>
<a href="#cal">Kalibrierung</a>
<a href="index.html#download">Download</a>
<a href="#history">Historie</a>
<a href="#todo">Todo</a>
<a href="index.html#build">Compilieren</a>
<h2><a name="description"></a>Kurzbeschreibung</h2>
<p>Dieses Programm&nbsp;generiert Sinus-Referenzsignale
unterschiedlicher Frequenz und analysiert die zeitgleich einlaufenden
Messdaten. Die Ergebnisse werden in eine Textdatei fortgeschrieben.</p>
<p>Die (plattformabhängige) Aus und Eingabe der
PCM-Daten
sowie eine
eventuelle Pufferung, um die Datenentsorgung in Echtzeit
sicherzustellen, muss anderwärtig erfolgen.</p>
<p>Das
Programm liegt als C++-Quelltext vor und sollte sich mit vertretbarem
Aufwand auf anderen Plattform übersetzen lassen.</p>
<h2><a name="guide"></a>Anleitung<br>
</h2>
<h3>Ablauflogik</h3>
<ol>
  <li>
    <h4>Synchronisation</h4>
    <p>Zuallererst
muss die Analyse der Messantwort auf das Referenzsignal synchronisiert
werden. Darüber wird dann die Steuerung der Messzeitfenster
bestimmt. Einmal synchronisiert zählen sowohl
Referenzsignalgenerator als auch die Analyse nur noch gemeinsam nach
dem gleichen Schema die Samples. Deshalb ist es essentiell, dass die
Parametrisierung identisch ist.</p>
    <p>Zudem muss sowohl die Wiedergabe
des Referenzsignals als auch die Aufnahme der Messantwort auf
sample-genau synchron laufenden Sounddevices erfolgen. Dazu braucht es
entweder<em> einunddieselbe Soundkarte</em> oder <em>World-Clock</em>.</p>
    <p>Mit
der Synchronisation werden unbekannte Latenzen im
Signalverarbeitungsprozess kompensiert. Diese können aus
I/O-Puffer kommen oder aber einfach dadurch, dass die Analyseseite
nicht exakt zeitgleich zum Referenzsignal gestartet wurde. Alle <em>Latenzen</em>,
die im Rahmen des <a href="#_sync">Synchronisationszeitfensters</a>
noch erfasst werden, <em>haben keine Auswirkung auf das
Messergebnis</em>.
Es ist daher sinnvoll, die I/O-Puffer eher großzügig
zu
gestalten, denn Sample-Drops haben sehr wohl Auswirkung auf das
Ergebnis.</p>
    <p>Technisch gesehen findet die Synchronisation immer bei 1/4
der Nyquist-Frequenz mit einem 180° Phasensprung statt. Das
Übertragungsverhalten des Messobjektes spielt dabei allerdings
keine Rolle, weil nur mit dem parallel aufgezeichneten Referenzsignal
synchronisiert wird.</p>
  </li>
  <li>
    <h4>Scan der Messfrequenzen</h4>
    <p>Einmal synchronisiert, werden für jede zu
messende Frequenz die nachfolgenden Schritte durchgeführt.</p>
    <p>Das
Programm verwendet, anders als der Name suggeriert, keinen stufenlosen
Frequenzscan. Statt dessen wird bei einzelnen, diskreten Frequenzen
gemessen, die alle eine Harmonische der durch die <a href="#_n">Datensatzgröße</a>
festgelegten Grundfrequenz sind. Dies ist genauer.</p>
    <p>Die Frequenzen müssen aber nicht linear verteilt
(äquidistant) sein. Über den Parameter <a href="#_flog"><tt>flog</tt></a>
kann ein
Mindestabstand benachbarter Frequenzen gewährleistet werden.</p>
  </li>
  <ol>
    <li>
      <h4>Einschwingzeit</h4>
      <p>Unmittelbar
nach einer Frequenzänderung wartet das Analyseprogramm erstmal
eine gewisse Zeit, bis sich das zu messende System in einem stabilen
Zustand ohne Nachwirkungen der letzten Messfrequenz befindet.</p>
      <p>Wie lange eine sinnvolle Einschwingzeit ist,
hängt letztlich von der Frequenz und der Resonanzgüte
der zu messenden Objekte ab. Sinnvolle Werte liegen in der
Größenordnung von 3<var>Q</var>/<var>f</var>.</p>
    </li>
    <li>
      <h4>Messung</h4>
      <p>Nun
werden die Daten zu einer Frequenz erfasst. Hier kann über
mehrere
Datensatzgrößen gemittelt werden, um die Genauigkeit
zu
erhöhen. Aufgrund der Synchronität zwischen
Referenzsignal
und Analyse hat dieser Parameter unmittelbaren Einfluss auf das
Signal-Untergrundverhältnis. Alle nicht mit den analysierten
Frequenzen synchronen Störungen können mit
genügend
Messzeit ausgeblendet werden. Das gilt auch für das Rauschen
der
Soundkarte. Dadurch können mit diesem Messverfahren selbst mit
räudigen Onboard-Soundkarten hochpräzise Ergebnisse
ermittelt
werden.</p>
    </li>
    <li>
      <h4>Analyse</h4>
      <p>Die aufgenommenen Informationen werden analysiert und an
die <a href="#_df">Ausgabedatei</a>
angehängt. Während dieser Zeit nimmt das Programm
keine Daten
entgegen. Der Ringpuffer für die Aufnahme muss daher
groß
genug sein um diese Zeit zu überbrücken.</p>
    </li>
    <li>
      <h4>Nachlauf</h4>
      <p>Um
die Auswirkungen einer nicht 100% sitzenden Synchronisation und
unterschiedlicher Gruppenlaufzeiten zu kompensieren, läuft das
Referenzsignal nach Abschluss der Messung noch einen Moment nach, bevor
die Frequenz wechselt.</p>
    </li>
  </ol>
  <li>
    <h4>Programmende<br>
    </h4>
    <p>Das Programm endet, wenn die letzte vorgesehene Frequenz
gemessen
und/oder erzeugt ist, der Eingabedatenstrom geschlossen wurde oder ein
Interrupt-Signal gesendet wird (z.B. Ctrl-C).</p>
  </li>
</ol>
<ol>
</ol>
<h3>Betriebsmodi</h3>
<blockquote>
  <p>Das Programm kennt drei Betriebsmodi:</p>
  <ol>
    <li>nur <strong>Referenzsignal erzeugen</strong>,</li>
    <li>nur <strong>Messantwort analysieren</strong>
und</li>
    <li><strong>Referenzsignal erzeugen und</strong>
gleichzeitig <strong>Messantwort analysieren</strong>.</li>
  </ol>
  <p>Die
Komponenten zum Erzeugen des Referenzsignals und zum analysieren der
Messantwort laufen komplett unabhängig in eigenen Threads.</p>
  <p>Wenn
die Referenzerzeugung und die Analyse in unterschiedlichen
Programminstanzen laufen, ist streng darauf zu achten, dass beide
Instanzen mit den gleichen Parametern gestartet werden, andernfalls ist
das Ergebnis undefiniert. Lediglich der <a href="sweep.html#_ma">Parameter
für den Messmodus</a> sollte sich unterscheiden.</p>
</blockquote>
<h4><a name="refplay"></a>Referenzsignal
erzeugen</h4>
<blockquote>
  <p>Beim Erzeugen des Referenzsignals schreibt das Programm <strong>16-Bit
PCM-kodierte Daten in 2 Kanälen</strong> mit einem
RIFF-Wave kompatiblen Header. Standardmäßig erfolgt
die Ausgabe nach <tt>stdout</tt>
und kann per Pipe zum Sounddevice umgeleitet werden. Sollte es sich bei
dem Ziel um ein RAW-Device handeln, dass keinen WAV-Header
benötigt,
führt das nur zu einem leichten Störgeräusch
am Anfang, was von der
Synchronisation des Analyseteils ignoriert wird.</p>
  <p>Das
Programm erzeugt das Referenzsignal entweder in mono oder symmetrisch.
In letzterem Fall erfolgt die Ausgabe auf dem linken und rechten Kanal
invers. </p>
</blockquote>
<h4><a name="analyze"></a>Messantwort
analysieren</h4>
<blockquote>
  <p>Das Programm liest kontinuierlich <strong>16-Bit
PCM-kodierte Daten in 2 Kanälen</strong> von <tt><strong>stdin</strong></tt>,
einer <a href="sweep.html#_in">Datei</a> oder einem
Device
und analysiert
sie. Die Ergebnisse werden dann nach jeder Messfrequenz in die <strong>Datei
  <tt>data.dat</tt></strong> und/oder auf den
Bildschirm (<tt>stderr</tt>) geschrieben. Danach kann
optional ein Befehl über <tt>stdout</tt>
ausgegeben werden, z.B. zur Steuerung von Gnuplot.</p>
</blockquote>
<blockquote>Die
Analyse erfolgt immer aufgrund des gleichzeitig aufgezeichneten
Referenzsignals und niemals auf Basis der theoretischen Kenntnis des
Referenzsignals. Daher muss einer der zwei Stereoeingänge
stets
das Referenzsignal enthalten. Näheres siehe <a href="#_scm">Scanmodus</a>.</blockquote>
<h3><a name="examples"></a>Beispiele</h3>
<blockquote>
  <p>@@@TODO</p>
</blockquote>
<h2><a name="reference"></a>Referenz</h2>
<h3><a name="options"></a>Kommandozeilenparameter</h3>
<blockquote>
  <dl compact="compact">
    <dt><kbd><a name="_al"></a>al<var>num</var></kbd></dt>
    <dd>Mehrere Zyklen addieren. Dabei werden erst die Rohdaten
von <kbd><var>num</var></kbd> Messzyklen
addiert, bevor die Analyse startet.</dd>
    <dt><kbd><a name="_bn"></a>bn<var>num</var></kbd></dt>
    <dd>Länge der Datenblöcke auf <var><kbd>num</kbd></var>
Samples festlegen. Diese Zahl ist <em>nach</em> einer
eventuellen
Zusammenfassung von
Samples durch die Option <a href="sweep.html#_ca"><kbd>ca</kbd></a>
zu verstehen. Ohne die Option <kbd>bn</kbd> wird eine
Standardlänge von 8192 Samples verwendet.</dd>
    <dt><kbd><a name="_ca"></a>ca<var>num</var></kbd></dt>
    <dd>Addiert immer <var><kbd>num</kbd></var>
benachbarte Samples
bei der Verarbeitung der PCM-Daten. Dieses Feature kann genutzt werden,
um die Samplingrate zu drücken und gleichzeitig das Rauschen
zu
mindern. Es handelt sich dabei nicht um eine geeignete Methode zum
Downsampeln, sondern eher um eine Methode zur reduktion des
ADC-Rauschens.<br>
Fehlt der Parameter <var><kbd>num</kbd></var>,
so werden je 2 Samples addiert und die effektive Samplingrate halbiert.</dd>
    <dt><kbd><a name="_df"></a>df<var>filename</var></kbd></dt>
    <dd>Name der Datendatei, die bei aktivierter Option <a href="#_wd"><kbd>wd</kbd></a>
(regelmäßig) geschrieben wird.
Standardmäßig heisst die Datei <tt>data.dat</tt>.</dd>
    <dt><kbd><a name="_exec"></a>exec<var>command</var></kbd></dt>
    <dd>Kommando, das nach dem Aktualisieren der Daten jedesmal
ausgeführt wird. Achtung! Das Analyseprogramm stoppt bis zur
Beendung des Kommandos. Das kann bei der Echtzeitverarbeitung der Daten
problematisch werden. Daher ist im allgemeinen die Synchronisation
über <tt>stdout</tt> (Option <a href="#_plot"><kbd>plot</kbd></a>)
vorzuziehen.</dd>
    <dt><kbd><a name="_fmin"></a><a name="_fmax"></a>fmin<var>freq</var></kbd>
und <kbd>fmax<var>freq</var></kbd></dt>
    <dd>Minimale und maximale Frequenz beim Frequenzscan. Diese
Einstellung
wirkt sich auf <em>alle</em> Folgeprozesse
einschließlich der
Berechnung der Kalibrierungsdaten etc. aus.</dd>
    <dt><kbd><a name="_fq"></a>fq<var>freq</var></kbd></dt>
    <dd>Primäre Samplingfrequenz vor einer eventuellen
Reduzierung durch <a href="#_ca">Sampleaddition</a>.
Dieser Parameter <strong>sollte immer angegeben werden</strong>,
da er für dieverse Normierungen benötigt wird. Unter
anderem bei der Bildung zeitlicher Ableitungen.<br>
Ohne den Parameter wird derzeit fon einer Samplingfrequenz von
48&nbsp;kHz
ausgegangen. Zukünftige Programmversionen könnten
dies jedoch
als einen Fehler werten.</dd>
    <dt><kbd><a name="_g2f"></a>g2f<var>filename</var></kbd></dt>
    <dd>Dateiname für die Differenzdatei bei der
Validierung der Gain-Kalibrierung. Siehe Option <a href="#_gd"><kbd>gd</kbd></a>.</dd>
    <dt><kbd><a name="_gd"></a>gd</kbd></dt>
    <dd>Validierung der <a href="#gain-cal">Gainkalibrierung</a>
durchführen. Mit dieser Option wird eine vorhandene
Gain-Kalibrierung aus der Datei <tt>gain.dat</tt> oder der
mit der Option <a href="#_gf"><kbd>gf</kbd></a>
angegebenen Datei angewendet und die sich danach immernoch ergebenden
Gain-Abweichungen in die Datei <tt>gainD.dat</tt> oder die
mit der Option <a href="#_g2f"><kbd>g2f</kbd></a>
angegebene Datei geschrieben. Diese Option ist hauptsächlich
zur Fehlersuche hilfreich.</dd>
    <dt><kbd><a name="_gf"></a>gf</kbd></dt>
    <dd>Dateiname für die Gainkalibrierung. Dieser
Dateiname ist für die Funktionen <a href="#_gr"><kbd>gg</kbd></a>
und <a href="#_gr"><kbd>gr</kbd></a>
relevant. Standardmäßig heisst die Datei <tt>gain.dat</tt>.</dd>
    <dt><kbd><a name="_gg"></a>gg</kbd></dt>
    <dd><a href="#gain-cal">Gainkalibrierung</a>
durchführen. Das Ergebnis wird in die Datei <tt>gain.dat</tt>
oder der mit der Option <a href="#_gf"><kbd>gf</kbd></a>
angegebenen Datei geschrieben. <a href="#gain_dat">&#8594;Dateiformat</a></dd>
    <dt><kbd><a name="_gr"></a>gr</kbd></dt>
    <dd><a href="#gain-cal">Gainkalibrierung</a>
aus einer früheren Kalibrierungsmessung verwenden. Die Daten
werden aus der Datei <tt>gain.dat</tt> oder der mit der
Option <a href="#_gf"><kbd>gf</kbd></a>
angegebenen Datei gelesen. <a href="#gain.dat">&#8594;Dateiformat</a></dd>
    <dt><kbd><a name="_hd"></a>hd</kbd></dt>
    <dd>Automatische Gewichtungsfunktion für den
differenziellen Scanmodus <a href="#_scm"><kbd>scm1</kbd></a>
aktivieren.</dd>
    <dt><kbd><a name="_in"></a>in<var>filename</var></kbd></dt>
    <dd>PCM-Daten aus <var><kbd>filename</kbd></var>
lesen (anstelle von <tt>stdin</tt>). Der angegebene Name
kann auch ein transienter Datenstrom, wie z.B. eine Pipe (FiFo) oder
ein
Device sein.</dd>
    <dt><kbd><a name="_ln"></a>ln<var>num</var></kbd></dt>
    <dd><kbd><var>num</var></kbd>
Einzelanalysen in Folge
durchführen und das Programm danach beenden.
Standardmäßig wird nur exakt ein Durchlauf
ausgeführt.</dd>
    <dt><kbd><a name="_loop"></a>loop</kbd></dt>
    <dd>Endlosmodus. Das Programm kann nur durch ein Ende der
Eingabedaten oder einer Abbruch gestoppt werden.</dd>
    <dt><kbd><a name="_lp"></a>lp<var>num</var></kbd></dt>
    <dd>Anzahl der zu verwerfenden Datenblöcke in der
Pause der <a href="#zero-cal">Nullwert-Kalibrierung</a>
(Option <kbd><a href="#_zg">zg</a></kbd>).</dd>
    <dt><kbd><a name="_plot" id="_plot"></a>plot<var>command</var></kbd></dt>
    <dd>Kommando nach jedem Analyseergebnis über <tt>stdout</tt>
als eigene Zeile ausgeben. Dies kann z.B. verwendet werden, um eine
grafische Visualisierung z.B. durch Gnuplot in Echtzeit zu
aktualisieren. Diese Option kann nicht gleichzeitig zur Ausgabe des
Referenzsignals nach <tt>stdout</tt> verwendet werden.</dd>
    <dt><kbd><a name="_psa"></a>psa<var>num</var></kbd></dt>
    <dd>Die ersten <kbd><var>num</var></kbd>
Samples verwerfen. Dies
kann benutzt werden, um eventuelle
Header-Daten in einem PCM-Datenstrom zu überspringen (z.B. <kbd>pca11</kbd>
für <tt>.WAV</tt>-Dateien).</dd>
    <dt><kbd><a name="_pte"></a>pte</kbd></dt>
    <dd>Nach Beendigung der Messung
weiterhin Daten lesen, diese jedoch verwerfen. Dies kann
nützlich
sein, wenn Echtzeit-Datenquellen allergisch reagieren, wenn sie ihren
Daten nicht mehr los werden und auf anderem Wege gestoppt werden
müssen. Das verhindert letztlich auch das Programmende,
solange
noch Eingabedaten kommen. Wenn der Eingabedatenstrom abbricht, wird das
Programm dann beendet.</dd>
    <dt><kbd><a name="_rf"></a>rf<var>filename</var></kbd></dt>
    <dd>Dateiname für die Ausgabe der Quelldaten (Option
      <a href="#_wr"><kbd>wr</kbd></a>).
Standardmäßig heißt die Datei <tt>raw.dat</tt>.</dd>
    <dt><kbd><a name="_rref"></a>rref<var>res</var></kbd></dt>
    <dd>Referenzwiderstand <var><kbd>res</kbd></var>
bei der Analyse
von Impedanzdaten berücksichtigen.
Standardmäßig wird
ein Wert von 1.0 verwendet. Das ist auch dann zu verwenden, wenn die
Umrechnung bereits an anderer Stelle bei der Datenaufbereitung erfolgt.</dd>
    <dt><kbd><a name="_scm"></a>scm0</kbd>,
      <kbd>scm1</kbd> oder <kbd>scm2</kbd></dt>
    <dd>Modus bei der Entgegennahme der PCM-Daten:<br>
      <ul>
        <li><kbd>scm0</kbd> &#8211;
PCM-Reihenfolge:
Kanal&nbsp;1 = <var>U</var>(<var>t</var>),
Kanal&nbsp;2 = <var>I</var>(<var>t</var>)</li>
        <li><kbd>scm1</kbd> &#8211;
Differenzmodus: <var>U</var>(<var>t</var>)
= Kanal 1, <var>I</var>(<var>t</var>) =
Kanal&nbsp;2 &#8722; Kanal&nbsp;1</li>
        <li><kbd>scm2</kbd> &#8211;
Kanäle
vertauschen: Kanal&nbsp;1 = <var>I</var>(<var>t</var>),
Kanal&nbsp;2 = <var>U</var>(<var>t</var>)</li>
      </ul>
Der Differenzmodus ist praktisch, weil er sehr einfache
Impedanzmessungen durch die Reihenschaltung eines Referenzwiderstandes
mit der zu messenden Impedanz ohne Instrumentenverstärker
erlaubt.
Allerding reagiert dieser Modus aufgrund der Differenzbildung von
ähnlich großen Zahlen auch sehr allergisch auf
kleinste
Asymmetrien zwischen den beiden Kanälen.</dd>
    <dt><kbd><a name="_wd"></a>wd</kbd></dt>
    <dd>Ausführliche Ergebnisse nach Analyse jeder
Messfrequenz an die Datei <tt>data.dat</tt> oder die mit
der
Option <a href="#_df"><kbd>df</kbd></a>
angegebene Datei anhängen. <a href="#data_dat">&#8594;Dateiformat</a></dd>
    <dt><kbd><a name="_wr"></a>wr</kbd></dt>
    <dd>Rohdaten in die Datei <tt>raw.dat</tt> oder
die mit der Option <a href="#_rf"><kbd>rf</kbd></a>
angegebene Datei schreiben. Das sind die Daten, wie sie aus dem
Eingabedatenstrom kommen. Die Option ist normalerweise nur zur
Fehlersuche gedacht. <a href="#raw_dat">&#8594;Dateiformat</a></dd>
    <dt><kbd><a name="_z2f" id="_z2f"></a>z2f<var>filename</var></kbd></dt>
    <dd>Dateiname für die Differenzdatei bei der
Validierung der Null-Kalibrierung. Siehe Option <a href="#_zd"><kbd>zd</kbd></a>.</dd>
    <dt><kbd><a name="_zd" id="_zd"></a>zd</kbd></dt>
    <dd>Validierung der <a href="#gain-cal">Null-Kalibrierung</a>
durchführen. Mit dieser Option wird eine vorhandene
Null-Kalibrierung aus der Datei <tt>zero.dat</tt> oder der
mit der Option <a href="#_zf"><kbd>zf</kbd></a>
angegebenen Datei angewendet und die sich danach immernoch ergebenden
Nullwert-Abweichungen in die Datei <tt>zeroD.dat</tt> oder
die mit der Option <a href="#_z2f"><kbd>z2f</kbd></a>
angegebene Datei geschrieben. Diese Option ist hauptsächlich
zur Fehlersuche hilfreich.</dd>
    <dt><kbd><a name="_zf"></a>zf</kbd></dt>
    <dd>Dateiname für die Gainkalibrierung. Dieser
Dateiname ist für die Funktionen <a href="#_zr"><kbd>zg</kbd></a>
und <a href="#_zr"><kbd>zr</kbd></a>
relevant. Standardmäßig heisst die Datei <tt>zero.dat</tt>.</dd>
    <dt><kbd><a name="_zg"></a>zg</kbd></dt>
    <dd><a href="#zero-cal">Null-Kalibrierung</a>
durchführen. Das Ergebnis wird in die Datei <tt>zero.dat</tt>
oder der mit der Option <a href="#_zf"><kbd>zf</kbd></a>
angegebenen Datei geschrieben.</dd>
    <dt><kbd><a name="_zn"></a>zn</kbd></dt>
    <dd>Amplituden normalisieren. Dabei wird die Summe der
komplexen
Amplituden von Kanal 1 und Kanal 2 für alle
Frequenzkanäle
einzeln vor der Weiterverarbeitung auf konstant 1 normiert. Dies hat
bei Impedanzmessungen zunächst einmal keine Auswirkung, da nur
die
relativen, komplexen Amplituden (<var>U</var>(<var>f</var>)&nbsp;/<var>&nbsp;I</var>(<var>f</var>))
verwendet werden. Sollen jedoch die Ergebnisse verschiedener Messungen
direkt ins Verhältnis gesetzt werden, wie es bei der
Null-Kalibrierung der Fall ist, bekommt diese Option durchaus Relevanz,
da nun auch Daten ins Verhältnis gesetzt werden
können, bei
denen das Referenzsignal aus technischen Gründen nicht exakt
übereinstimmt.</dd>
    <dt><kbd><a name="_zr"></a>zr</kbd></dt>
    <dd><a href="#zero-cal">Null-Kalibrierung</a>
aus einer früheren Kalibrierungsmessung verwenden. Die Daten
werden aus der Datei <tt>zero.dat</tt> oder der mit der
Option <a href="#_gf"><kbd>zf</kbd></a>
angegebenen Datei gelesen. <a href="#gain_dat">&#8594;Dateiformat</a></dd>
  </dl>
</blockquote>
<h3><a name="fileformat"></a>Dateiformate</h3>
<blockquote>
  <p>Alle Dateien sind ASCII-Dateien, die aus
tabulator-separierten,
numerischen Spalten bestehen. Es gibt derzeit keine
Spaltenüberschriften. Die Daten beginnen sofort mit Zeile 1.
Zukünftige Programmversionen könnten jedoch eine
Überschriftszeile generieren. Diese ist an einem <strong><tt>#</tt></strong>
im ersten Zeichen zu erkennen und ebenfalls tabulator-separiert. Im
folgenden sind die Bedeutungen der einzelnen Spalten beschrieben.</p>
</blockquote>
<h4><tt><a name="data_dat"></a>data.dat</tt>
&#8211; FFT-Modus</h4>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Spalte</th>
        <th>Kurzbezeichnung</th>
        <th>Beschreibung</th>
      </tr>
      <tr>
        <td>$1</td>
        <td><var>f</var></td>
        <td>Frequenz</td>
      </tr>
      <tr>
        <td>$2</td>
        <td>|<var>U</var>|</td>
        <td>Amplitude von <var>U</var>(<var>f</var>)</td>
      </tr>
      <tr>
        <td>$3</td>
        <td>arg <var>U</var></td>
        <td>Phase von <var>U</var>(<var>f</var>)
in Grad</td>
      </tr>
      <tr>
        <td>$4</td>
        <td>|<var>I</var>|</td>
        <td>Amplitude von <var>I</var>(<var>f</var>)</td>
      </tr>
      <tr>
        <td>$5</td>
        <td>arg&nbsp;<var>I</var></td>
        <td>Phase von <var>I</var>(<var>f</var>)
in Grad</td>
      </tr>
      <tr>
        <td>$6</td>
        <td>|<var>U</var>/<var>I</var>|</td>
        <td>Amplitude der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
      </tr>
      <tr>
        <td>$7</td>
        <td>arg <var>U</var>/<var>I</var></td>
        <td>Phase der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)
in Grad</td>
      </tr>
      <tr>
        <td>$8</td>
        <td>re&nbsp;<var>U</var>/<var>I</var></td>
        <td>Realteil der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
      </tr>
      <tr>
        <td>$9</td>
        <td>im <var>U</var>/<var>I</var></td>
        <td>Imaginärteil der Impedanz <var>U</var>(<var>f</var>)/<var>I</var>(<var>f</var>)</td>
      </tr>
      <tr>
        <td>$10</td>
        <td><var>weight</var></td>
        <td>relativer Gewichtungsfaktor</td>
      </tr>
      <tr>
        <td>$11</td>
        <td><var>delay</var></td>
        <td>Gruppenlaufzeit d(<var>U</var>/<var>I</var>)/d<var>&#969;</var>,
ergibt nur für Vierpolmessungen Sinn.</td>
      </tr>
    </tbody>
  </table>
  <p>Für Vierpolmessungen ist&nbsp;<var>I</var>(<var>f</var>)
durch das Eingangssignal zu ersetzen und&nbsp;<var>U</var>(<var>f</var>)
durch das Ausgangssignal.</p>
  <p>Aus den obigen Spalten können folgende,
frequenzabhängigen Werte wie
folgt berechnet werden:</p>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Symbol</th>
        <th>Bezeichnung</th>
        <th>Formel</th>
        <th>Einheit</th>
        <th>Bemerkung</th>
      </tr>
      <tr>
        <td valign="middle"><a href="glossary.htlm#ESR"><var>ESR</var></a></td>
        <td valign="middle">Äquivalenter
Serienwiderstand</td>
        <td valign="middle">$8 · <var>R<sub>ref</sub></var></td>
        <td valign="middle">&#937;</td>
        <td valign="middle"><br>
        </td>
      </tr>
      <tr>
        <td valign="middle"><a href="glossary.html#ESC"><var>ESC</var></a></td>
        <td valign="middle">Äquivalente
Serienkapazität</td>
        <td valign="middle">
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td align="center" nowrap="nowrap">-1</td>
            </tr>
            <tr>
              <td style="border-top: 1px solid black;">2&#960;
· $1 · $9 · <var>R<sub>ref</sub></var></td>
            </tr>
          </tbody>
        </table>
        </td>
        <td valign="middle">F</td>
        <td valign="middle">nur, wenn $9 &#8804; 0</td>
      </tr>
      <tr>
        <td valign="middle"><a href="glossary.html#ESL"><var>ESL</var></a></td>
        <td valign="middle">Äquivalente
Serieninduktivität</td>
        <td valign="middle">
        <table border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td align="center" nowrap="nowrap">$9
· <var>R<sub>ref</sub></var></td>
            </tr>
            <tr>
              <td align="center">2&#960; · $1</td>
            </tr>
          </tbody>
        </table>
        </td>
        <td valign="middle">H</td>
        <td valign="middle">nur, wenn $9 &#8805; 0</td>
      </tr>
      <tr>
        <td valign="middle">|<var>Z</var>|</td>
        <td valign="middle">Betrag der Impedanz</td>
        <td valign="middle">$6 · <var>R<sub>ref</sub></var></td>
        <td valign="middle">&#937;</td>
        <td valign="middle"><br>
        </td>
      </tr>
      <tr>
        <td valign="middle"><var>Q</var></td>
        <td valign="middle">Effektive Güte</td>
        <td valign="middle">|$9| / $8</td>
        <td valign="middle"><br>
        </td>
        <td valign="middle"><br>
        </td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h4><tt><a name="gain_dat"></a>gain.dat</tt></h4>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Spalte</th>
        <th>Kurzbezeichnung</th>
        <th>Beschreibung</th>
      </tr>
      <tr>
        <td>-</td>
        <td>Zeilennummer</td>
        <td>Die Zeilen werden in der Reihenfolge der
FFT-Frequenzen geschrieben, enthalten jedoch nicht die Frequenzkennung.</td>
      </tr>
      <tr>
        <td>$1</td>
        <td><var>re</var></td>
        <td>Realteil</td>
      </tr>
      <tr>
        <td>$2</td>
        <td><var>im</var></td>
        <td>Imaginärteil</td>
      </tr>
      <tr>
        <td>$3</td>
        <td><var>abs</var></td>
        <td>Betrag</td>
      </tr>
      <tr>
        <td>$4</td>
        <td><var>arg</var></td>
        <td>Phase in Grad</td>
      </tr>
    </tbody>
  </table>
  <p>Beim Einlesen der Datei <tt>gain.dat</tt> mit
der Option <a href="#_gr"><tt>gr</tt></a>
oder <a href="#_gd"><tt>gd</tt></a>
werden nur die ersten beiden Spalten verwendet.</p>
</blockquote>
<h4><tt><a name="zero_dat"></a>zero.dat</tt></h4>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Spalte</th>
        <th>Kurzbezeichnung</th>
        <th>Beschreibung</th>
      </tr>
      <tr>
        <td>-</td>
        <td>Zeilennummer</td>
        <td>Die Zeilen werden in der Reihenfolge der
FFT-Frequenzen geschrieben, enthalten jedoch nicht die Frequenzkennung.</td>
      </tr>
      <tr>
        <td>$1</td>
        <td>re <var>c<sub>ll</sub></var></td>
        <td>Realteil Koeffizient <var>c<sub>ll</sub></var></td>
      </tr>
      <tr>
        <td>$2</td>
        <td>im&nbsp;<var>c<sub>ll</sub></var></td>
        <td>Imaginärteil Koeffizient <var>c<sub>ll</sub></var></td>
      </tr>
      <tr>
        <td>$3</td>
        <td>re <var>c<sub>lr</sub></var></td>
        <td>Realteil Koeffizient <var>c<sub>lr</sub></var></td>
      </tr>
      <tr>
        <td>$4</td>
        <td>im <var>c<sub>lr</sub></var></td>
        <td>Imaginärteil Koeffizient <var>c<sub>lr</sub></var></td>
      </tr>
      <tr>
        <td>$5</td>
        <td>re <var>c<sub>rl</sub></var></td>
        <td>Realteil Koeffizient <var>c<sub>rl</sub></var></td>
      </tr>
      <tr>
        <td>$6</td>
        <td>im <var>c<sub>rl</sub></var></td>
        <td>Imaginärteil Koeffizient <var>c<sub>rl</sub></var></td>
      </tr>
      <tr>
        <td>$7</td>
        <td>re <var>c<sub>rr</sub></var></td>
        <td>Realteil Koeffizient <var>c<sub>rr</sub></var></td>
      </tr>
      <tr>
        <td>$8</td>
        <td>im <var>c<sub>rr</sub></var></td>
        <td>Imaginärteil Koeffizient <var>c<sub>rr</sub></var></td>
      </tr>
      <tr>
        <td>$9</td>
        <td>abs&nbsp;<var>c<sub>ll</sub></var></td>
        <td>Betrag Koeffizient <var>c<sub>ll</sub></var></td>
      </tr>
      <tr>
        <td>$10</td>
        <td>arg&nbsp;<var>c<sub>ll</sub></var></td>
        <td>Phase Koeffizient <var>c<sub>ll</sub></var>
in Grad</td>
      </tr>
      <tr>
        <td>$11</td>
        <td>abs <var>c<sub>lr</sub></var></td>
        <td>Betrag Koeffizient <var>c<sub>lr</sub></var></td>
      </tr>
      <tr>
        <td>$12</td>
        <td>arg <var>c<sub>lr</sub></var></td>
        <td>Phase Koeffizient <var>c<sub>lr</sub></var>
in Grad</td>
      </tr>
      <tr>
        <td>$13</td>
        <td>abs <var>c<sub>rl</sub></var></td>
        <td>Betrag Koeffizient <var>c<sub>rl</sub></var></td>
      </tr>
      <tr>
        <td>$14</td>
        <td>arg <var>c<sub>rl</sub></var></td>
        <td>Phase Koeffizient <var>c<sub>rl</sub></var>
in Grad</td>
      </tr>
      <tr>
        <td>$15</td>
        <td>abs <var>c<sub>rr</sub></var></td>
        <td>Betrag Koeffizient <var>c<sub>rr</sub></var></td>
      </tr>
      <tr>
        <td>$16</td>
        <td>arg <var>c<sub>rr</sub></var></td>
        <td>Phase Koeffizient <var>c<sub>rr</sub></var>
in Grad</td>
      </tr>
    </tbody>
  </table>
  <p>Diese Datei enthält ein Array von
komplexen 2×2 Matrizen der Form
  <table style="display: inline; vertical-align: middle;"
 cellpadding="0" cellspacing="0" height="22" width="54">
    <tbody>
      <tr>
        <td style="border-left: 1px solid black;"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
        <td style="border-right: 1px solid black;"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
      </tr>
      <tr>
        <td style="border-left: 1px solid black;"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
        <td style="border-right: 1px solid black;"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
      </tr>
    </tbody>
  </table>
.&nbsp;Beim Einlesen der Datei über die Option <a href="#_zr"><tt>zr</tt></a>
oder <a href="#_zd"><tt>zd</tt></a>
werden nur die ersten 8 Spalten verwendet. <a
 href="analyze.html#zero_cal">&#8594;Null-Kalibrierung</a></p>
  <p>Die semantische Bedeutung der Koeffizienten ist:</p>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Koeffizient</th>
        <th>Bedeutung</th>
      </tr>
      <tr>
        <td><var>c<sub>ll</sub></var></td>
        <td>Verstärkung für Kanal 1</td>
      </tr>
      <tr>
        <td><var>c<sub>lr</sub></var></td>
        <td>Übersprechen von Kanal 2 auf Kanal 1</td>
      </tr>
      <tr>
        <td><var>c<sub>rl</sub></var></td>
        <td>Übersprechen von Kanal 1 auf Kanal 2</td>
      </tr>
      <tr>
        <td><var>c<sub>rr</sub></var></td>
        <td>Verstärkung für Kanal 2</td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h4><tt><a name="window_dat"></a>window.dat</tt></h4>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Spalte</th>
        <th>Kurzbezeichnung</th>
        <th>Beschreibung</th>
      </tr>
      <tr>
        <td>-</td>
        <td>Zeilennummer</td>
        <td>Index des Samples</td>
      </tr>
      <tr>
        <td>1</td>
        <td><var>win</var></td>
        <td>Wert der Fensterfunktion zum betreffenden Sample</td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h4><tt><a name="raw_dat"></a>raw.dat</tt></h4>
<blockquote>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
      <tr>
        <th>Spalte</th>
        <th>Kurzbezeichnung</th>
        <th>Beschreibung</th>
      </tr>
      <tr>
        <td>-</td>
        <td>Zeilennummer</td>
        <td>Index des Samples</td>
      </tr>
      <tr>
        <td>1</td>
        <td><var>L</var></td>
        <td>Wert des Samples von Kanal 1</td>
      </tr>
      <tr>
        <td>1</td>
        <td><var>R</var></td>
        <td>Wert des Samples von Kanal 2</td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h2><a name="cal"></a>Kalibrierung</h2>
<h3><a name="gain-cal"></a>Gain-Kalibrierung</h3>
<blockquote>
  <p>Bei der einfachsten Art der Kalibrierung wird mit einer
Messung lediglich der <em>Gleichlauf</em>
der beiden Kanäle korrigiert. Damit können
Torleranzen der
Soundkarten sowie bauartbedingte Phasenverschiebungen zwischen den
beiden Kanälen korrigiert werden. Das ist besonders dann
wichtig,
wenn im differentiellen <a href="#_scm">Scan-Modus</a>
(<tt>scm1</tt>) gearbeitet wird.</p>
  <h4>Durchführung</h4>
  <p>Zur Gain-Kalibrierung müssen beide Kanäle
von Line-In mit
einem der Line-Out Ausgänge verbunden werden.
Anschließend
ist mit weißem Rauschen eine Kalibrierung mit der
Kommandozeilenoption <a href="#_gg"><tt>gg</tt></a>
durchzuführen. Die FFT- und Samplingparameter müssen
dabei
mit denen bei der zu korrigierenden realen Messung
übereinstimmen.</p>
  <h4>Ergebnis</h4>
  <div class="rightbox" style="width: 371px;"><img
 src="images/GainSample.png" alt="Beispiel für Gainkorrektur"
 height="234" width="371"><br>
Beispiel für eine Gain-Korrektur: Terratec XLerate (Aureal
AU8820 Chip) bei 48kHz und einer FFT-Länge von 65536 Samples,
gemittelt über ca. 10 Zyklen.<br>
Der Amplitudenfehler ist mit &lt; 0,1dB ziemlich gut, aber die
Kanäle werden offenbar nicht exakt gleichzeitig gesampelt. Die
Verschiebung von ¼ Sample bei der Nyquistfrequenz deutet auf
eine serielle Konertierung der Kanäle sowie ein
Zweifach-Oversampling zur Verminderung von Aliasing hin. </div>
  <p>Das Resultat der Korrektur ist der komplexe,
frequenzabhängige Quotient:</p>
  <blockquote>
    <table border="0" cellpadding="0" cellspacing="0">
      <tbody>
        <tr>
          <td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>gain_korr</var>(<var>f</var>)
=&nbsp;</td>
          <td align="center" nowrap="nowrap">FFT(<var>Kanal
2</var>)</td>
        </tr>
        <tr>
          <td style="border-top: 1px solid black;">FFT(<var>Kanal
1</var>)</td>
        </tr>
      </tbody>
    </table>
  </blockquote>
  <p>Der Betrag der Korrektur ist ein
frequenzabhängiges Maß für unterschiedliche
Verstärkungsfaktoren bei den beiden Stereokanälen.
Typischerweise ist der Wert weitgehend frequenzabhängig aber
leicht verschieden von eins. Das kommt durch Bauteiltoleranzen bei den
Widerständen. Bei niedrigen Frequenzen gibt es
üblicherweise eine Größere Abweichung. Das
kommt durch Toleranzen bei den Koppelkondensatoren.</p>
  <p>Die Phase ist ein Maß für den zeitlichen
Gleichlauf der Kanäle. Typischerweise gibt es außer
der ebenfalls auf die Koppelkondensatoren
zurückzuführenden Abweichung bei niedrigen Frequenzen
hier keine Besonderheiten. Manche Soundkarten digitalisieren aber den
rechten und den linken Kanal abwechselnd mit einem gemeinsamen ADC.
Dadurch sind die Signale um ein halbes Sample zeitverschoben, was sich
in einem linearen Anstieg der Phasendifferenz mit der Frequenz
äußert.</p>
  <h4>Korrektur</h4>
  <p>Bei der Anwendung der Korrektur wird willkürlich
nur
Kanal 1 korrigiert, da die Korrektur ohnehin nur relativ ist.</p>
</blockquote>
<h3><a name="zero-cal"></a>Null-Kalibrierung</h3>
<blockquote>
  <p>Die bessere Art der Kalibrieirung für
Impedanzmessungen (2-Pol)
ist die Null-Kalibrierung. Bei dieser wird neben dem
Verstärkungsfaktoren auch noch das <em>Übersprechen</em>
mit berücksichtigt. Es handelt sich um eine <strong>Zwei-Punkt-Kalibrierung</strong>.</p>
  <p>Unter Berücksichtigung von <var>L<sub>ideal</sub></var>&nbsp;&#8733;&nbsp;<var>U</var>
und <var>R<sub>ideal</sub></var>&nbsp;&#8733;&nbsp;<var>I</var>&nbsp;·&nbsp;<var>R<sub>ref</sub></var>
ergibt sich die die reale Impedanz:</p>
  <blockquote>
    <table border="0" cellpadding="0" cellspacing="0" height="50"
 width="112">
      <tbody>
        <tr>
          <td colspan="1" rowspan="2" nowrap="nowrap" valign="middle"><var>Z</var>&nbsp;=&nbsp;</td>
          <td align="center" nowrap="nowrap"><var>L<sub>ideal</sub></var></td>
          <td colspan="1" rowspan="2" valign="middle">&nbsp;·<sup>&nbsp;</sup><var>R<sub>ref</sub></var></td>
        </tr>
        <tr>
          <td style="border-top: 1px solid black;"><var>R<sub>ideal</sub></var></td>
        </tr>
      </tbody>
    </table>
  </blockquote>
  <p>In Realität hat man es aber mit den
transformnierten
Werten&nbsp;<var>L<sub>real</sub></var> und<var></var>
  <var>R<sub>real</sub></var> zu tun.
Selbstverständlich sind alle Koeffizienten c<sub>xx</sub>
komplex und
frequenzabhängig.</p>
</blockquote>
<blockquote>
  <blockquote>
    <table border="0" cellpadding="0" cellspacing="0">
      <tbody>
        <tr>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
          <td rowspan="2" align="center" valign="middle">&nbsp;=&nbsp; </td>
          <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
          <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
          <td rowspan="2" align="center" valign="middle">&nbsp;·&nbsp;</td>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
        </tr>
        <tr>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
          <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
          <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
        </tr>
      </tbody>
    </table>
  </blockquote>
  <h4>Durchführung</h4>
  <p>Zur Null-Kalibirierung wird mit dem gesamten realen
Messequipment einmal bei <var>Z</var>&nbsp;=&nbsp;0
(<var>L<sub>ideal</sub></var>&nbsp;=&nbsp;0)
und einmal mit <var>Z&nbsp;</var>=&nbsp;&#8734;
(<var>R<sub>ideal</sub></var>&nbsp;=&nbsp;0)
gemessen, also Kurzschluss und keine Verbindung. Dabei wird neben der
Soundkarte auch das gesamte Messequipment mit kalibriert. Wenn eine
Kalibrierung mit der Option <a href="#_zg"><tt>zg</tt></a>
gestartet wird, Erwartet das Analyseprogramm zunächst einmal <a
 href="#_ln"><tt>ln</tt></a> Perioden
mit&nbsp;<var>Z</var>&nbsp;=&nbsp;0.
Anschließend kommt eine Bildschrirmausgabe nach <tt>stdout</tt>
und eine kurze Pause. In der Pause muss das Messequipment auf <var>Z&nbsp;</var>=&nbsp;&#8734;
umgestellt werden. Dann werden nochmal <a href="analyze.html#_ln"><tt>ln</tt></a>
Perioden aufgenommen, bevor das Ergebnis feststeht und der
Eingabedatenstrom <tt>stdin</tt> geschlossen wird.</p>
  <p>Theoretisch
lassen sich alle linearen Fehler ohne absolute Eichung korrigieren.
Praktisch gibt es eine Unbekannte zuviel. Man kennt weder <var>R<sub>ideal</sub></var>
bei <var>Z</var>&nbsp;=&nbsp;0 noch <var>L<sub>ideal</sub></var>
bei <var>Z&nbsp;</var>=&nbsp;&#8734;. Einer
der Unbekannten kann man sich entledigen, in dem man
willkürlich definiert det&nbsp;<i>C</i>&nbsp;=
1. Das ist
insofern erlaubt, als dass die absolute Skalierung bei der Bildung der
Quotienten&nbsp;<var>L<sub>ideal</sub></var>
/<var>&nbsp;R<sub>ideal</sub></var> keine
Rolle spielt. Eine weitere Unbekannte kann man eliminieren, wenn man
animmt, dass das Referenzsignal <var>U<sub>ref</sub></var>
bei beiden Messungen dasselbe war, und <var>R<sub>ref</sub></var>
und die Messimpedanz in Reihe geschaltet sind. Dann kann man
nähern, dass <var>U<sub>ref</sub></var>&nbsp;&#8733;&nbsp;<var>L<sub>ideal</sub></var>&nbsp;+&nbsp;<var>R<sub>ideal</sub></var>
ist (siehe Option <a href="#_zn"><tt>zn</tt></a>).
Dabei macht man einen Fehler: die zusätzlichen zu <var>R<sub>ref</sub></var>
und <var>Z</var> in Reihe geschalteten Impedanzen allen
voran die <strong>Zuleitungsinduktivitäten werden nicht
berücksichtigt</strong>.</p>
  <h4>Ergebnis</h4>
  <div class="figure"><img src="images/ZeroSample.png"
 alt="Beispiel für Gainkorrektur" height="484" width="748"><br>
Beispiel für eine Null-Korrektur: Onboard Realtek ALC650 Codec
bei 48kHz sowie der <a
 href="http://www.maazl.de/electronic/LCR/LCR-Adapter.html">gebastelte
Messadapter</a> bei 200&#937; <var>R<sub>ref</sub></var>
und einer FFT-Länge von 65536 Samples,
gemittelt über ca. 10 Zyklen.<br>
Dargestellt sind die diagonalen (links) und die nichtdiagonalen
Koeffizienten (rechts) der Transformationsmatrix jeweils in Betrag
(oben) und Phase in Grad (unten).<br>
Man erkennt ein kapazitives Übersprechen vom linken zum
rechten Kanal. Die Asymmetrie beim Übersprechen
erklärt sich durch die Asymmetrie der Innenschaltung des
Messadapter und den definitiv nicht hochfrequenztauglichen Aufbau.<br>
Der Koeffizient <i>c<sub>lr</sub></i> ist in
seiner Amplitude so klein (ca. -70dB), dass die Phase nahezu unbestimmt
ist. Daher die relativ willkürliche Verteilung der Phase. </div>
  <h4>Korrektur</h4>
  <p>Durch Inversion der Transformationsmatrix kann man die
gemessenen Werte kompensieren:</p>
  <blockquote>
    <table border="0" cellpadding="0" cellspacing="0">
      <tbody>
        <tr>
          <td colspan="4"><br>
          </td>
          <td colspan="1" rowspan="2" valign="middle">&nbsp;<sup>-1</sup></td>
          <td rowspan="1" colspan="2"><br>
          </td>
        </tr>
        <tr>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;L<sub>ideal</sub></var>&nbsp;</td>
          <td rowspan="2" align="center" valign="middle"><var>&nbsp;</var>=&nbsp;
          </td>
          <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>ll</sub>&nbsp;</var></td>
          <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>lr</sub>&nbsp;</var></td>
          <td rowspan="2" align="center" valign="middle">·&nbsp;</td>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;L<sub>real</sub></var>&nbsp;</td>
        </tr>
        <tr>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;R<sub>ideal</sub></var>&nbsp;</td>
          <td style="border-left: 1px solid black;" align="center"><var>&nbsp;c<sub>rl</sub>&nbsp;</var></td>
          <td style="border-right: 1px solid black;" align="center"><var>&nbsp;c<sub>rr</sub>&nbsp;</var></td>
          <td><br>
          </td>
          <td
 style="border-left: 1px solid black; border-right: 1px solid black;"
 align="center"><var>&nbsp;R<sub>real</sub></var>&nbsp;</td>
        </tr>
      </tbody>
    </table>
  </blockquote>
</blockquote>
<h2><a name="history"></a>Historie</h2>
<h4>Version 0.11</h4>
<ul>
  <li>Source-Verzeichnisstruktur reorganisiert.</li>
</ul>
<h4>Version 0.1</h4>
<ul>
  <li>Interne Version</li>
</ul>
<h2><a name="todo"></a>TODOs, bekante Probleme</h2>
<dl>
  <dt><b>3-Punkt-Kalibrierung</b></dt>
  <dd>Aufgrund den unzulänglichkeiten der
Zweipunkteichung ist eine 3-Punkt-Kalibrierung mit einer bekannten
Referenzimpedanz wünschenswert.</dd>
</dl>
</body>
</html>
