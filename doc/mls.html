<html>
<head>
<title>Analysetools - MLS-Generator</title>
<link href="mm.css" rel="stylesheet" type="text/css">
</head>

<body>
<a href="index.html">&rarr;&nbsp;Index</a>
<a href="glossary.html">&rarr;&nbsp;Glossar
</a>
<h1>Referenzsignalgenerator f&uuml;r MLS-Signale</h1>
<p>Release: 0.1</p>
<a href="#description">Beschreibung</a> <a href="#reference">Referenz</a> <a href="#download">Download</a> <a href="#history">Historie</a>
<a href="#todo">Todo</a>
<a href="#build">Compilieren</a>
<h2><a name="description"></a>Kurzbeschreibung</h2>
<p>Dieses Programm generiert <a href="glossary.html#MLS">MLS-Signale</a> definierter L&auml;nge mit einer parametrisierbaren Energieverteilung.</p>
<h3>Einsatzbereich</h3>
<ul>
  <li>Messung von Impedanzen oder &Uuml;bertragungsfunktionen.</li>
</ul>
<h3>Programmablauf</h3>
<blockquote>
  <p>Das Programm liefert <strong>16-Bit PCM-kodierte Daten in 2 Kan&auml;len</strong> und
    gibt sie &uuml;ber <tt><strong>stdout</strong></tt> oder in eine Datei aus.</p>
  <p>Die (plattformabh&auml;ngige) Ausgabe der PCM-Daten &uuml;ber ein DAC-Device
    muss anderw&auml;rtig gew&auml;hrleistet werden..</p>
</blockquote>
<h2><a name="options"></a>Kommandozeilenparameter</h2>
<blockquote>
  <p><kbd>mls <var>nsamp</var> <var>fmin</var> <var>fmax</var> </kbd>[<kbd><var>scale</var></kbd><kbd> </kbd>[<kbd><var>n</var> </kbd>[<kbd><var>file</var></kbd>]]]</p>
  <dl compact>
    <dt><kbd><a name="_bin"></a>bin<var>size</var></kbd></dt>
    <dd>Fasst <var><kbd>size</kbd></var> benachbarte Frequenzkan&auml;le bei der Fouriertransformation zusammen und mittelt. Mit der Methode kann man schnell mal das Rauschen etwas mindern, um zu sehen, ob man auf dem richtigen Weg ist. Als Dauerl&ouml;sung ist eine k&uuml;rzere FFT-L&auml;nge gefolgt von einer Mittelung &uuml;ber mehrere Messintervalle die bessere Methode.</dd>
    <dt><kbd><a name="_ca"></a>ca<var>num</var></kbd></dt>
    <dd>Addiert immer <var><kbd>num</kbd></var> benachbarte Samples bei der Verarbeitung der PCM-Daten. Dieses Feature kann genutzt werden, um die Samplingrate zu dr&uuml;cken und gleichzeitig das Rauschen zu mindern. Es handelt sich dabei nicht um eine geeignete Methode zum Downsampeln, sondern eher um eine Methode zur reduktion des ADC-Rauschens.<br>
    Fehlt der Parameter <var><kbd>num</kbd></var>, so werden je 2 Samples addiert und die effektive Samplingrate halbiert.</dd>
    <dt><kbd><a name="_df"></a>df<var>filename</var></kbd></dt>
    <dd>Name der Datendatei, die bei aktivierter Option <a href="#_wd"><kbd>wd</kbd></a> (regelm&auml;&szlig;ig) geschrieben wird.</dd>
    <dt><kbd><a name="_exec"></a>exec<var>command</var></kbd></dt>
    <dd>Kommando, das nach dem Wegschreiben der Daten jedesmal ausgef&uuml;hrt wird. Achtung! Das Analyseprogramm stoppt bis zur Beendung des Kommandos. Das kann bei der Echtzeitverarbeitung der Daten problematisch werden. Daher ist im allgemeinen die Synchronisation &uuml;ber <tt>stdout</tt> (Option <a href="#_plot"><kbd>plot</kbd></a>) vorzuziehen.</dd>
    <dt><kbd><a name="_famin"></a><a name="_famax"></a>famin<var>freq</var></kbd> und <kbd>famax<var>freq</var></kbd></dt>
    <dd>Minimale und maximale Frequenz, die bei der Analyse der FFT-Daten herangezogen wird. Damit kann die Analyse an die Bandbreite der verwendeten Komponenten angepasst werden. Im Gegensatz zu <a href="#_fmin"><kbd>fmin</kbd></a> und <a href="#_fmax"><kbd>fmax</kbd></a> werden dennoch alle Daten in die Datendatei geschrieben. Die Einstellung wirkt sich nur auf die am Bildschirm angezeigten Resultate aus.</dd>
    <dt><kbd><a name="_fbin"></a>fbin<var>factor</var></kbd></dt>
    <dd>Relativer Binsize Faktor. Diese Option fasst benachbarte Frequenzkan&auml;le bei der Analyse der FFT-Daten genau dann zusammen, wenn sie in das Intervall [<var>f</var>,&nbsp;<var>f</var>&nbsp;&middot;&nbsp;(<kbd><var>factor</var></kbd>&nbsp;+&nbsp;1)] passen. Diese Option ist sehr n&uuml;tzlich, wenn es in der Natur der analysierten Daten liegt, ihre Eigenschaften eher &uuml;ber log&nbsp;<var>f</var> zu &auml;ndern als mit der Frequenz <var>f</var>. Anders formuliert: wenn das Ergebnis in der Datendatei logarithmisch dargestellt werden soll, ist diese Option dringend zu empfehlen, da dann in etwa in log&nbsp;<var>f</var> &auml;quidistante St&uuml;tzpunkte entstehen.</dd>
    <dt><kbd><a name="_fmin"></a><a name="_fmax"></a>fmin<var>freq</var></kbd> und <kbd>fmax<var>freq</var></kbd></dt>
    <dd>Minimale und maximale Frequenz bei der FFT-Analyse, die &uuml;berhaupt in irgendeiner Weise bearbeitet wird. Diese Einstellung wirkt sich auf <em>alle</em> Folgeprozesse einschlie&szlig;lich der Berechnung der Kalibrierungsdaten etc. aus. Sie kann z.B. verwendet werden, um st&ouml;rende Artefakte an den Randbereichen des Frequenzspektrums aus grafischen Darstellungen zu entfernen.</dd>
    <dt><kbd><a name="_fq"></a>fq<var>freq</var></kbd></dt>
    <dd>Prim&auml;re Samplingfrequenz vor einer eventuellen Reduzierung durch <a href="#_ca">Sampleaddition</a>. Dieser Parameter <strong>sollte immer angegeben werden</strong>, da er f&uuml;r dieverse Normierungen ben&ouml;tigt wird. Unter anderem bei der Bildung zeitlicher Ableitungen.<br>
      Ohne den Parameter wird derzeit fon einer Samplingfrequenz von 44,1kHz ausgegangen. Zuk&uuml;nftige Programmversionen k&ouml;nnten dies jedoch als einen Fehler werten.</dd>
    <dt><kbd><a name="_g2f"></a>g2f<var>filename</var></kbd></dt>
    <dd>Dateiname f&uuml;r die Differenzdatei bei der Validierung der Gain-Kalibrierung. Siehe Option <a href="#_gd"><kbd>gd</kbd></a>.</dd>
    <dt><kbd><a name="_gd"></a>gd</kbd></dt>
    <dd>Validierung der <a href="#gain-cal">Gainkalibrierung</a> durchf&uuml;hren. Mit dieser Option wird eine vorhandene Gain-Kalibrierung aus der Datei <tt>gain.dat</tt> oder der mit der Option <a href="#_gf"><kbd>gf</kbd></a> angegebenen Datei angewendet und die sich danach immernoch ergebenden Gain-Abweichungen in die Datei <tt>gainD.dat</tt> oder die mit der Option <a href="#_g2f"><kbd>g2f</kbd></a> angegebene Datei geschrieben. Diese Option ist haupts&auml;chlich zur Fehlersuche hilfreich.</dd>
    <dt><kbd><a name="_gf"></a>gf</kbd></dt>
    <dd>Dateiname f&uuml;r die Gainkalibrierung. Dieser Dateiname ist f&uuml;r die Funktionen <a href="#_gr"><kbd>gg</kbd></a> und <a href="#_gr"><kbd>gr</kbd></a> relevant.</dd>
    <dt><kbd><a name="_gg"></a>gg</kbd></dt>
    <dd><a href="#gain.dat"></a><a href="#gain-cal">Gainkalibrierung</a> durchf&uuml;hren. Das Ergebnis wird in die Datei <tt>gain.dat</tt> oder der mit der Option <a href="#_gf"><kbd>gf</kbd></a> angegebenen Datei geschrieben. <a href="#gain_dat">&rarr;&nbsp;Dateiformat</a></dd>
    <dt><kbd><a name="_gr"></a>gr</kbd></dt>
    <dd><a href="#gain-cal">Gainkalibrierung</a> aus einer fr&uuml;heren Kalibrierungsmessung verwenden. Die Daten werden aus der Datei <tt>gain.dat</tt> oder der mit der Option <a href="#_gf"><kbd>gf</kbd></a> angegebenen Datei gelesen. <a href="#gain.dat">&rarr;&nbsp;Dateiformat</a></dd>
    <dt><kbd><a name="_h_f"></a>h/f</kbd></dt>
    <dd>Automatische Gewichtungsfunktion bei der Analyse der FFT-Daten durch eine 1/<var>f</var>-Gewichtung ersetzen.</dd>
    <dt><kbd><a name="_hd"></a>hd</kbd></dt>
    <dd>Automatische Gewichtungsfunktion f&uuml;r den differenziellen Scanmodus <a href="#_scm"><kbd>scm1</kbd></a> aktivieren.</dd>
    <dt><kbd><a name="_he"></a>he</kbd></dt>
    <dd>Gewichtung der Messpunkte bei der Analyse der FFT-Daten deaktivieren.</dd>
    <dt><kbd><a name="_in"></a>in<var>filename</var></kbd></dt>
    <dd>PCM-Daten aus <var><kbd>filename</kbd></var> lesen (anstelle von <tt>stdin</tt>). Der angegebene Name kann auch ein transienter Datenstrom, wie z.B. eine Pipe oder ein Device sein.</dd>
    <dt><kbd><a name="_ln"></a>ln<var>num</var></kbd></dt>
    <dd><kbd><var>num</var></kbd> Einzelanalysen in Folge durchf&uuml;hren und das Programm danach beenden. Standardm&auml;&szlig;ig wird nur exakt ein Durchlauf ausgef&uuml;hrt.</dd>
    <dt><kbd><a name="_loop"></a>loop</kbd></dt>
    <dd>Endlosmodus. Das Programm kann nur durch ein Ende der Eingabedaten oder einer Abbruch gestoppt werden. Bei der Verwendung des Endlosmodus zur Echtzeitverarbeitung transienter Eingabedaten sollte man vorher mit einer endlichen Zahl an Schleifendurchl&auml;ufen (Option <a href="#_ln"><kbd>ln</kbd></a>) getestet haben, ob die Verarbeitung in Echtzeit mit den angegebenen Optionen &uuml;berhaupt mit unter 100% Systemlast m&ouml;glich ist.</dd>
    <dt><kbd><a name="_lp"></a>lp<var>num</var></kbd></dt>
    <dd>Anzahl der zu verwerfenden Datenbl&ouml;cke in der Pause der <a href="#zero-cal">Nullwert-Kalibrierung</a> (Option <kbd><a href="#_zg">zg</a></kbd>).</dd>
    <dt><kbd><a name="_lvl"></a>lvl<var>level</var></kbd></dt>
    <dd>St&ouml;rpegel f&uuml;r die automatische Gewichtung der Messpunkte bei der FFT-Analyse. Messpunkte mit Amplituden unterhalb dieses St&ouml;rpegels werden gar nicht verwendet.</dd>
    <dt><kbd><a name="_mfft"></a>mfft</kbd></dt>
    <dd>Messmodus <a href="#mfft">FFT-Analyse</a> verwenden.</dd>
    <dt><kbd><a name="_mpca" id="_mpca"></a>mpca</kbd></dt>
    <dd>Messmodus <a href="#mpca">PCA-Analyse</a> verwenden.</dd>
    <dt><kbd><a name="_mfft"></a>mxy</kbd></dt>
    <dd><a href="#mxy">Kennlinienmodus</a> verwenden.</dd>
    <dt><kbd><a name="_n"></a>n<var>num</var></kbd></dt>
    <dd>L&auml;nge der Datenbl&ouml;cke f&uuml;r alle Messmodi auf <var><kbd>num</kbd></var> festlegen. (FFT-L&auml;nge, Samples pro PCA-Analyse, Samples pro Kennlinie). Diese Zahl ist nach einer eventuellen Zusammenfassung von Samples durch die Option <a href="#_ca"><kbd>ca</kbd></a> zu verstehen.<br>
      Ohne die Option <kbd>n</kbd> wird eine Standardl&auml;nge von 8192 Samples verwendet.</dd>
    <dt><kbd><a name="_pdc"></a>pdc<var>num</var></kbd></dt>
    <dd>Die ersten num Frequenzkan&auml;le bei der FFT-Analyse ausnullen. Diese Option kann alternativ zu <a href="#_fmin"><kbd>fmin</kbd></a> verwendet werden, um zu verhindern, dass nicht relevante DC-Offsets die automatische Achsenskalierung einer Grafik negativ beeinflussen. Im Gegensatz zu <kbd>fmin</kbd> werden die Zeilen dennoch in die Ergebnisdateien geschrieben und uninitialisierte Werte in den Kalibrierungsdateien vermieden. Das kann jedoch nach hinten losgehen, wenn sich einer dieser Werte im Nenner einer Folgekalkulation wiederfindet (z.B. der Strom bei der Impedanzberechnung). Deshalb wird sicherheitshalber auch nicht 0, sondern nur ein sehr kleiner Wert verwendet.</dd>
    <dt><kbd><a name="_plot" id="_plot"></a>plot<var>command</var></kbd></dt>
    <dd>Kommando nach jedem Analyseergebnis &uuml;ber <tt>stdout</tt> als eigene Zeile ausgeben. Dies kann z.B. verwendet werden, um eine grafische Visualisierung z.B. durch Gnuplot in Echtzeit zu aktualisieren.</dd>
    <dt><kbd><a name="_psa"></a>psa<var>num</var></kbd></dt>
    <dd>Die ersten <kbd><var>num</var></kbd> Samples verwerfen. Dies kann benutzt werden, um nach dem Start einer Messung auf einen eingeschwungenen Zustand zu warten, aber auch, um eventuelle Header-Daten in einem PCM-Datenstrom zu &uuml;berspringen (z.B. <kbd>pca11</kbd> f&uuml;r <tt>.WAV</tt>-Dateien).</dd>
    <dt><kbd><a name="_pte"></a>pte</kbd></dt>
    <dd>Nach Beedigung der angegebenen Anzahl an Analyse-Durchl&auml;ufen (Option <a href="#_ln"><kbd>ln</kbd></a>) weiterhin Daten lesen, diese jedoch verwerfen. Dies kann n&uuml;tzlich sein, wenn Echtzeit-Datenquellen allergisch reagieren, wenn sie ihren Daten nicht mehr los werden und auf anderem Wege gestoppt werden m&uuml;ssen. Das verhindert letztlich auch das Programmende, solange noch Eingabedaten kommen. Wenn der Eingabedatenstrom abbricht, wird das Programm dann beendet.</dd>
    <dt><kbd><a name="_rref"></a>rref<var>res</var></kbd></dt>
    <dd>Referenzwiderstand <var><kbd>res</kbd></var> bei der Analyse von Impedanzdaten ber&uuml;cksichtigen. Standardm&auml;&szlig;ig wird ein Wert von 1.0 verwendet. Das ist auch dann zu verwenden, wenn die Umrechnung bereits an anderer Stelle bei der Datenaufbereitung erfolgt.</dd>
    <dt><kbd><a name="_scm"></a>scm0</kbd>, <kbd>scm1</kbd> oder <kbd>scm2</kbd></dt>
    <dd>Modus bei der Entgegennahme der PCM-Daten:<br>
    <kbd>scm0</kbd> &ndash; PCM-Reihenfolge: Kanal&nbsp;1 = <var>U</var>(<var>t</var>), Kanal&nbsp;2 = <var>I</var>(<var>t</var>)<br>
    <kbd>scm1</kbd> &ndash; Differenzmodus: <var>U</var>(<var>t</var>) = Kanal 1, <var>I</var>(<var>t</var>) = Kanal&nbsp;2 &minus; Kanal&nbsp;1<br>
    <kbd>scm2</kbd> &ndash;Kan&auml;le vertauschen: Kanal&nbsp;1 = <var>I</var>(<var>t</var>), Kanal&nbsp;2 = <var>U</var>(<var>t</var>)<br>
    Der Differenzmodus ist Prkatisch, weil er sehr einfache Impedanzmessungen durch die Reihenschaltung eines Referenzwiderstandes mit der zu messenden Impedanz ohne Instrumentenverst&auml;rker erlaubt. Allerding reagiert dieser Modus aufgrund der Differenzbildung von &auml;hnlich gro&szlig;en Zahlen auch sehr allergisch auf kleinste Assymetrieen zwischen den beiden Kan&auml;len.</dd>
    <dt><kbd><a name="_wd"></a>wd</kbd></dt>
    <dd>Ausf&uuml;hrliche Ergebnisse nach Abschluss (je)der Analyse in die Datei <tt>data.dat</tt> oder die mit der Option <a href="#_df"><kbd>df</kbd></a> angegebene Datei schreiben. <a href="#data_dat">&rarr;&nbsp;Dateiformat</a></dd>
    <dt><kbd><a name="_wf"></a>wf<var>filename</var></kbd></dt>
    <dd>Dateiname f&uuml;r die Ausgabe der Fensterfunktion (Option <a href="#_ww"><kbd>ww</kbd></a>).</dd>
    <dt><kbd><a name="_win"></a>win<var>typ</var></kbd></dt>
    <dd>Festerfunktion vor der FFT-Analyse verwenden. Derzeit gibt sind folgende Fensterfunktionen implementiert:<br>
    win0 &ndash;Rechteckfenster = keine Fensterfunktion<br>
    win1 &ndash;Bartlett-Fenster = Dreieck-Fenster, abs(2&nbsp;<var>i</var>/<var>n&nbsp;</var>&minus;&nbsp;1)<br>
    win2 &ndash;Hanning-Fenster, .5&nbsp;&minus;&nbsp;.5&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
    win3 &ndash;Hamming-Fenster, .54&nbsp;&minus;&nbsp;.46&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
    win4 &ndash;Blackman-Fenster, .42&nbsp;&minus;&nbsp;.5&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>) +&nbsp;.08&nbsp;cos(4&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
    win5 &ndash;Blackman-Harris-Fenster, .35875&nbsp;&minus;&nbsp;.48829&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>) +&nbsp;.14128&nbsp;cos(4&pi;&nbsp;<var>i</var>/<var>n</var>) &minus;&nbsp;.01168&nbsp;cos(2&pi;&nbsp;<var>i</var>/<var>n</var>)<br>
    Fehlt die Angabe
    <var>    <kbd>typ</kbd></var>, so wird ein Hanning-Fenster verwendet. Das ist i.A. ein brauchbarer Kompromiss zwischen Trennsch&auml;rfe und St&ouml;rpegel.</dd>
    <dt><kbd><a name="_wr"></a>wr</kbd></dt>
    <dd>Rohdaten in die Datei <tt>raw.dat</tt> oder die mit der Option <a href="#_rf"><kbd>rf</kbd></a> angegebene Datei schreiben. Das sind die Daten, wie sie aus dem Eingabedatenstrom kommen. Die Option ist normalerweise nur zur Fehlersuche gedacht. <a href="#raw_dat">&rarr;&nbsp;Dateiformat</a></dd>
    <dt><kbd><a name="_ww"></a>ww</kbd></dt>
    <dd>Fensterfunktion Schreiben. Mit dieser Option wird die mit der Option <a href="#_win"><kbd>win</kbd></a> ausgew&auml;hlte Fensterfunktion in die date <tt>window.dat</tt> oder die mit der Option <a href="#_wf"><kbd>wf</kbd></a> angegebene Datei geschrieben. <a href="#window_dat">&rarr;&nbsp;Dateiformat</a></dd>
    <dt><kbd><a name="_z2f" id="_z2f"></a>z2f<var>filename</var></kbd></dt>
    <dd>Dateiname f&uuml;r die Differenzdatei bei der Validierung der Null-Kalibrierung. Siehe Option <a href="#_zd"><kbd>zd</kbd></a>.</dd>
    <dt><kbd><a name="_zd" id="_zd"></a>zd</kbd></dt>
    <dd>Validierung der <a href="#gain-cal">Null-Kalibrierung</a> durchf&uuml;hren. Mit dieser Option wird eine vorhandene Null-Kalibrierung aus der Datei <tt>zero.dat</tt> oder der mit der Option <a href="#_zf"><kbd>zf</kbd></a> angegebenen Datei angewendet und die sich danach immernoch ergebenden Nullwert-Abweichungen in die Datei <tt>zeroD.dat</tt> oder die mit der Option <a href="#_z2f"><kbd>z2f</kbd></a> angegebene Datei geschrieben. Diese Option ist haupts&auml;chlich zur Fehlersuche hilfreich.</dd>
    <dt><kbd><a name="_zf"></a>zf</kbd></dt>
    <dd>Dateiname f&uuml;r die Gainkalibrierung. Dieser Dateiname ist f&uuml;r die Funktionen <a href="#_zr"><kbd>zg</kbd></a> und <a href="#_zr"><kbd>zr</kbd></a> relevant.</dd>
    <dt><kbd><a name="_zg"></a>zg</kbd></dt>
    <dd><a href="#zero.dat"></a><a href="#zero-cal">Null-Kalibrierung</a> durchf&uuml;hren. Das Ergebnis wird in die Datei <tt>zero.dat</tt> oder der mit der Option <a href="#_zf"><kbd>zf</kbd></a> angegebenen Datei geschrieben.</dd>
    <dt><kbd><a name="_zn"></a>zn</kbd></dt>
    <dd>Amplituden normalisieren. Dabei wird die Summe der komplexen Amplituden von Kanal 1 und Kanal 2 f&uuml;r alle Frequenzkan&auml;le einzeln vor der Weiterverarbeitung  auf konstant 1 normiert. Dies hat bei Impedanzmessungen zun&auml;chst einmal keine Auswirkung, da nur die relativen, komplexen Amplituden (<var>U</var>(<var>f</var>)&nbsp;/<var>&nbsp;I</var>(<var>f</var>)) verwendet werden. Sollen jedoch die Ergebnisse verschiedener Messungen direkt ins Verh&auml;ltnis gesetzt werden, wie es bei der Null-Kalibrierung der Fall ist, bekommt diese Option durchaus Relevanz, da nun auch Daten ins Verh&auml;ltnis gesetzt werden k&ouml;nnen, bei denen das Referenzsignal aus technischen Gr&uuml;nden nicht exakt &uuml;bereinstimmt.</dd>
    <dt><kbd><a name="_zr"></a>zr</kbd></dt>
    <dd><a href="#zero-cal">Null-Kalibrierung</a> aus einer fr&uuml;heren Kalibrierungsmessung verwenden. Die Daten werden aus der Datei <tt>zero.dat</tt> oder der mit der Option <a href="#_gf"><kbd>zf</kbd></a> angegebenen Datei gelesen. <a href="#gain_dat">&rarr;&nbsp;Dateiformat</a></dd>
    <dt><kbd></kbd></dt>
  </dl>
</blockquote>
<h3><a name="examples"></a>Beispiele</h3>
<blockquote>
  <p>k</p>
</blockquote>
<h2><a name="method"></a>Arbeitsweise</h2>
<blockquote>
  <p>Das Programm erzeugt das MLS per inverser, diskreter Fourier-Transformation.
    Dabei werden die Amplituden der einzelnen Koeffizienten nach folgender Formel
    berechnet:</p>
  <blockquote>
    <p><var>r<font size="-1"><sub>i</sub></font></var> = <var>f<font size="-1"><sub>i</sub><sup>k</sup></font></var></p>
  </blockquote>
  <p>Die Phasen dazu werden zuf&auml;llig gew&auml;hlt.</p>
  <p>Alle Koeffizienten, die nicht im Frequenzintervall [<var>f<font size="-1"><sub>min</sub></font></var>,
    <var>f<font size="-1"><sub>max</sub></font></var>] liegen, werden genullt.</p>
  <p>Nach der R&uuml;cktransformation wird das Signal noch normalisiert bevor es ausgegeben
    wird.</p>
</blockquote>
<h2><a name="download"></a>Download</h2>
<blockquote>
  <p>This program is distributed under the terms of the <a href="gpl.txt"><i>GNU GENERAL PUBLIC LICENSE</i></a>.</p>
  <p> ZIP file with source, <strong>OS/2</strong> binary and this guide: <a href="analyze.zip">Version&nbsp;0.1</a></p>
  <p>The OS/2 binary requires the gcc runtime <a href="../libc06b2.zip"><tt>
    <!-- TODO: Link -->libc06b4.dll</tt></a> to execute (LGPL).</p>
</blockquote>
<h2><a name="history"></a>Historie</h2>
<h4>Version 0.11</h4>
<ul>
  <li>Hysterese-Modus hinzugef&uuml;gt.</li>
  <li>Verzeichnisstruktur reorganisiert.</li>
</ul>
<h4>Version 0.1</h4>
<ul>
  <li>Interne Version</li>
</ul>
<hr>
<a name="todo">
<h2>TODOs, bekante Probleme</h2>
<dl>
  <dt><b>Create correct CRC fields</b></dt>
  <dd>Currently the (optional) CRC fileds of the MPEG frames are neither updated nor checked.</dd>
  <dt><strong>Fix the MP3 bit reservoir after cutting</strong></dt>
  <dd>Layer III files spreads the main data over frames in the past. This causes dead references when a file is cut at a frame boundary.
    This shoul be fixed when splitting.</dd>
  <dt><b>The bit reservoir checking seems to trigger on each frame of some MP3 files.</b></dt>
  <dd>So far, I don't know wether this is a bug or the files are really broken due to a bug in an MP3 encoder.</dd>
</dl>
</a>
<hr>
<h2><a name="build"></a>Programm compilieren</h2>
<p>Normalerweise wie &uuml;blich: <kbd>cd src</kbd>, <kbd>make</kbd>... - aber faktisch ist das Makefile f&uuml;r OS/2 gcc Version 3.3 geschrieben und enth&auml;lt zudem den Pfad zur rfftw-Library. Kurzum, da ist Feintuning erforderlich. Eine Anpassung der Pfade und Compiler-Optionen sollte aber im allgemeinen hinreichend sein. Wenn alles passt, werden beim Aufruf von make im Verzeichnis <tt>bin</tt> alle ausf&uuml;hrbaren Dateien erstellt.</p>
</body>
</html>
