<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Analyze: Configuration parameters</title>
    <link href="mm.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=MML_HTMLorMML">
    </script>
    <h1>Analyze: Configuration parameters</h1>
    <div class="index"><a href="index.html">△</a><a href="index.html"> Index</a> <span class="current">▼ Parameters</span> <a href="calibration.html">▷
        Calibration</a> <a href="fileformat.html">▷ File formats</a> <a href="index.html#download">&rarr; Download</a> <a href="#history">&rarr;
        History</a> <a href="#todo">&rarr; Todo</a> <a href="index.html#build">&rarr; Build</a><br>
      <a href="#syntax">▾ Syntax</a> <a href="#list">▾ Alphabetic list</a> <a href="#general">▾ General options</a> <a href="#input">▾
        Input options</a> <a href="#output">▾ Output options</a> <a href="#control">▾ Control options</a> <a href="#FFT">▾ FFT
        parameter</a> <a href="#calibrate">▾ Calibration options</a></div>
    <a href="index.html#build"> </a>
    <h2 class="index"><a name="syntax"></a>General syntax</h2>
    <blockquote>
      <pre><var>key</var>=<var>value</var>
<var>key</var>
<var>key</var>=
@<var>includefile</var>
#<var>comment</var></pre>
    </blockquote>
    <p>All arguments follow basically a key value syntax. The value might be completely omitted (including the equals sign). In this
      case a parameter specific default value is assigned, e.g. boolean options usually assign the <tt>true</tt> value by default.
      But if the argument ends with <tt>=</tt> then an empty value is assigned. This might not be valid for all data types.</p>
    <ul>
      <li>
        <p>There is always <em>exactly one parameter per command line argument</em> or per line in an included file.</p>
      </li>
      <li>
        <p>If an argument <em>starts with <tt>@</tt></em> then this is an <em>include directive</em>. In this case all lines in
          the specified file are treated as parameters. Included files may include further files.</p>
      </li>
      <li>
        <p>Arguments or <em>lines starting with <tt>#</tt> are ignored</em>.</p>
      </li>
    </ul>
    <h3>Data types</h3>
    <dl>
      <dt><b>boolean</b></dt>
      <dd>Boolean parameters accept the values <b><tt>1</tt>, <tt>true</tt>, <tt>yes</tt> or <tt>on</tt> as true</b> and the
        values <b><tt>0</tt>, <tt>false</tt>, <tt>no</tt> or <tt>off</tt> as false</b>. Additionally the value <tt>toggle</tt>
        might be uses to change the current state.<br>
        If the value is omitted <tt>true</tt> is assumed.</dd>
      <dt><b>integer</b></dt>
      <dd>Integer parameters accept <b>non-negative whole numbers</b>. Depending on the parameter it may accept only a smaller
        domain.<br>
        Numbers starting with a leading <tt>0</tt> are octal, numbers starting with <tt>0x</tt> hexadecimal. Powers of 2 can be
        entered with a trailing <tt>^</tt>, e.g. <tt>^12</tt> = 2<sup>12</sup> = 4096.</dd>
      <dt><b>floating point</b></dt>
      <dd>Floating point parameters accept fractional and/or negative numbers and also decimal exponents but no thousands separator.
        Again the individual parameter might restrict the domain.</dd>
      <dt><b>string</b></dt>
      <dd>String parameters accept any <b>single line string</b>, but there is a length restriction of 1kB. Leading or trailing
        blanks are kept.<br>
        Note that the syntax <tt><var>key</var>=</tt> will assign an empty string while just <var><tt>key</tt></var> will assign a
        null value or the default for this parameter.</dd>
      <dt><b>constants</b></dt>
      <dd>Constants do not accept any value, they just assign a constant value. E.g. the option <tt>loop</tt> assigns <tt>0</tt>
        to the parameter <tt>ln</tt>.</dd>
    </dl>
    <h2><a name="list"></a>Alphabetic list</h2>
    <table cellspacing="0" cellpadding="3" border="1">
      <tbody>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Default</th>
          <th>Category</th>
        </tr>
        <tr>
          <td><a href="#_ainc"><tt>ainc</tt></a></td>
          <td>incremental mode<br>
          </td>
          <td>off</td>
          <td><a href="#input">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_al"><tt>al</tt></a></td>
          <td>average over multiple cycles of samples<br>
          </td>
          <td><tt>1</tt> (off)<tt> </tt></td>
          <td><a href="#input">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_aref"><span style="font-family: monospace;">aref</span></a></td>
          <td>append reference data file (instead of overwriting)<br>
          </td>
          <td>overwrite<br>
          </td>
          <td><a href="#output">output data</a> </td>
        </tr>
        <tr>
          <td><a href="#_bin"><tt>bin</tt></a></td>
          <td>average FFT channels<br>
          </td>
          <td><tt>1</tt> (off)</td>
          <td><a href="#FFT">FFT parameter</a></td>
        </tr>
        <tr>
          <td><a href="#_dcfg"><tt>dcfg</tt></a></td>
          <td>dump effective configuration to a file</td>
          <td><br>
          </td>
          <td><a href="#general">general options</a></td>
        </tr>
        <tr>
          <td><a href="#_diff"><span style="font-family: monospace;">diff</span></a></td>
          <td>use differential input mode</td>
          <td>off</td>
          <td><a href="#input">input data</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_famin">famin</a> <a href="#_famax">famax</a></tt></td>
          <td>frequency range for LCR analysis</td>
          <td><a href="#_fmin"><tt>fmin</tt></a> .. <a href="#_fmax"><tt>fmax</tt></a></td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_fbin"><tt>fbin</tt></a></td>
          <td>average FFT channels with logarithmic bandwidth<br>
          </td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_ff32"><span style="font-family: monospace;">ff32</span></a></td>
          <td>read/write floating point samples</td>
          <td><br>
          </td>
          <td><a href="#general">general options</a><a href="#input"></a></td>
        </tr>
        <tr>
          <td><a href="#_fftlen"><tt>fftlen</tt></a></td>
          <td>analysis block size</td>
          <td><tt>8192</tt></td>
          <td><a href="#general">general options</a></td>
        </tr>
        <tr>
          <td><a href="#_fi16"><span style="font-family: monospace;">fi16</span></a></td>
          <td>read/write 16 bit integer samples</td>
          <td>default</td>
          <td><a href="#general">general options</a><a href="#input"></a></td>
        </tr>
        <tr>
          <td><a href="#_finc"><tt>finc</tt></a></td>
          <td>linear increment for used FFT channels<br>
          </td>
          <td><tt>1.0</tt></td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_flog"><tt>flog</tt></a></td>
          <td>logarithmic increment for used FFT channels</td>
          <td><tt>1.0</tt> (off)</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><tt><a href="#_fmin">fmin</a> <a href="#_fmax">fmax</a></tt></td>
          <td>frequency range for analysis<br>
          </td>
          <td><tt>0.001</tt> .. Nyquist frequency</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_fsamp"><tt>fsamp</tt></a></td>
          <td>sampling frequency</td>
          <td><tt>48000</tt></td>
          <td><a href="#general">general options</a><a href="#input"></a></td>
        </tr>
        <tr>
          <td><a href="#_gain"><tt>gain</tt></a></td>
          <td>master gain for reference output in dB FSR</td>
          <td><tt>0.0</tt></td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><a href="#_gg"><tt>gg</tt></a></td>
          <td>generate <a href="#gain-cal">gain calibration</a> file</td>
          <td><br>
          </td>
          <td><a href="#calibrate">calibration</a></td>
        </tr>
        <tr>
          <td><a href="#_gr"><tt>gr</tt></a></td>
          <td>use <a href="#gain-cal">gain calibration</a> file</td>
          <td><br>
          </td>
          <td><a href="#calibrate">calibration</a><a href="#calibrate_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_h_f"><tt>h/f</tt></a></td>
          <td>use 1/<var>f</var> weight<br>
          </td>
          <td><br>
          </td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_harm"><tt>harm</tt></a></td>
          <td>take harmonics into account<br>
          </td>
          <td><tt>1</tt> (off)</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_hd"><tt>hd</tt></a></td>
          <td>use weight function for differential <a href="#_scm">input mode</a></td>
          <td><br>
          </td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_he"><tt>he</tt></a></td>
          <td>disable weight function<br>
          </td>
          <td><br>
          </td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><tt>help</tt></td>
          <td>show help screen with options</td>
          <td><br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td><a href="#_in"><tt>in</tt></a></td>
          <td>name of PCM input file, <tt>-</tt> for <tt>stdin</tt></td>
          <td><span style="font-family: monospace;"></span><br>
          </td>
          <td><a href="#input">input data</a></td>
        </tr>
        <tr>
          <td><a href="#_initcmd"><tt>initcmd</tt></a></td>
          <td>execute shell command before the main analysis<br>
          </td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_initout"><tt>initout</tt></a></td>
          <td>write command to <span style="font-family: monospace;">stdout</span> before the main analysis</td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a><a href="#control_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_ln"><tt>ln</tt></a></td>
          <td>number of cycles to process</td>
          <td><tt>1</tt></td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_loop"><tt>loop</tt></a></td>
          <td>infinite number of cycles</td>
          <td>off</td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_lp"><tt>lp</tt></a></td>
          <td>pause in seconds between measurements (at <a href="#matrix-cal">matrix calibration</a>)<a href="#matrix-cal"> </a></td>
          <td><tt>10</tt></td>
          <td><a href="#calibrate">calibration</a><a href="#calibrate_options"></a></td>
        </tr>
        <tr>
          <td><tt><a href="#_mfft">mfft</a> <a href="#_mpca">mpca</a></tt></td>
          <td>operation mode<br>
          </td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a><a href="#control_options"></a><a href="#control_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_msweep"><tt>msweep</tt></a></td>
          <td>use <a href="measure.html#sweep">sweep mode</a></td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_olf">olf</a> <a href="#_olc">olc</a></tt></td>
          <td>file name and column to overwrite numerator<br>
          </td>
          <td>none / <tt>1</tt></td>
          <td><a href="#input">input data</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_orf">orf</a> <a href="#_orc">orc</a></tt></td>
          <td>file name and column to overwrite denominator (reference)<br>
          </td>
          <td>none / <tt>1</tt></td>
          <td><a href="#input">input data</a><a href="#input_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_out"><tt>out</tt></a></td>
          <td>name of PCM data file to write reference signal to</td>
          <td><br>
          </td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><a href="#_pch"><tt>pch</tt></a></td>
          <td>purge first frequency channels</td>
          <td><tt>1</tt> (purge DC)<tt> </tt></td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_phcc"><tt>phcc</tt></a></td>
          <td>fit group delay<br>
          </td>
          <td>off<br>
          </td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_phl"><tt>phl</tt></a></td>
          <td>subtract constant group delay</td>
          <td><tt>0.0</tt> (off)</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_plotcmd"><tt>plotcmd</tt></a></td>
          <td>execute shell command after new data is available<br>
          </td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_plotout"><tt>plotout</tt></a></td>
          <td>write command to <span style="font-family: monospace;">stdout</span> after new data available</td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a><a href="#control_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_postcmd"><tt>postcmd</tt></a></td>
          <td>execute shell command after all analysis has completed<br>
          </td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_postout"><tt>postout</tt></a></td>
          <td>write command to <span style="font-family: monospace;">stdout</span> after all analysis has completed</td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a><a href="#control_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_predelay"><tt>predelay</tt></a></td>
          <td>time to setup in FFT cycles</td>
          <td><tt>0.95</tt></td>
          <td><a href="#synchronize">synchronization options</a><a href="#input"></a><a href="#synchronize"></a></td>
        </tr>
        <tr>
          <td><a href="#_psa"><tt>psa</tt></a></td>
          <td>discard first input samples<br>
          </td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#input">input data</a><a href="#input_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_pte"><tt>pte</tt></a></td>
          <td>read input data till the end<br>
          </td>
          <td>off</td>
          <td><a href="#input">input data</a><a href="#input_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_rref"><tt>rref</tt></a></td>
          <td>reference resistor<br>
          </td>
          <td><tt>1.0</tt></td>
          <td><a href="#general">general options</a><a href="#param_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_rspec"><tt>rspec</tt></a></td>
          <td>read frequency domain reference data from file</td>
          <td><br>
          </td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><a href="#_scale"><tt>scale</tt></a></td>
          <td>noise type, <a href="noise.html#method">energy distribution</a></td>
          <td><tt>0</tt> (white noise)</td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><a href="#_setupcmd"><tt>setupcmd</tt></a></td>
          <td>execute shell command at program start<br>
          </td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a></td>
        </tr>
        <tr>
          <td><a href="#_setupout"><tt>setupout</tt></a></td>
          <td>write command to <span style="font-family: monospace;">stdout</span> at program start</td>
          <td><br>
          </td>
          <td><a href="#control_options">control options</a><a href="#control_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_stereo"><tt>stereo</tt></a></td>
          <td>two channel mode</td>
          <td>off</td>
          <td><a href="#control_options">control options</a><a href="#general"></a></td>
        </tr>
        <tr>
          <td><a href="#_symmout"><tt>symmout</tt></a></td>
          <td>symmetric stereo output</td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><a href="#_sync"><tt>sync</tt></a></td>
          <td>synchronize before start</td>
          <td><tt>0</tt> (off)</td>
          <td><a href="#synchronize">synchronization options</a></td>
        </tr>
        <tr>
          <td><a href="#_syncmod"><tt>syncmod</tt></a></td>
          <td>modulation of synchronization signal</td>
          <td><tt>0.0</tt> (off)</td>
          <td><a href="#synchronize">synchronization options</a></td>
        </tr>
        <tr>
          <td><a href="#_synclvl"><tt>synclvl</tt></a></td>
          <td>minimum cross correlation SNR</td>
          <td><tt>0.2</tt></td>
          <td><a href="#synchronize">synchronization options</a></td>
        </tr>
        <tr>
          <td><a href="#_wd"><tt>wd</tt></a></td>
          <td>(over)write FFT data file on the fly<br>
          </td>
          <td>off</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_win"><tt>win</tt></a></td>
          <td>select window function</td>
          <td>off (rectangular)<br>
          </td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_wraw"><tt>wraw</tt></a></td>
          <td>write raw data</td>
          <td>off</td>
          <td><a href="#input">input data</a><a href="#input_options"></a></td>
        </tr>
        <tr>
          <td><tt><a href="#_wref">wref</a></tt></td>
          <td>write time domain reference to file</td>
          <td><br>
          </td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><tt><a href="#_wspec">wspec</a></tt></td>
          <td>write frequency domain reference to file</td>
          <td><br>
          </td>
          <td><a href="#output">output data</a></td>
        </tr>
        <tr>
          <td><a href="#_wwin"><tt>wwin</tt></a></td>
          <td>write window function</td>
          <td>off</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_xch"><span style="font-family: monospace;">xch</span></a></td>
          <td>swap input channels (L &harr; R)</td>
          <td>off</td>
          <td><a href="#input">input data</a><a href="#input_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_xb"><span style="font-family: monospace;">xb</span></a></td>
          <td>swap bytes of PCM data (change endianess)</td>
          <td>off</td>
          <td><a href="#general">general options</a><a href="#input"></a><a href="#input_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_zg"><tt>zg</tt></a></td>
          <td>generate <a href="#matrix-cal">matrix calibration</a> file</td>
          <td>off</td>
          <td><a href="#calibrate">calibration</a><a href="#calibrate_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_zn"><tt>zn</tt></a></td>
          <td>normalize amplitudes</td>
          <td>off</td>
          <td><a href="#FFT">FFT parameter</a><a href="#fft_options"></a></td>
        </tr>
        <tr>
          <td><a href="#_zr"><tt>zr</tt></a></td>
          <td>use <a href="#matrix-cal">matrix calibration</a> file</td>
          <td>off</td>
          <td><a href="#calibrate">calibration</a><a href="#calibrate_options"></a></td>
        </tr>
      </tbody>
    </table>
    <h2><a name="general"></a>General options </h2>
    <dl compact="compact">
      <dt><tt><a name="_fsamp"></a><b>fsamp</b>=<var>freq</var></tt> - sampling frequency of input data<tt><var> </var></tt></dt>
      <dd>This parameter should always be specified unless it is the default value of 48&nbsp;kHz. <tt>analyze</tt> cannot read
        headers of PCM data files.</dd>
      <dt><tt><a name="_ff32"></a><b>ff32</b></tt> - read/write floating point samples</dt>
      <dd>Read input (option <a href="#_in"><tt>in</tt></a>) and write output (option <a href="#_out"><tt>out</tt></a>) samples in
        32 bit floating point format (rather than 16 bit integer).</dd>
      <dt><tt><a name="_fi16"></a><b>fi16</b></tt> - read/write integer samples</dt>
      <dd>Read input (option <a href="#_in"><tt>in</tt></a>) and write output (option <a href="#_out"><tt>out</tt></a>) as 16 bit
        signed integers (default) in the platform's native byte order (unless <a href="#_xb"><tt>xb</tt></a> is used).</dd>
      <dt><tt><a name="_xb"></a><b>xb</b></tt> - swap bytes of PCM data</dt>
      <dd>Change endianess of PCM input and output data.</dd>
      <dt><tt><a name="_fftlen"></a><b>fftlen</b>=<var>num</var></tt> - analysis block length </dt>
      <dd>Number of samples for one analysis cycle. This is also the length of the FFT. It is strongly recommended to use a power of
        2 if you activated the <a href="#_mfft">FFT mode</a>. The number of samples here counts after an options averaging with
        option <a href="#_ca"><tt>ca</tt></a>.<br>
        The default values is 8192.</dd>
      <dt><tt><a name="_rref"></a><b>rref</b>=<var>res</var></tt> - reference resistor </dt>
      <dd>Scale the denominator by <var><tt>res</tt></var> before any further processing. By default no scaling takes place.<br>
        This option could be used to compensate for constant factors of your measurement setup like a reference resistors to measure
        the current or the amplifier gain.</dd>
      <dt><tt><b><a name="_dcfg"></a>dcfg</b>=<var>filename</var></tt> - dump effective configuration to <tt><var>filename</var></tt></dt>
      <dd>When this option is activated all configuration parameters are saved to <tt><var>filename</var></tt> after all arguments
        have been parsed and before any other processing. This includes parameters that are not explicitly set. The file format is
        compatible to Analyze configuration files, i.e. can be used for configuration input. It can also be used for further
        processing e.g. by a program like Gnuplot.</dd>
    </dl>
    <h2><a name="input"></a>Input data options</h2>
    <dl compact="compact">
      <dt><tt><a name="_in"></a><b>in</b></tt>[<tt>=<var>filename</var></tt>] - name of input file</dt>
      <dd>Read PCM data to analyze from <var><tt>filename</tt></var>. If <var><tt>filename</tt></var> is <tt>-</tt> or omitted
        use <tt>stdin</tt>. The file name could be a transient source like a pipe or a character device.<br>
        This option implicitly enables the analysis part of the program. </dd>
      <dt><tt><a name="_wraw"></a><b>wraw</b></tt>[<tt>=<var>filename</var></tt>] -<tt> </tt>write raw data</dt>
      <dd>Write raw data to <var><tt>filename</tt></var>. If the filename is omitted the data is written to <tt>raw.dat</tt>.
        These is the raw input data without any processing so far, except for option <tt><a href="#_psa">psa</a></tt>. It is
        intended for diagnostics only. <a href="#raw_dat">&rarr; file format</a></dd>
      <dt><tt><a name="_psa"></a><b>psa</b>=<var>num</var></tt> - discard first <tt><var>num</var></tt> samples</dt>
      <dd>Use this to discard spikes at the starting or to reach a steady state. You may also use this option to discard headers
        from PCM files like RIFF wave format.</dd>
      <dt><tt><a name="_pte"></a><b>pte</b></tt> - discard trailing input<tt> </tt></dt>
      <dd>If the analysis has completed (option <a href="#_ln"><tt>ln</tt></a>) the input is read continuously, but the data is
        discarded. This can be useful if the data source behaves unexpectedly if the data drain is closed. This also causes analyze
        not to terminate before either the input stream is closed or an interrupt signal is received.</dd>
      <dt><tt><a name="_diff"></a><b>diff</b></tt> - differential input mode<tt></tt> </dt>
      <dd> normally: nominator or <var>U</var>(<var>t</var>) := channel 1 (L), denominator or <var>I</var>(<var>t</var>) :=
        channel 2 (R)<br>
        differential mode: nominator or <var>U</var>(<var>t</var>) := channel 1 (L), denominator or <var>I</var>(<var>t</var>) :=
        channel 2 &minus; channel 1 (R-L)<br>
        Differential mode is useful if you want to do impedance measurements without a differential instrumentation amplifier. You
        could simply use a series of a reference resistor with the unknown impedance. But note that the difference of similar
        numbers may become very sensitive to channel differences for low currents. It is recommended to use at least the <a href="#_hd">differential
          weight function</a> in FFT mode to reduce this kind of errors.</dd>
      <dt><a name="_xch"></a><tt><b>xch</b></tt> - swap input channels</dt>
      <dd>Swap left and right input channel. Normally the left channel contains the nominator and the right channel the denominator
        (reference). With this option the channels are swapped. You my combine this with <a href="#_diff">differential mode</a>.</dd>
      <dt><tt><a name="_al"></a><b>al</b>=<var>num</var></tt> - add <tt><var>num</var></tt> cycles</dt>
      <dd>Add <tt><var>num</var></tt> cycles of raw input data before starting analysis. This improves the SNR by the square root
        of <tt><var>num</var></tt>. Note that the reference signal must be cyclic to use this option.<br>
        This is effectively the same than taking a <var><tt>num</tt></var> times as large FFT size and taking only every <var><tt>num</tt></var>-th
        frequency channel, but it is significantly faster.</dd>
      <dt><tt><a name="_ainc"></a><b>ainc</b></tt> - incremental mode</dt>
      <dd>The raw input data is added in sets of the analysis length. This causes a increasing accuracy by building an average over
        more and more cycles. Note that the reference signal must be cyclic to use this option and it must be exactly synchronized
        to the sampling frequency.<br>
        This option is an alternative to sweep measurements.</dd>
      <dt><a name="_olf"></a><tt><b>olf</b>=<var>file</var></tt> - override nominator</dt>
      <dd>Override nominator (left channel by default) with a <a href="#_olc">column</a> from <var><tt>file</tt></var>.</dd>
      <dt><tt><a name="_olc"></a><b>olc</b>=<var>column</var></tt> - column to override numerator<tt><var> </var></tt></dt>
      <dd>Column in the file to override the nominator. Requires <a href="#_olf"><tt>olf</tt></a>.</dd>
      <dt><a name="_orf"></a><tt><b>orf</b>=</tt><var><tt>file</tt> - </var>override denominator</dt>
      <dd>Override denominator (right channel by default) with a <a href="#_orc">column</a> from <var><tt>file</tt></var>.</dd>
      <dt><tt><a name="_orc"></a><b>orc</b>=c<var>column</var></tt> - column to override denominator</dt>
      <dd>Column in the file to override the denominator. Requires <a href="#_orf"><tt>orf</tt></a>.</dd>
    </dl>
    <h2><a name="output"></a>Output data options</h2>
    <dl>
      <dt><tt><a name="_out"></a><b>out</b>=<var>filename</var></tt> - write reference PCM data to <tt><var>filename</var></tt></dt>
      <dd>Write PCM data to <var><tt>filename</tt></var>. If <var><tt>filename</tt></var> is <tt>-</tt> or omitted use <tt>stdout</tt>.
        The file name could be a transient drain like a pipe or a character device.<br>
        This option implicitly enables the reference generator part of the program.</dd>
      <dt><tt><a name="_gain"></a><b>gain</b>=<var>dB</var></tt> - master gain</dt>
      <dd>Apply this value in dB to the to 0dB FSR (<u>f</u>ull <u>s</u>can <u>r</u>ange) normalized reference output. Because of
        the scaling only negative values are reasonable.</dd>
      <dt><a name="_symmout"></a><b><tt>symmout</tt></b> - symmetric stereo output</dt>
      <dd>Invert the output of the second channel of single channel reference. This cannot be combined with <a href="#_stereo"><tt>stereo</tt></a>.</dd>
      <dt><a name="_scale"></a><tt><b>scale</b>=<var>power</var></tt> - noise type</dt>
      <dd>Exponent of the <a href="noise.html#method">energy distribution</a>. <tt>0</tt> := white noise, <tt>-1</tt> := pink
        noise. <tt>0</tt> by default.</dd>
      <dt><b><tt><a name="#_wspec"></a>rspec</tt></b>[<tt>=<var>filename</var></tt>] - read design spectrum of the reference signal</dt>
      <dd>Read the frequency domain reference signal from <var><tt>filename</tt></var> or <tt>spectrum.dat</tt> if <var><tt>filename</tt></var>
        is omitted. See <a href="fileformat.html#spectrum_dat">&rarr;&nbsp;file format</a>.<br>
        Using this option effectively disables all options related to the design spectrum creation, first of all <a href="#_fmin"><tt>fmin</tt></a>
        and <a href="#_fmax"><tt>fmax</tt></a>.</dd>
      <dt><b><tt><a name="#_wspec"></a>wspec</tt></b>[<tt>=<var>filename</var></tt>] - write design spectrum of the reference signal</dt>
      <dd>Writes the frequency domain reference signal to <var><tt>filename</tt></var> or <tt>spectrum.dat</tt> if <var><tt>filename</tt></var>
        is omitted. See <a href="fileformat.html#spectrum_dat">&rarr;&nbsp;file format</a>.</dd>
      <dt><tt><a name="#_wref"></a><b>wref</b></tt>[<tt>=<var>filename</var></tt>] - write time domain reference data</dt>
      <dd>Writes one cycle of the reference signal to <var><tt>filename</tt></var>. If the filename is omitted <tt>ref.dat</tt> is
        used. See <a href="fileformat.html#ref_dat">&rarr;&nbsp;file format</a>.<br>
        The file is written only at setup once unless sweep mode is used.</dd>
      <dt><a name="_aref"></a><b><tt>aref</tt></b><var> - </var>append reference data file</dt>
      <dd>Append the reference data file instead of overwriting it. This is useful in sweep mode to get not only the latest
        reference in the file. See also option <a href="#_wref"><tt>wref</tt></a>.</dd>
    </dl>
    <h2><a name="control"></a>Control options</h2>
    <dl compact="compact">
      <dt><tt><a name="_ln"></a><b>ln</b>=<var>num</var></tt> - number of cycles to process</dt>
      <dd>The program terminates automatically after <tt><var>num</var></tt> analysis cycles. By default only a a single analysis
        is done.<br>
        The value applies to each individual step of the measurement, i.e. twice for the <a href="calibration.html#matrix-cal">matrix
          calibration</a> and for each frequency in sweep mode.</dd>
      <dt><tt><a name="_loop"></a><b>loop</b> - </tt>do infinite analysis</dt>
      <dd>The program continue to analyze until the input data has been finished or it is interrupted by a signal. This is useful to
        reflect changes of you measurement item in near real time.<br>
        It is recommended to check whether real time processing is possible with a reasonable system load with a <a href="#_ln">limited
          number of cycles</a> before using this option on a infinite transient data source.</dd>
      <dt><tt><a name="_mfft"></a><b>mfft</b></tt> - FFT mode</dt>
      <dd>Activate FFT mode for analysis.</dd>
      <dt><tt><a name="_mpca"></a><b>mpca</b></tt> - PCA mode</dt>
      <dd>Activate PCA mode for analysis.</dd>
      <dt><tt><a name="_msweep"></a><b>msweep</b></tt> - enable sweep mode</dt>
      <dd>In sweep mode the distinct frequencies are measured one after each other. This takes considerably longer than the fast FFT
        mode but it is also more robust against non-linearities and ambient noise. See <a href="measure.html#sweep">documentation</a>
        for further details.</dd>
      <dt><a name="_stereo"></a><b><tt>stereo</tt></b> - two channel mode</dt>
      <dd>In two channel mode (<u>st</u>ereo) the used FFT frequencies are associated with two distinct channels alternatingly. This
        applies to the reference generator as well as to any averaging operation. A column in the result files indicates the channel
        association. Note that this doubles the measurement time in sweep mode. See multi <a href="#multichannel">multi channel
          measurements</a>.</dd>
      <dt><tt><a name="_setupcmd"></a><b>setupcmd</b>=<var>command</var></tt> - execute shell command at program start</dt>
      <dd>After parameter parsing but before any other action <var><tt>command</tt></var> is passed to <tt>system()</tt>.<br>
        Note that <tt>analyze</tt> waits for the command to complete. So you may setup some things that are used by other
        parameters here.</dd>
      <dt><tt><a name="_plot" id="_setupout"></a><b>setupout</b>=<var>command</var></tt> - pipe command before start at program
        start</dt>
      <dd>Write <var><tt>command</tt></var> to <tt>stdout</tt> after parameter parsing but before any other action.</dd>
      <dt><tt><a name="_initcmd"></a><b>initcmd</b>=<var>command</var></tt> - execute shell command before start of data processing</dt>
      <dd>Before the first input samples are processed <var><tt>command</tt></var> is passed to <tt>system()</tt>. At this point
        global output files like the <a href="#_wspec">reference design spectrum</a> have been written already.<br>
        Note that <tt>analyze</tt> waits for the command to complete. This gives you exclusive access to the data files. </dd>
      <dt><tt><a name="_plot" id="_initout"></a><b>initout</b>=<var>command</var></tt> - pipe command before start of data
        processing</dt>
      <dd>Write <var><tt>command</tt></var> to <tt>stdout</tt> before the first input samples are processed<span style="font-family: monospace;"></span>.
        At this point global output files like the <a href="#_wspec">reference design spectrum</a> have been written already.</dd>
      <dt><tt><a name="_plotcmd"></a><b>plotcmd</b>=<var>command</var></tt> - execute shell command when new data is available</dt>
      <dd>Each time a analysis is complete and the data has been written <var><tt>command</tt></var> is passed to <tt>system()</tt>.
        Note that <span style="font-family: monospace;">analyze</span> waits for the command to complete. This gives you exclusive
        access to the data files but it may also interfere with the real time processing of the input data. You may alternatively
        consider to pipe the command to <tt>stdout</tt> instead (option <a href="#_plotout"><tt>plotout</tt></a>), if you do not
        need this kind of synchronization. </dd>
      <dt><tt><a name="_plot" id="_plotout"></a><b>plotout</b>=<var>command</var></tt> - pipe command when new data is available</dt>
      <dd>Write <var><tt>command</tt></var> to <tt>stdout</tt> each time an analysis has completed. You can use this to
        synchronize plot programs when new data arrives.</dd>
      <dt><tt><a name="_postcmd"></a><b>postcmd</b>=<var>command</var></tt> - execute shell command after analysis has completed</dt>
      <dd>When all analysis steps have been completed <var><tt>command</tt></var> is passed to <tt>system()</tt>. Note that <span
          style="font-family: monospace;">analyze</span> waits for the command to complete. You may alternatively consider to pipe
        the command to <tt>stdout</tt> instead (option <a href="#_postout"><tt>postout</tt></a>), if you do not need this kind of
        synchronization. </dd>
      <dt><tt><a name="_plot" id="_postout"></a><b>postout</b>=<var>command</var></tt> - pipe command after analysis has completed</dt>
      <dd>When all analysis steps have been completed write <var><tt>command</tt></var> to <tt>stdout</tt>.</dd>
    </dl>
    <dl compact="compact">
    </dl>
    <h2><a name="FFT"></a>FFT parameter</h2>
    <dl compact="compact">
      <dt><tt><b><a name="_famin"></a>famin</b>=<var>freq</var></tt>, <b> </b><tt><b><a name="_famax"></a></b></tt><tt><b>famax</b>=<var>freq</var></tt>
        - frequency range for LCR analysis</dt>
      <dd>Minimum and maximum frequency for LCR data fit. This could be used to adapt the bandwidth of your setup. In contrast to <a
          href="#_fmin"><tt>fmin</tt></a> and <a href="#_fmax"><tt>fmax</tt></a> this has no influence on the data written to the <a
          href="#_wd">result file</a>. It applies only to the screen output (to <tt>stderr</tt>).</dd>
      <dt><tt><b><a name="_fmin"></a>fmin</b>=<var>freq</var></tt>, <tt><b><a name="_fmax"></a></b></tt> <b><tt>f</tt></b><tt><b>max</b>=<var>freq</var></tt>
        - frequency range</dt>
      <dd>Minimum and maximum frequency for the FFT analysis. This option applies to <em>all</em> processing steps including
        calculation of calibration etc. It could be used to remove artifacts at the frequency limits for graphical output. </dd>
      <dt><tt><a name="_h_f"></a><b>h/f</b></tt> - use <tt>1/<var>f</var></tt> weight</dt>
      <dd>This weight function can be useful for measurements with pink noise.</dd>
      <dt><tt><a name="_hd"></a><b>hd</b></tt> - weight function for differential mode</dt>
      <dd>Use adapted weight function for <a href="#_diff">differential input mode</a>.</dd>
      <dt><tt><a name="_he"></a><b>he</b></tt> - disable weights</dt>
      <dd>Use an equal distributed weight function. Use this if your input SNR has no correlation with the signal amplitude at a
        certain frequency.</dd>
      <dt><tt><a name="_bin"></a><b>bin</b>=<var>size</var></tt> - average <var><tt>size</tt></var> FFT channels</dt>
      <dd>Calculates the average over <var><tt>size</tt></var> subsequent frequency channels before any further processing. The
        averaging is done in polar coordinates so phase noise does not degrade the amplitude.<br>
        This could be used to reduce noise if the measurement response is not likely to change fast with frequency. But if your
        reference signal is periodic you should prefer a shorter block length together with <a href="#_al">averaging input samples</a>.
      </dd>
      <dt><tt><a name="_fbin"></a><b>fbin</b>=<var>factor</var></tt> - average FFT channels logarithmically</dt>
      <dd>Calculates the average over <var><tt>size</tt></var> subsequent frequency channels to get approximately logarithmic
        frequency bins. The channels are averaged as long as they fit into the interval [<var>f</var>,&nbsp;<var>f</var>&nbsp;&middot;&nbsp;(<tt><var>factor</var></tt>&nbsp;+&nbsp;1)].
This
        option is particularly useful if the properties of the object tend to change over log&nbsp;<var>f</var> rather than <var>f</var>.
        In other words if the result is shown with logarithmic frequency axis.</dd>
      <dt><tt><a name="_finc"></a><b>finc</b>=<var>channels</var></tt>, <tt><a name="_flog"></a><b>flog</b>=<var>factor</var></tt>
        - linear and logarithmic increment for used frequencies </dt>
      <dd>This is intended to be used with custom, discrete energy distributions. Subsequent used frequencies have at least the
        distance <var>f<sub>n+1</sub>&nbsp;= f<sub>n</sub></var>&nbsp;&middot; <tt><var>factor</var> + <var>channels</var></tt>
        rounded to the closest frequency in the FFT result. Any channels in between are ignored.</dd>
      <dt><tt><a name="_harm"></a><b>harm</b>=<var>n</var></tt> - use harmonics</dt>
      <dd>With this option the first <i><tt>n</tt></i> harmonics of any used frequency is reserved. In fact it is assumed that the
        reference signal does not contain energy at these frequencies and any response is the result of harmonic distortion. This
        could be used to do very fast measurements of harmonics of loudspeakers.<br>
        The setting must be chosen to <a href="noise.html#_finc">match the reference signal</a>. See <a href="#harmonics">analysis
          of harmonics</a>.</dd>
      <dt><tt><a name="_pch"></a><b>pch</b>=<var>num</var></tt> - purge low FFT channels</dt>
      <dd>This assigns zero to the first <var><tt>num</tt></var> channels of the FFT result. It is alternative to <a href="#_fmin"><tt>fmin</tt></a>
        that does not remove the lines from the data file and avoids uninitialized values in calibration files. But be careful not
        to use these coefficients as denominator of some following calculation step. To avoid division by zero exceptions a very
        small value is used rather than zero. </dd>
      <dt><tt><a name="_phcc"></a><b>phcc</b></tt> - fit group delay<tt> </tt></dt>
      <dd>This option fits the group delay by calculation of the center of the cross correlation of the wanted signal and the
        reference signal.</dd>
      <dd>The option is required if the wanted and the reference data are only synchronized at the sampling frequency but not at the
        origin of the cycle. Otherwise degradation of amplitude at higher frequencies when averaging of frequency channels is used
        may occur, because of errors in phase unwrapping. With this option activated the result is written to <tt>stderr</tt>
        additionally. The fitted group delay is removed from the output file in this case.</dd>
      <dt><tt><a name="_phl"></a><b>phl</b>=<var>delay</var></tt> - subtract group delay</dt>
      <dd>Adjusts the phase data by exp(i <var>&omega; <tt>delay</tt></var>). <var><tt>delay</tt></var> is in seconds.</dd>
      <dt><tt><a name="_wd"></a><b>wd</b></tt>[<tt>=<var>filename</var></tt>] - write FFT data<tt> </tt></dt>
      <dd>Write detailed result of FFT analysis to <var><tt>filename</tt></var>. If <tt>=<var>filename</var></tt> is omitted the
        data is written to file <tt>data.dat</tt>. <a href="fileformat.html#data_dat">&rarr; file format</a></dd>
      <dt><tt><a name="_win"></a><b>win</b>=<var>typ</var></tt> - window function</dt>
      <dd>Apply window function to data before FFT. The following window functions are implemented:<br>
        <tt>win=0</tt> &ndash; rectangular = none (default)<br>
        <tt>win=1</tt> &ndash; Bartlett window = triangular, abs(2&nbsp;<var>i</var>/<var>n</var> 1)<br>
        <tt>win=2</tt> &ndash; Hanning window, .5 + .5&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)<br>
        <tt>win=3</tt> &ndash; Hamming window, .54 + .46&nbsp;cos(2 <var>i</var>/<var>n</var>)<br>
        <tt>win=4</tt> &ndash; Blackman window, .42 + .5&nbsp;cos(2&pi; <var>i</var>/<var>n</var>) +&nbsp;.08&nbsp;cos(4&pi; <var>i</var>/<var>n</var>)<br>
        <tt>win=5</tt> &ndash; Blackman Harris window, .35875 + .48829&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)
        +&nbsp;.14128&nbsp;cos(4&pi; <var>i</var>/<var>n</var>) + .01168&nbsp;cos(2&pi; <var>i</var>/<var>n</var>)<br>
        A window function is only recommended if the reference signal cannot be made cyclic or the DAC and ADC do not operate
        coherent.</dd>
      <dt><tt><a name="_wwin"></a><b>wwin</b></tt>[<tt>=<var>filename</var></tt>] - write window function</dt>
      <dd>This option writes the selected window function (option <a href="#_win"><tt>win</tt></a>) to&nbsp;<tt><var>filename</var></tt>.
        If <tt>=<var>filename</var></tt> is omitted the window data is written to file <tt>window.dat</tt>. <a href="fileformat.html#window_dat">&rarr;
          file format</a></dd>
      <dt><a name="_zn"></a><b><tt>zn</tt></b> - normalize amplitudes</dt>
      <dd>Adjust the sum of the complex amplitudes of nominator and denominator to 1. This has no effect on impedance or transfer
        function, but it gets important if you relate data of different measurements as e.g. the matrix calibration does.</dd>
    </dl>
    <h2><a name="synchronize"></a>Synchronization options</h2>
    <dl>
      <dt><a name="_sync"></a><b><tt>sync</tt></b>[<tt>=<var>count</var></tt>] - synchronize before start</dt>
      <dd>Generate sync pattern before the reference signal for <tt><var>count</var></tt> cycles - by default 2.<br>
        This option also enables the synchronization before the main analysis starts. This takes the average group delay in the
        frequency range <a href="#_famin"><tt>famin</tt></a> to <a href="#_famax"><tt>famax</tt></a> and discards samples unless
        the synchronization pattern has completed.<br>
        This option is <em>strongly recommended for sweep mode</em> because otherwise you might not measure the frequency that you
        intend.</dd>
      <dt><a name="_synclvl"></a><b><tt>synclvl</tt></b><tt>=<var>level</var></tt> - minimum SNR level of the cross correlation
        compared to the auto correlation of the sync reference</dt>
      <dd>This level controls when input samples are considered to be a valid synchronization signal. It is a relative value.</dd>
      <dt><a name="_syncmod"></a><b><tt>syncmod</tt></b><tt>=<var>depth</var></tt> - modulation of synchronization pattern, range [<tt>0.0</tt>,
        <tt>1.0</tt>]</dt>
      <dd>If activated the sync pattern is modulated with the sync cycle number. This causes the amplitude of every 11th frequency
        to be reduced by this modulation factor.<br>
        Using modulation simplifies the detection of the end of the synchronization pattern. But it also introduces some distortion
        due to the modulation side bands.</dd>
      <dt><a name="_predelay"></a><tt><b>predelay</b>=cycles<var></var></tt> - time to setup in FFT cycles</dt>
      <dd>Number of FFT cycles used for setup. This is a fractional number. Since the total time used must be a multiple of the FFT
        length an additional gap is inserted at the <i>end</i> of the measurement to match the next whole number. Example:<br>
        The default value of <tt>0.95</tt> causes the measurement to take <tt><a href="#_ln">ln</a></tt> + 1 FFT cycles. 95% of an
        FFT cycle is the setup delay, then the measurement starts and after the measurement the remaining 5% of the FFT cycle the
        current reference is kept.<br>
        This is especially important in&nbsp;<a href="measure.html#sweep">sweep mode</a> where the reference changes after each
        frequency. It is a good advise not to use a whole number for this parameter in this case because otherwise small deviations
        at synchronization might degrade the measurement.</dd>
    </dl>
    <h2><a name="calibrate"></a>Calibration options</h2>
    <dl compact="compact">
      <dt><tt><a name="_gg"></a><b>gg</b></tt>[<tt>=<var>filename</var></tt>] - do <a href="calibration.html#gain-cal">gain
          calibration</a></dt>
      <dd>The left and right channel is assumed to sample the same signal. The difference in the transfer functions is written to <tt><var>filename</var></tt>.
        If <tt>=<var>filename</var></tt> is omitted the calibration data is written to file <tt>gain.dat</tt>. <a href="fileformat.html#gain_dat">&rarr;
          file format</a></dd>
      <dt><tt><a name="_gr"></a><b>gr</b></tt>[<tt>=<var>filename</var></tt>] - apply gain calibration</dt>
      <dd>The result from an earlier <a href="calibration.html#gain-cal">gain calibration</a> is read from <tt><var>filename</var></tt>
        and applied to the data before any further processing. If <tt>=<var>filename</var></tt> is omitted the calibration data is
        read from <tt>gain.dat</tt>. <a href="fileformat.html#gain.dat">&rarr; file format</a><br>
        The calibration is arbitrarily applied to the nominator signal. So you should not abuse the gain calibration to compensate
        for complex transfer functions, because the weight functions would be affected too.<br>
        If you combine this option with <a href="#_gg"><tt>gg</tt></a> the result from an earlier <a href="calibration.html#gain-cal">gain
          calibration</a> is applied to the data before another gain calibration is done. The residual result is written to the gain
        calibration file.</dd>
      <dt><tt><a name="_zg"></a><b>zg</b></tt>[<tt>=<var>filename</var></tt>] - do <a href="#matrix-cal">matrix calibration</a></dt>
      <dd>Generate the matrix calibration file. The Matrix calibration operates in two steps. In the first step the reference signal
        should be zero, in the second step the wanted signal should be zero. Between the steps there is a <a href="#_lp">configured
          pause</a> to adjust the setup. See <a href="#matrix-cal">documentation</a> for further details.<br>
        If <tt>=<var>filename</var></tt> is omitted the calibration data is written to file <tt>zero.dat</tt>.</dd>
      <dt><tt><a name="_zr"></a><b>zr</b></tt>[<tt>=<var>filename</var></tt>] - apply matrix calibration</dt>
      <dd>Use the <a href="#matrix-cal">matrix calibration</a> from <tt><var>filename</var></tt> and apply it to the input data. <br>
        If <tt>=<var>filename</var></tt> is omitted the calibration data is read from <tt>zero.dat</tt>. <a href="fileformat.html#gain_dat">&rarr;
          file format</a><br>
        If this option is combined with <a href="#_zg"><tt>zg</tt></a> then the result from an earlier <a href="#matrix-cal">matrix
          calibration</a> is applied to the input data while another matrix calibration is done. The residuals are written to the
        matrix calibration file.</dd>
      <dt><tt><a name="_lp"></a><b>lp</b>=<var>secs</var></tt> - pause between matrix calibration steps</dt>
      <dd>Number of seconds between the two steps of the matrix calibration (option <tt><a href="#_zg">zg</a></tt>). The time is
        rounded up to full <a href="#_n">blocks</a>.</dd>
    </dl>
  </body>
</html>
